#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/ftrace/android_fs.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

AndroidFsFsyncStartFtraceEvent::AndroidFsFsyncStartFtraceEvent() = default;
AndroidFsFsyncStartFtraceEvent::~AndroidFsFsyncStartFtraceEvent() = default;
AndroidFsFsyncStartFtraceEvent::AndroidFsFsyncStartFtraceEvent(const AndroidFsFsyncStartFtraceEvent&) = default;
AndroidFsFsyncStartFtraceEvent& AndroidFsFsyncStartFtraceEvent::operator=(const AndroidFsFsyncStartFtraceEvent&) = default;
AndroidFsFsyncStartFtraceEvent::AndroidFsFsyncStartFtraceEvent(AndroidFsFsyncStartFtraceEvent&&) noexcept = default;
AndroidFsFsyncStartFtraceEvent& AndroidFsFsyncStartFtraceEvent::operator=(AndroidFsFsyncStartFtraceEvent&&) = default;

bool AndroidFsFsyncStartFtraceEvent::operator==(const AndroidFsFsyncStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && cmdline_ == other.cmdline_
   && i_size_ == other.i_size_
   && ino_ == other.ino_
   && pathbuf_ == other.pathbuf_
   && pid_ == other.pid_;
}

bool AndroidFsFsyncStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* cmdline */:
        field.get(&cmdline_);
        break;
      case 2 /* i_size */:
        field.get(&i_size_);
        break;
      case 3 /* ino */:
        field.get(&ino_);
        break;
      case 4 /* pathbuf */:
        field.get(&pathbuf_);
        break;
      case 5 /* pid */:
        field.get(&pid_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AndroidFsFsyncStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AndroidFsFsyncStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AndroidFsFsyncStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: cmdline
  if (_has_field_[1]) {
    msg->AppendString(1, cmdline_);
  }

  // Field 2: i_size
  if (_has_field_[2]) {
    msg->AppendVarInt(2, i_size_);
  }

  // Field 3: ino
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ino_);
  }

  // Field 4: pathbuf
  if (_has_field_[4]) {
    msg->AppendString(4, pathbuf_);
  }

  // Field 5: pid
  if (_has_field_[5]) {
    msg->AppendVarInt(5, pid_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AndroidFsFsyncEndFtraceEvent::AndroidFsFsyncEndFtraceEvent() = default;
AndroidFsFsyncEndFtraceEvent::~AndroidFsFsyncEndFtraceEvent() = default;
AndroidFsFsyncEndFtraceEvent::AndroidFsFsyncEndFtraceEvent(const AndroidFsFsyncEndFtraceEvent&) = default;
AndroidFsFsyncEndFtraceEvent& AndroidFsFsyncEndFtraceEvent::operator=(const AndroidFsFsyncEndFtraceEvent&) = default;
AndroidFsFsyncEndFtraceEvent::AndroidFsFsyncEndFtraceEvent(AndroidFsFsyncEndFtraceEvent&&) noexcept = default;
AndroidFsFsyncEndFtraceEvent& AndroidFsFsyncEndFtraceEvent::operator=(AndroidFsFsyncEndFtraceEvent&&) = default;

bool AndroidFsFsyncEndFtraceEvent::operator==(const AndroidFsFsyncEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && bytes_ == other.bytes_
   && ino_ == other.ino_
   && offset_ == other.offset_;
}

bool AndroidFsFsyncEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* bytes */:
        field.get(&bytes_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* offset */:
        field.get(&offset_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AndroidFsFsyncEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AndroidFsFsyncEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AndroidFsFsyncEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: bytes
  if (_has_field_[1]) {
    msg->AppendVarInt(1, bytes_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: offset
  if (_has_field_[3]) {
    msg->AppendVarInt(3, offset_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AndroidFsDatawriteStartFtraceEvent::AndroidFsDatawriteStartFtraceEvent() = default;
AndroidFsDatawriteStartFtraceEvent::~AndroidFsDatawriteStartFtraceEvent() = default;
AndroidFsDatawriteStartFtraceEvent::AndroidFsDatawriteStartFtraceEvent(const AndroidFsDatawriteStartFtraceEvent&) = default;
AndroidFsDatawriteStartFtraceEvent& AndroidFsDatawriteStartFtraceEvent::operator=(const AndroidFsDatawriteStartFtraceEvent&) = default;
AndroidFsDatawriteStartFtraceEvent::AndroidFsDatawriteStartFtraceEvent(AndroidFsDatawriteStartFtraceEvent&&) noexcept = default;
AndroidFsDatawriteStartFtraceEvent& AndroidFsDatawriteStartFtraceEvent::operator=(AndroidFsDatawriteStartFtraceEvent&&) = default;

bool AndroidFsDatawriteStartFtraceEvent::operator==(const AndroidFsDatawriteStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && bytes_ == other.bytes_
   && cmdline_ == other.cmdline_
   && i_size_ == other.i_size_
   && ino_ == other.ino_
   && offset_ == other.offset_
   && pathbuf_ == other.pathbuf_
   && pid_ == other.pid_;
}

bool AndroidFsDatawriteStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* bytes */:
        field.get(&bytes_);
        break;
      case 2 /* cmdline */:
        field.get(&cmdline_);
        break;
      case 3 /* i_size */:
        field.get(&i_size_);
        break;
      case 4 /* ino */:
        field.get(&ino_);
        break;
      case 5 /* offset */:
        field.get(&offset_);
        break;
      case 6 /* pathbuf */:
        field.get(&pathbuf_);
        break;
      case 7 /* pid */:
        field.get(&pid_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AndroidFsDatawriteStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AndroidFsDatawriteStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AndroidFsDatawriteStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: bytes
  if (_has_field_[1]) {
    msg->AppendVarInt(1, bytes_);
  }

  // Field 2: cmdline
  if (_has_field_[2]) {
    msg->AppendString(2, cmdline_);
  }

  // Field 3: i_size
  if (_has_field_[3]) {
    msg->AppendVarInt(3, i_size_);
  }

  // Field 4: ino
  if (_has_field_[4]) {
    msg->AppendVarInt(4, ino_);
  }

  // Field 5: offset
  if (_has_field_[5]) {
    msg->AppendVarInt(5, offset_);
  }

  // Field 6: pathbuf
  if (_has_field_[6]) {
    msg->AppendString(6, pathbuf_);
  }

  // Field 7: pid
  if (_has_field_[7]) {
    msg->AppendVarInt(7, pid_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AndroidFsDatawriteEndFtraceEvent::AndroidFsDatawriteEndFtraceEvent() = default;
AndroidFsDatawriteEndFtraceEvent::~AndroidFsDatawriteEndFtraceEvent() = default;
AndroidFsDatawriteEndFtraceEvent::AndroidFsDatawriteEndFtraceEvent(const AndroidFsDatawriteEndFtraceEvent&) = default;
AndroidFsDatawriteEndFtraceEvent& AndroidFsDatawriteEndFtraceEvent::operator=(const AndroidFsDatawriteEndFtraceEvent&) = default;
AndroidFsDatawriteEndFtraceEvent::AndroidFsDatawriteEndFtraceEvent(AndroidFsDatawriteEndFtraceEvent&&) noexcept = default;
AndroidFsDatawriteEndFtraceEvent& AndroidFsDatawriteEndFtraceEvent::operator=(AndroidFsDatawriteEndFtraceEvent&&) = default;

bool AndroidFsDatawriteEndFtraceEvent::operator==(const AndroidFsDatawriteEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && bytes_ == other.bytes_
   && ino_ == other.ino_
   && offset_ == other.offset_;
}

bool AndroidFsDatawriteEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* bytes */:
        field.get(&bytes_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* offset */:
        field.get(&offset_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AndroidFsDatawriteEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AndroidFsDatawriteEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AndroidFsDatawriteEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: bytes
  if (_has_field_[1]) {
    msg->AppendVarInt(1, bytes_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: offset
  if (_has_field_[3]) {
    msg->AppendVarInt(3, offset_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AndroidFsDatareadStartFtraceEvent::AndroidFsDatareadStartFtraceEvent() = default;
AndroidFsDatareadStartFtraceEvent::~AndroidFsDatareadStartFtraceEvent() = default;
AndroidFsDatareadStartFtraceEvent::AndroidFsDatareadStartFtraceEvent(const AndroidFsDatareadStartFtraceEvent&) = default;
AndroidFsDatareadStartFtraceEvent& AndroidFsDatareadStartFtraceEvent::operator=(const AndroidFsDatareadStartFtraceEvent&) = default;
AndroidFsDatareadStartFtraceEvent::AndroidFsDatareadStartFtraceEvent(AndroidFsDatareadStartFtraceEvent&&) noexcept = default;
AndroidFsDatareadStartFtraceEvent& AndroidFsDatareadStartFtraceEvent::operator=(AndroidFsDatareadStartFtraceEvent&&) = default;

bool AndroidFsDatareadStartFtraceEvent::operator==(const AndroidFsDatareadStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && bytes_ == other.bytes_
   && cmdline_ == other.cmdline_
   && i_size_ == other.i_size_
   && ino_ == other.ino_
   && offset_ == other.offset_
   && pathbuf_ == other.pathbuf_
   && pid_ == other.pid_;
}

bool AndroidFsDatareadStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* bytes */:
        field.get(&bytes_);
        break;
      case 2 /* cmdline */:
        field.get(&cmdline_);
        break;
      case 3 /* i_size */:
        field.get(&i_size_);
        break;
      case 4 /* ino */:
        field.get(&ino_);
        break;
      case 5 /* offset */:
        field.get(&offset_);
        break;
      case 6 /* pathbuf */:
        field.get(&pathbuf_);
        break;
      case 7 /* pid */:
        field.get(&pid_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AndroidFsDatareadStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AndroidFsDatareadStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AndroidFsDatareadStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: bytes
  if (_has_field_[1]) {
    msg->AppendVarInt(1, bytes_);
  }

  // Field 2: cmdline
  if (_has_field_[2]) {
    msg->AppendString(2, cmdline_);
  }

  // Field 3: i_size
  if (_has_field_[3]) {
    msg->AppendVarInt(3, i_size_);
  }

  // Field 4: ino
  if (_has_field_[4]) {
    msg->AppendVarInt(4, ino_);
  }

  // Field 5: offset
  if (_has_field_[5]) {
    msg->AppendVarInt(5, offset_);
  }

  // Field 6: pathbuf
  if (_has_field_[6]) {
    msg->AppendString(6, pathbuf_);
  }

  // Field 7: pid
  if (_has_field_[7]) {
    msg->AppendVarInt(7, pid_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AndroidFsDatareadEndFtraceEvent::AndroidFsDatareadEndFtraceEvent() = default;
AndroidFsDatareadEndFtraceEvent::~AndroidFsDatareadEndFtraceEvent() = default;
AndroidFsDatareadEndFtraceEvent::AndroidFsDatareadEndFtraceEvent(const AndroidFsDatareadEndFtraceEvent&) = default;
AndroidFsDatareadEndFtraceEvent& AndroidFsDatareadEndFtraceEvent::operator=(const AndroidFsDatareadEndFtraceEvent&) = default;
AndroidFsDatareadEndFtraceEvent::AndroidFsDatareadEndFtraceEvent(AndroidFsDatareadEndFtraceEvent&&) noexcept = default;
AndroidFsDatareadEndFtraceEvent& AndroidFsDatareadEndFtraceEvent::operator=(AndroidFsDatareadEndFtraceEvent&&) = default;

bool AndroidFsDatareadEndFtraceEvent::operator==(const AndroidFsDatareadEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && bytes_ == other.bytes_
   && ino_ == other.ino_
   && offset_ == other.offset_;
}

bool AndroidFsDatareadEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* bytes */:
        field.get(&bytes_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* offset */:
        field.get(&offset_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AndroidFsDatareadEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AndroidFsDatareadEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AndroidFsDatareadEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: bytes
  if (_has_field_[1]) {
    msg->AppendVarInt(1, bytes_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: offset
  if (_has_field_[3]) {
    msg->AppendVarInt(3, offset_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
