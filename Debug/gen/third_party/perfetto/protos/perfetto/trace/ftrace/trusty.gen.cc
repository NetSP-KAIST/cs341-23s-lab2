#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/ftrace/trusty.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

TrustyEnqueueNopFtraceEvent::TrustyEnqueueNopFtraceEvent() = default;
TrustyEnqueueNopFtraceEvent::~TrustyEnqueueNopFtraceEvent() = default;
TrustyEnqueueNopFtraceEvent::TrustyEnqueueNopFtraceEvent(const TrustyEnqueueNopFtraceEvent&) = default;
TrustyEnqueueNopFtraceEvent& TrustyEnqueueNopFtraceEvent::operator=(const TrustyEnqueueNopFtraceEvent&) = default;
TrustyEnqueueNopFtraceEvent::TrustyEnqueueNopFtraceEvent(TrustyEnqueueNopFtraceEvent&&) noexcept = default;
TrustyEnqueueNopFtraceEvent& TrustyEnqueueNopFtraceEvent::operator=(TrustyEnqueueNopFtraceEvent&&) = default;

bool TrustyEnqueueNopFtraceEvent::operator==(const TrustyEnqueueNopFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && arg1_ == other.arg1_
   && arg2_ == other.arg2_
   && arg3_ == other.arg3_;
}

bool TrustyEnqueueNopFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* arg1 */:
        field.get(&arg1_);
        break;
      case 2 /* arg2 */:
        field.get(&arg2_);
        break;
      case 3 /* arg3 */:
        field.get(&arg3_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyEnqueueNopFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyEnqueueNopFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyEnqueueNopFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: arg1
  if (_has_field_[1]) {
    msg->AppendVarInt(1, arg1_);
  }

  // Field 2: arg2
  if (_has_field_[2]) {
    msg->AppendVarInt(2, arg2_);
  }

  // Field 3: arg3
  if (_has_field_[3]) {
    msg->AppendVarInt(3, arg3_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyIpcRxFtraceEvent::TrustyIpcRxFtraceEvent() = default;
TrustyIpcRxFtraceEvent::~TrustyIpcRxFtraceEvent() = default;
TrustyIpcRxFtraceEvent::TrustyIpcRxFtraceEvent(const TrustyIpcRxFtraceEvent&) = default;
TrustyIpcRxFtraceEvent& TrustyIpcRxFtraceEvent::operator=(const TrustyIpcRxFtraceEvent&) = default;
TrustyIpcRxFtraceEvent::TrustyIpcRxFtraceEvent(TrustyIpcRxFtraceEvent&&) noexcept = default;
TrustyIpcRxFtraceEvent& TrustyIpcRxFtraceEvent::operator=(TrustyIpcRxFtraceEvent&&) = default;

bool TrustyIpcRxFtraceEvent::operator==(const TrustyIpcRxFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && buf_id_ == other.buf_id_
   && chan_ == other.chan_
   && srv_name_ == other.srv_name_;
}

bool TrustyIpcRxFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* buf_id */:
        field.get(&buf_id_);
        break;
      case 2 /* chan */:
        field.get(&chan_);
        break;
      case 3 /* srv_name */:
        field.get(&srv_name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyIpcRxFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyIpcRxFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyIpcRxFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: buf_id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, buf_id_);
  }

  // Field 2: chan
  if (_has_field_[2]) {
    msg->AppendVarInt(2, chan_);
  }

  // Field 3: srv_name
  if (_has_field_[3]) {
    msg->AppendString(3, srv_name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyIpcReadEndFtraceEvent::TrustyIpcReadEndFtraceEvent() = default;
TrustyIpcReadEndFtraceEvent::~TrustyIpcReadEndFtraceEvent() = default;
TrustyIpcReadEndFtraceEvent::TrustyIpcReadEndFtraceEvent(const TrustyIpcReadEndFtraceEvent&) = default;
TrustyIpcReadEndFtraceEvent& TrustyIpcReadEndFtraceEvent::operator=(const TrustyIpcReadEndFtraceEvent&) = default;
TrustyIpcReadEndFtraceEvent::TrustyIpcReadEndFtraceEvent(TrustyIpcReadEndFtraceEvent&&) noexcept = default;
TrustyIpcReadEndFtraceEvent& TrustyIpcReadEndFtraceEvent::operator=(TrustyIpcReadEndFtraceEvent&&) = default;

bool TrustyIpcReadEndFtraceEvent::operator==(const TrustyIpcReadEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && buf_id_ == other.buf_id_
   && chan_ == other.chan_
   && len_or_err_ == other.len_or_err_
   && shm_cnt_ == other.shm_cnt_
   && srv_name_ == other.srv_name_;
}

bool TrustyIpcReadEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* buf_id */:
        field.get(&buf_id_);
        break;
      case 2 /* chan */:
        field.get(&chan_);
        break;
      case 3 /* len_or_err */:
        field.get(&len_or_err_);
        break;
      case 4 /* shm_cnt */:
        field.get(&shm_cnt_);
        break;
      case 5 /* srv_name */:
        field.get(&srv_name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyIpcReadEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyIpcReadEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyIpcReadEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: buf_id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, buf_id_);
  }

  // Field 2: chan
  if (_has_field_[2]) {
    msg->AppendVarInt(2, chan_);
  }

  // Field 3: len_or_err
  if (_has_field_[3]) {
    msg->AppendVarInt(3, len_or_err_);
  }

  // Field 4: shm_cnt
  if (_has_field_[4]) {
    msg->AppendVarInt(4, shm_cnt_);
  }

  // Field 5: srv_name
  if (_has_field_[5]) {
    msg->AppendString(5, srv_name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyIpcReadFtraceEvent::TrustyIpcReadFtraceEvent() = default;
TrustyIpcReadFtraceEvent::~TrustyIpcReadFtraceEvent() = default;
TrustyIpcReadFtraceEvent::TrustyIpcReadFtraceEvent(const TrustyIpcReadFtraceEvent&) = default;
TrustyIpcReadFtraceEvent& TrustyIpcReadFtraceEvent::operator=(const TrustyIpcReadFtraceEvent&) = default;
TrustyIpcReadFtraceEvent::TrustyIpcReadFtraceEvent(TrustyIpcReadFtraceEvent&&) noexcept = default;
TrustyIpcReadFtraceEvent& TrustyIpcReadFtraceEvent::operator=(TrustyIpcReadFtraceEvent&&) = default;

bool TrustyIpcReadFtraceEvent::operator==(const TrustyIpcReadFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && chan_ == other.chan_
   && srv_name_ == other.srv_name_;
}

bool TrustyIpcReadFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* chan */:
        field.get(&chan_);
        break;
      case 2 /* srv_name */:
        field.get(&srv_name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyIpcReadFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyIpcReadFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyIpcReadFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: chan
  if (_has_field_[1]) {
    msg->AppendVarInt(1, chan_);
  }

  // Field 2: srv_name
  if (_has_field_[2]) {
    msg->AppendString(2, srv_name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyIpcPollFtraceEvent::TrustyIpcPollFtraceEvent() = default;
TrustyIpcPollFtraceEvent::~TrustyIpcPollFtraceEvent() = default;
TrustyIpcPollFtraceEvent::TrustyIpcPollFtraceEvent(const TrustyIpcPollFtraceEvent&) = default;
TrustyIpcPollFtraceEvent& TrustyIpcPollFtraceEvent::operator=(const TrustyIpcPollFtraceEvent&) = default;
TrustyIpcPollFtraceEvent::TrustyIpcPollFtraceEvent(TrustyIpcPollFtraceEvent&&) noexcept = default;
TrustyIpcPollFtraceEvent& TrustyIpcPollFtraceEvent::operator=(TrustyIpcPollFtraceEvent&&) = default;

bool TrustyIpcPollFtraceEvent::operator==(const TrustyIpcPollFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && chan_ == other.chan_
   && poll_mask_ == other.poll_mask_
   && srv_name_ == other.srv_name_;
}

bool TrustyIpcPollFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* chan */:
        field.get(&chan_);
        break;
      case 2 /* poll_mask */:
        field.get(&poll_mask_);
        break;
      case 3 /* srv_name */:
        field.get(&srv_name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyIpcPollFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyIpcPollFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyIpcPollFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: chan
  if (_has_field_[1]) {
    msg->AppendVarInt(1, chan_);
  }

  // Field 2: poll_mask
  if (_has_field_[2]) {
    msg->AppendVarInt(2, poll_mask_);
  }

  // Field 3: srv_name
  if (_has_field_[3]) {
    msg->AppendString(3, srv_name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyIpcWriteFtraceEvent::TrustyIpcWriteFtraceEvent() = default;
TrustyIpcWriteFtraceEvent::~TrustyIpcWriteFtraceEvent() = default;
TrustyIpcWriteFtraceEvent::TrustyIpcWriteFtraceEvent(const TrustyIpcWriteFtraceEvent&) = default;
TrustyIpcWriteFtraceEvent& TrustyIpcWriteFtraceEvent::operator=(const TrustyIpcWriteFtraceEvent&) = default;
TrustyIpcWriteFtraceEvent::TrustyIpcWriteFtraceEvent(TrustyIpcWriteFtraceEvent&&) noexcept = default;
TrustyIpcWriteFtraceEvent& TrustyIpcWriteFtraceEvent::operator=(TrustyIpcWriteFtraceEvent&&) = default;

bool TrustyIpcWriteFtraceEvent::operator==(const TrustyIpcWriteFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && buf_id_ == other.buf_id_
   && chan_ == other.chan_
   && kind_shm_ == other.kind_shm_
   && len_or_err_ == other.len_or_err_
   && shm_cnt_ == other.shm_cnt_
   && srv_name_ == other.srv_name_;
}

bool TrustyIpcWriteFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* buf_id */:
        field.get(&buf_id_);
        break;
      case 2 /* chan */:
        field.get(&chan_);
        break;
      case 3 /* kind_shm */:
        field.get(&kind_shm_);
        break;
      case 4 /* len_or_err */:
        field.get(&len_or_err_);
        break;
      case 5 /* shm_cnt */:
        field.get(&shm_cnt_);
        break;
      case 6 /* srv_name */:
        field.get(&srv_name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyIpcWriteFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyIpcWriteFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyIpcWriteFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: buf_id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, buf_id_);
  }

  // Field 2: chan
  if (_has_field_[2]) {
    msg->AppendVarInt(2, chan_);
  }

  // Field 3: kind_shm
  if (_has_field_[3]) {
    msg->AppendVarInt(3, kind_shm_);
  }

  // Field 4: len_or_err
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_or_err_);
  }

  // Field 5: shm_cnt
  if (_has_field_[5]) {
    msg->AppendVarInt(5, shm_cnt_);
  }

  // Field 6: srv_name
  if (_has_field_[6]) {
    msg->AppendString(6, srv_name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyIpcConnectEndFtraceEvent::TrustyIpcConnectEndFtraceEvent() = default;
TrustyIpcConnectEndFtraceEvent::~TrustyIpcConnectEndFtraceEvent() = default;
TrustyIpcConnectEndFtraceEvent::TrustyIpcConnectEndFtraceEvent(const TrustyIpcConnectEndFtraceEvent&) = default;
TrustyIpcConnectEndFtraceEvent& TrustyIpcConnectEndFtraceEvent::operator=(const TrustyIpcConnectEndFtraceEvent&) = default;
TrustyIpcConnectEndFtraceEvent::TrustyIpcConnectEndFtraceEvent(TrustyIpcConnectEndFtraceEvent&&) noexcept = default;
TrustyIpcConnectEndFtraceEvent& TrustyIpcConnectEndFtraceEvent::operator=(TrustyIpcConnectEndFtraceEvent&&) = default;

bool TrustyIpcConnectEndFtraceEvent::operator==(const TrustyIpcConnectEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && chan_ == other.chan_
   && err_ == other.err_
   && state_ == other.state_;
}

bool TrustyIpcConnectEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* chan */:
        field.get(&chan_);
        break;
      case 2 /* err */:
        field.get(&err_);
        break;
      case 3 /* state */:
        field.get(&state_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyIpcConnectEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyIpcConnectEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyIpcConnectEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: chan
  if (_has_field_[1]) {
    msg->AppendVarInt(1, chan_);
  }

  // Field 2: err
  if (_has_field_[2]) {
    msg->AppendVarInt(2, err_);
  }

  // Field 3: state
  if (_has_field_[3]) {
    msg->AppendVarInt(3, state_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyIpcConnectFtraceEvent::TrustyIpcConnectFtraceEvent() = default;
TrustyIpcConnectFtraceEvent::~TrustyIpcConnectFtraceEvent() = default;
TrustyIpcConnectFtraceEvent::TrustyIpcConnectFtraceEvent(const TrustyIpcConnectFtraceEvent&) = default;
TrustyIpcConnectFtraceEvent& TrustyIpcConnectFtraceEvent::operator=(const TrustyIpcConnectFtraceEvent&) = default;
TrustyIpcConnectFtraceEvent::TrustyIpcConnectFtraceEvent(TrustyIpcConnectFtraceEvent&&) noexcept = default;
TrustyIpcConnectFtraceEvent& TrustyIpcConnectFtraceEvent::operator=(TrustyIpcConnectFtraceEvent&&) = default;

bool TrustyIpcConnectFtraceEvent::operator==(const TrustyIpcConnectFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && chan_ == other.chan_
   && port_ == other.port_
   && state_ == other.state_;
}

bool TrustyIpcConnectFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* chan */:
        field.get(&chan_);
        break;
      case 2 /* port */:
        field.get(&port_);
        break;
      case 3 /* state */:
        field.get(&state_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyIpcConnectFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyIpcConnectFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyIpcConnectFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: chan
  if (_has_field_[1]) {
    msg->AppendVarInt(1, chan_);
  }

  // Field 2: port
  if (_has_field_[2]) {
    msg->AppendString(2, port_);
  }

  // Field 3: state
  if (_has_field_[3]) {
    msg->AppendVarInt(3, state_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyIpcHandleEventFtraceEvent::TrustyIpcHandleEventFtraceEvent() = default;
TrustyIpcHandleEventFtraceEvent::~TrustyIpcHandleEventFtraceEvent() = default;
TrustyIpcHandleEventFtraceEvent::TrustyIpcHandleEventFtraceEvent(const TrustyIpcHandleEventFtraceEvent&) = default;
TrustyIpcHandleEventFtraceEvent& TrustyIpcHandleEventFtraceEvent::operator=(const TrustyIpcHandleEventFtraceEvent&) = default;
TrustyIpcHandleEventFtraceEvent::TrustyIpcHandleEventFtraceEvent(TrustyIpcHandleEventFtraceEvent&&) noexcept = default;
TrustyIpcHandleEventFtraceEvent& TrustyIpcHandleEventFtraceEvent::operator=(TrustyIpcHandleEventFtraceEvent&&) = default;

bool TrustyIpcHandleEventFtraceEvent::operator==(const TrustyIpcHandleEventFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && chan_ == other.chan_
   && event_id_ == other.event_id_
   && srv_name_ == other.srv_name_;
}

bool TrustyIpcHandleEventFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* chan */:
        field.get(&chan_);
        break;
      case 2 /* event_id */:
        field.get(&event_id_);
        break;
      case 3 /* srv_name */:
        field.get(&srv_name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyIpcHandleEventFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyIpcHandleEventFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyIpcHandleEventFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: chan
  if (_has_field_[1]) {
    msg->AppendVarInt(1, chan_);
  }

  // Field 2: event_id
  if (_has_field_[2]) {
    msg->AppendVarInt(2, event_id_);
  }

  // Field 3: srv_name
  if (_has_field_[3]) {
    msg->AppendString(3, srv_name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyIrqFtraceEvent::TrustyIrqFtraceEvent() = default;
TrustyIrqFtraceEvent::~TrustyIrqFtraceEvent() = default;
TrustyIrqFtraceEvent::TrustyIrqFtraceEvent(const TrustyIrqFtraceEvent&) = default;
TrustyIrqFtraceEvent& TrustyIrqFtraceEvent::operator=(const TrustyIrqFtraceEvent&) = default;
TrustyIrqFtraceEvent::TrustyIrqFtraceEvent(TrustyIrqFtraceEvent&&) noexcept = default;
TrustyIrqFtraceEvent& TrustyIrqFtraceEvent::operator=(TrustyIrqFtraceEvent&&) = default;

bool TrustyIrqFtraceEvent::operator==(const TrustyIrqFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && irq_ == other.irq_;
}

bool TrustyIrqFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* irq */:
        field.get(&irq_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyIrqFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyIrqFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyIrqFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: irq
  if (_has_field_[1]) {
    msg->AppendVarInt(1, irq_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyReclaimMemoryDoneFtraceEvent::TrustyReclaimMemoryDoneFtraceEvent() = default;
TrustyReclaimMemoryDoneFtraceEvent::~TrustyReclaimMemoryDoneFtraceEvent() = default;
TrustyReclaimMemoryDoneFtraceEvent::TrustyReclaimMemoryDoneFtraceEvent(const TrustyReclaimMemoryDoneFtraceEvent&) = default;
TrustyReclaimMemoryDoneFtraceEvent& TrustyReclaimMemoryDoneFtraceEvent::operator=(const TrustyReclaimMemoryDoneFtraceEvent&) = default;
TrustyReclaimMemoryDoneFtraceEvent::TrustyReclaimMemoryDoneFtraceEvent(TrustyReclaimMemoryDoneFtraceEvent&&) noexcept = default;
TrustyReclaimMemoryDoneFtraceEvent& TrustyReclaimMemoryDoneFtraceEvent::operator=(TrustyReclaimMemoryDoneFtraceEvent&&) = default;

bool TrustyReclaimMemoryDoneFtraceEvent::operator==(const TrustyReclaimMemoryDoneFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && id_ == other.id_
   && ret_ == other.ret_;
}

bool TrustyReclaimMemoryDoneFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* id */:
        field.get(&id_);
        break;
      case 2 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyReclaimMemoryDoneFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyReclaimMemoryDoneFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyReclaimMemoryDoneFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, id_);
  }

  // Field 2: ret
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyReclaimMemoryFtraceEvent::TrustyReclaimMemoryFtraceEvent() = default;
TrustyReclaimMemoryFtraceEvent::~TrustyReclaimMemoryFtraceEvent() = default;
TrustyReclaimMemoryFtraceEvent::TrustyReclaimMemoryFtraceEvent(const TrustyReclaimMemoryFtraceEvent&) = default;
TrustyReclaimMemoryFtraceEvent& TrustyReclaimMemoryFtraceEvent::operator=(const TrustyReclaimMemoryFtraceEvent&) = default;
TrustyReclaimMemoryFtraceEvent::TrustyReclaimMemoryFtraceEvent(TrustyReclaimMemoryFtraceEvent&&) noexcept = default;
TrustyReclaimMemoryFtraceEvent& TrustyReclaimMemoryFtraceEvent::operator=(TrustyReclaimMemoryFtraceEvent&&) = default;

bool TrustyReclaimMemoryFtraceEvent::operator==(const TrustyReclaimMemoryFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && id_ == other.id_;
}

bool TrustyReclaimMemoryFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* id */:
        field.get(&id_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyReclaimMemoryFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyReclaimMemoryFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyReclaimMemoryFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, id_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyShareMemoryDoneFtraceEvent::TrustyShareMemoryDoneFtraceEvent() = default;
TrustyShareMemoryDoneFtraceEvent::~TrustyShareMemoryDoneFtraceEvent() = default;
TrustyShareMemoryDoneFtraceEvent::TrustyShareMemoryDoneFtraceEvent(const TrustyShareMemoryDoneFtraceEvent&) = default;
TrustyShareMemoryDoneFtraceEvent& TrustyShareMemoryDoneFtraceEvent::operator=(const TrustyShareMemoryDoneFtraceEvent&) = default;
TrustyShareMemoryDoneFtraceEvent::TrustyShareMemoryDoneFtraceEvent(TrustyShareMemoryDoneFtraceEvent&&) noexcept = default;
TrustyShareMemoryDoneFtraceEvent& TrustyShareMemoryDoneFtraceEvent::operator=(TrustyShareMemoryDoneFtraceEvent&&) = default;

bool TrustyShareMemoryDoneFtraceEvent::operator==(const TrustyShareMemoryDoneFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && handle_ == other.handle_
   && len_ == other.len_
   && lend_ == other.lend_
   && nents_ == other.nents_
   && ret_ == other.ret_;
}

bool TrustyShareMemoryDoneFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* handle */:
        field.get(&handle_);
        break;
      case 2 /* len */:
        field.get(&len_);
        break;
      case 3 /* lend */:
        field.get(&lend_);
        break;
      case 4 /* nents */:
        field.get(&nents_);
        break;
      case 5 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyShareMemoryDoneFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyShareMemoryDoneFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyShareMemoryDoneFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: handle
  if (_has_field_[1]) {
    msg->AppendVarInt(1, handle_);
  }

  // Field 2: len
  if (_has_field_[2]) {
    msg->AppendVarInt(2, len_);
  }

  // Field 3: lend
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lend_);
  }

  // Field 4: nents
  if (_has_field_[4]) {
    msg->AppendVarInt(4, nents_);
  }

  // Field 5: ret
  if (_has_field_[5]) {
    msg->AppendVarInt(5, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyShareMemoryFtraceEvent::TrustyShareMemoryFtraceEvent() = default;
TrustyShareMemoryFtraceEvent::~TrustyShareMemoryFtraceEvent() = default;
TrustyShareMemoryFtraceEvent::TrustyShareMemoryFtraceEvent(const TrustyShareMemoryFtraceEvent&) = default;
TrustyShareMemoryFtraceEvent& TrustyShareMemoryFtraceEvent::operator=(const TrustyShareMemoryFtraceEvent&) = default;
TrustyShareMemoryFtraceEvent::TrustyShareMemoryFtraceEvent(TrustyShareMemoryFtraceEvent&&) noexcept = default;
TrustyShareMemoryFtraceEvent& TrustyShareMemoryFtraceEvent::operator=(TrustyShareMemoryFtraceEvent&&) = default;

bool TrustyShareMemoryFtraceEvent::operator==(const TrustyShareMemoryFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && len_ == other.len_
   && lend_ == other.lend_
   && nents_ == other.nents_;
}

bool TrustyShareMemoryFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* len */:
        field.get(&len_);
        break;
      case 2 /* lend */:
        field.get(&lend_);
        break;
      case 3 /* nents */:
        field.get(&nents_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyShareMemoryFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyShareMemoryFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyShareMemoryFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: len
  if (_has_field_[1]) {
    msg->AppendVarInt(1, len_);
  }

  // Field 2: lend
  if (_has_field_[2]) {
    msg->AppendVarInt(2, lend_);
  }

  // Field 3: nents
  if (_has_field_[3]) {
    msg->AppendVarInt(3, nents_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyStdCall32DoneFtraceEvent::TrustyStdCall32DoneFtraceEvent() = default;
TrustyStdCall32DoneFtraceEvent::~TrustyStdCall32DoneFtraceEvent() = default;
TrustyStdCall32DoneFtraceEvent::TrustyStdCall32DoneFtraceEvent(const TrustyStdCall32DoneFtraceEvent&) = default;
TrustyStdCall32DoneFtraceEvent& TrustyStdCall32DoneFtraceEvent::operator=(const TrustyStdCall32DoneFtraceEvent&) = default;
TrustyStdCall32DoneFtraceEvent::TrustyStdCall32DoneFtraceEvent(TrustyStdCall32DoneFtraceEvent&&) noexcept = default;
TrustyStdCall32DoneFtraceEvent& TrustyStdCall32DoneFtraceEvent::operator=(TrustyStdCall32DoneFtraceEvent&&) = default;

bool TrustyStdCall32DoneFtraceEvent::operator==(const TrustyStdCall32DoneFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && ret_ == other.ret_;
}

bool TrustyStdCall32DoneFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyStdCall32DoneFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyStdCall32DoneFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyStdCall32DoneFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ret
  if (_has_field_[1]) {
    msg->AppendVarInt(1, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustyStdCall32FtraceEvent::TrustyStdCall32FtraceEvent() = default;
TrustyStdCall32FtraceEvent::~TrustyStdCall32FtraceEvent() = default;
TrustyStdCall32FtraceEvent::TrustyStdCall32FtraceEvent(const TrustyStdCall32FtraceEvent&) = default;
TrustyStdCall32FtraceEvent& TrustyStdCall32FtraceEvent::operator=(const TrustyStdCall32FtraceEvent&) = default;
TrustyStdCall32FtraceEvent::TrustyStdCall32FtraceEvent(TrustyStdCall32FtraceEvent&&) noexcept = default;
TrustyStdCall32FtraceEvent& TrustyStdCall32FtraceEvent::operator=(TrustyStdCall32FtraceEvent&&) = default;

bool TrustyStdCall32FtraceEvent::operator==(const TrustyStdCall32FtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && r0_ == other.r0_
   && r1_ == other.r1_
   && r2_ == other.r2_
   && r3_ == other.r3_;
}

bool TrustyStdCall32FtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* r0 */:
        field.get(&r0_);
        break;
      case 2 /* r1 */:
        field.get(&r1_);
        break;
      case 3 /* r2 */:
        field.get(&r2_);
        break;
      case 4 /* r3 */:
        field.get(&r3_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustyStdCall32FtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustyStdCall32FtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustyStdCall32FtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: r0
  if (_has_field_[1]) {
    msg->AppendVarInt(1, r0_);
  }

  // Field 2: r1
  if (_has_field_[2]) {
    msg->AppendVarInt(2, r1_);
  }

  // Field 3: r2
  if (_has_field_[3]) {
    msg->AppendVarInt(3, r2_);
  }

  // Field 4: r3
  if (_has_field_[4]) {
    msg->AppendVarInt(4, r3_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustySmcDoneFtraceEvent::TrustySmcDoneFtraceEvent() = default;
TrustySmcDoneFtraceEvent::~TrustySmcDoneFtraceEvent() = default;
TrustySmcDoneFtraceEvent::TrustySmcDoneFtraceEvent(const TrustySmcDoneFtraceEvent&) = default;
TrustySmcDoneFtraceEvent& TrustySmcDoneFtraceEvent::operator=(const TrustySmcDoneFtraceEvent&) = default;
TrustySmcDoneFtraceEvent::TrustySmcDoneFtraceEvent(TrustySmcDoneFtraceEvent&&) noexcept = default;
TrustySmcDoneFtraceEvent& TrustySmcDoneFtraceEvent::operator=(TrustySmcDoneFtraceEvent&&) = default;

bool TrustySmcDoneFtraceEvent::operator==(const TrustySmcDoneFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && ret_ == other.ret_;
}

bool TrustySmcDoneFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustySmcDoneFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustySmcDoneFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustySmcDoneFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ret
  if (_has_field_[1]) {
    msg->AppendVarInt(1, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TrustySmcFtraceEvent::TrustySmcFtraceEvent() = default;
TrustySmcFtraceEvent::~TrustySmcFtraceEvent() = default;
TrustySmcFtraceEvent::TrustySmcFtraceEvent(const TrustySmcFtraceEvent&) = default;
TrustySmcFtraceEvent& TrustySmcFtraceEvent::operator=(const TrustySmcFtraceEvent&) = default;
TrustySmcFtraceEvent::TrustySmcFtraceEvent(TrustySmcFtraceEvent&&) noexcept = default;
TrustySmcFtraceEvent& TrustySmcFtraceEvent::operator=(TrustySmcFtraceEvent&&) = default;

bool TrustySmcFtraceEvent::operator==(const TrustySmcFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && r0_ == other.r0_
   && r1_ == other.r1_
   && r2_ == other.r2_
   && r3_ == other.r3_;
}

bool TrustySmcFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* r0 */:
        field.get(&r0_);
        break;
      case 2 /* r1 */:
        field.get(&r1_);
        break;
      case 3 /* r2 */:
        field.get(&r2_);
        break;
      case 4 /* r3 */:
        field.get(&r3_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrustySmcFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrustySmcFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrustySmcFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: r0
  if (_has_field_[1]) {
    msg->AppendVarInt(1, r0_);
  }

  // Field 2: r1
  if (_has_field_[2]) {
    msg->AppendVarInt(2, r1_);
  }

  // Field 3: r2
  if (_has_field_[3]) {
    msg->AppendVarInt(3, r2_);
  }

  // Field 4: r3
  if (_has_field_[4]) {
    msg->AppendVarInt(4, r3_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
