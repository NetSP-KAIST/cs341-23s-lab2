#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/android/android_game_intervention_list.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

AndroidGameInterventionList::AndroidGameInterventionList() = default;
AndroidGameInterventionList::~AndroidGameInterventionList() = default;
AndroidGameInterventionList::AndroidGameInterventionList(const AndroidGameInterventionList&) = default;
AndroidGameInterventionList& AndroidGameInterventionList::operator=(const AndroidGameInterventionList&) = default;
AndroidGameInterventionList::AndroidGameInterventionList(AndroidGameInterventionList&&) noexcept = default;
AndroidGameInterventionList& AndroidGameInterventionList::operator=(AndroidGameInterventionList&&) = default;

bool AndroidGameInterventionList::operator==(const AndroidGameInterventionList& other) const {
  return unknown_fields_ == other.unknown_fields_
   && game_packages_ == other.game_packages_
   && parse_error_ == other.parse_error_
   && read_error_ == other.read_error_;
}

int AndroidGameInterventionList::game_packages_size() const { return static_cast<int>(game_packages_.size()); }
void AndroidGameInterventionList::clear_game_packages() { game_packages_.clear(); }
AndroidGameInterventionList_GamePackageInfo* AndroidGameInterventionList::add_game_packages() { game_packages_.emplace_back(); return &game_packages_.back(); }
bool AndroidGameInterventionList::ParseFromArray(const void* raw, size_t size) {
  game_packages_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* game_packages */:
        game_packages_.emplace_back();
        game_packages_.back().ParseFromArray(field.data(), field.size());
        break;
      case 2 /* parse_error */:
        field.get(&parse_error_);
        break;
      case 3 /* read_error */:
        field.get(&read_error_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AndroidGameInterventionList::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AndroidGameInterventionList::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AndroidGameInterventionList::Serialize(::protozero::Message* msg) const {
  // Field 1: game_packages
  for (auto& it : game_packages_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(1));
  }

  // Field 2: parse_error
  if (_has_field_[2]) {
    msg->AppendTinyVarInt(2, parse_error_);
  }

  // Field 3: read_error
  if (_has_field_[3]) {
    msg->AppendTinyVarInt(3, read_error_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AndroidGameInterventionList_GamePackageInfo::AndroidGameInterventionList_GamePackageInfo() = default;
AndroidGameInterventionList_GamePackageInfo::~AndroidGameInterventionList_GamePackageInfo() = default;
AndroidGameInterventionList_GamePackageInfo::AndroidGameInterventionList_GamePackageInfo(const AndroidGameInterventionList_GamePackageInfo&) = default;
AndroidGameInterventionList_GamePackageInfo& AndroidGameInterventionList_GamePackageInfo::operator=(const AndroidGameInterventionList_GamePackageInfo&) = default;
AndroidGameInterventionList_GamePackageInfo::AndroidGameInterventionList_GamePackageInfo(AndroidGameInterventionList_GamePackageInfo&&) noexcept = default;
AndroidGameInterventionList_GamePackageInfo& AndroidGameInterventionList_GamePackageInfo::operator=(AndroidGameInterventionList_GamePackageInfo&&) = default;

bool AndroidGameInterventionList_GamePackageInfo::operator==(const AndroidGameInterventionList_GamePackageInfo& other) const {
  return unknown_fields_ == other.unknown_fields_
   && name_ == other.name_
   && uid_ == other.uid_
   && current_mode_ == other.current_mode_
   && game_mode_info_ == other.game_mode_info_;
}

int AndroidGameInterventionList_GamePackageInfo::game_mode_info_size() const { return static_cast<int>(game_mode_info_.size()); }
void AndroidGameInterventionList_GamePackageInfo::clear_game_mode_info() { game_mode_info_.clear(); }
AndroidGameInterventionList_GameModeInfo* AndroidGameInterventionList_GamePackageInfo::add_game_mode_info() { game_mode_info_.emplace_back(); return &game_mode_info_.back(); }
bool AndroidGameInterventionList_GamePackageInfo::ParseFromArray(const void* raw, size_t size) {
  game_mode_info_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* name */:
        field.get(&name_);
        break;
      case 2 /* uid */:
        field.get(&uid_);
        break;
      case 3 /* current_mode */:
        field.get(&current_mode_);
        break;
      case 4 /* game_mode_info */:
        game_mode_info_.emplace_back();
        game_mode_info_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AndroidGameInterventionList_GamePackageInfo::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AndroidGameInterventionList_GamePackageInfo::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AndroidGameInterventionList_GamePackageInfo::Serialize(::protozero::Message* msg) const {
  // Field 1: name
  if (_has_field_[1]) {
    msg->AppendString(1, name_);
  }

  // Field 2: uid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, uid_);
  }

  // Field 3: current_mode
  if (_has_field_[3]) {
    msg->AppendVarInt(3, current_mode_);
  }

  // Field 4: game_mode_info
  for (auto& it : game_mode_info_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(4));
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AndroidGameInterventionList_GameModeInfo::AndroidGameInterventionList_GameModeInfo() = default;
AndroidGameInterventionList_GameModeInfo::~AndroidGameInterventionList_GameModeInfo() = default;
AndroidGameInterventionList_GameModeInfo::AndroidGameInterventionList_GameModeInfo(const AndroidGameInterventionList_GameModeInfo&) = default;
AndroidGameInterventionList_GameModeInfo& AndroidGameInterventionList_GameModeInfo::operator=(const AndroidGameInterventionList_GameModeInfo&) = default;
AndroidGameInterventionList_GameModeInfo::AndroidGameInterventionList_GameModeInfo(AndroidGameInterventionList_GameModeInfo&&) noexcept = default;
AndroidGameInterventionList_GameModeInfo& AndroidGameInterventionList_GameModeInfo::operator=(AndroidGameInterventionList_GameModeInfo&&) = default;

bool AndroidGameInterventionList_GameModeInfo::operator==(const AndroidGameInterventionList_GameModeInfo& other) const {
  return unknown_fields_ == other.unknown_fields_
   && mode_ == other.mode_
   && use_angle_ == other.use_angle_
   && resolution_downscale_ == other.resolution_downscale_
   && fps_ == other.fps_;
}

bool AndroidGameInterventionList_GameModeInfo::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* mode */:
        field.get(&mode_);
        break;
      case 2 /* use_angle */:
        field.get(&use_angle_);
        break;
      case 3 /* resolution_downscale */:
        field.get(&resolution_downscale_);
        break;
      case 4 /* fps */:
        field.get(&fps_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AndroidGameInterventionList_GameModeInfo::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AndroidGameInterventionList_GameModeInfo::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AndroidGameInterventionList_GameModeInfo::Serialize(::protozero::Message* msg) const {
  // Field 1: mode
  if (_has_field_[1]) {
    msg->AppendVarInt(1, mode_);
  }

  // Field 2: use_angle
  if (_has_field_[2]) {
    msg->AppendTinyVarInt(2, use_angle_);
  }

  // Field 3: resolution_downscale
  if (_has_field_[3]) {
    msg->AppendFixed(3, resolution_downscale_);
  }

  // Field 4: fps
  if (_has_field_[4]) {
    msg->AppendFixed(4, fps_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
