// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: quic_trace.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_quic_5ftrace_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_quic_5ftrace_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_quic_5ftrace_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_quic_5ftrace_2eproto {
  static const uint32_t offsets[];
};
namespace quic_trace {
class AckBlock;
struct AckBlockDefaultTypeInternal;
extern AckBlockDefaultTypeInternal _AckBlock_default_instance_;
class AckInfo;
struct AckInfoDefaultTypeInternal;
extern AckInfoDefaultTypeInternal _AckInfo_default_instance_;
class CloseInfo;
struct CloseInfoDefaultTypeInternal;
extern CloseInfoDefaultTypeInternal _CloseInfo_default_instance_;
class CryptoFrameInfo;
struct CryptoFrameInfoDefaultTypeInternal;
extern CryptoFrameInfoDefaultTypeInternal _CryptoFrameInfo_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class ExternalNetworkParameters;
struct ExternalNetworkParametersDefaultTypeInternal;
extern ExternalNetworkParametersDefaultTypeInternal _ExternalNetworkParameters_default_instance_;
class FlowControlInfo;
struct FlowControlInfoDefaultTypeInternal;
extern FlowControlInfoDefaultTypeInternal _FlowControlInfo_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class ResetStreamInfo;
struct ResetStreamInfoDefaultTypeInternal;
extern ResetStreamInfoDefaultTypeInternal _ResetStreamInfo_default_instance_;
class StreamFrameInfo;
struct StreamFrameInfoDefaultTypeInternal;
extern StreamFrameInfoDefaultTypeInternal _StreamFrameInfo_default_instance_;
class Trace;
struct TraceDefaultTypeInternal;
extern TraceDefaultTypeInternal _Trace_default_instance_;
class TransportState;
struct TransportStateDefaultTypeInternal;
extern TransportStateDefaultTypeInternal _TransportState_default_instance_;
}  // namespace quic_trace
PROTOBUF_NAMESPACE_OPEN
template<> ::quic_trace::AckBlock* Arena::CreateMaybeMessage<::quic_trace::AckBlock>(Arena*);
template<> ::quic_trace::AckInfo* Arena::CreateMaybeMessage<::quic_trace::AckInfo>(Arena*);
template<> ::quic_trace::CloseInfo* Arena::CreateMaybeMessage<::quic_trace::CloseInfo>(Arena*);
template<> ::quic_trace::CryptoFrameInfo* Arena::CreateMaybeMessage<::quic_trace::CryptoFrameInfo>(Arena*);
template<> ::quic_trace::Event* Arena::CreateMaybeMessage<::quic_trace::Event>(Arena*);
template<> ::quic_trace::ExternalNetworkParameters* Arena::CreateMaybeMessage<::quic_trace::ExternalNetworkParameters>(Arena*);
template<> ::quic_trace::FlowControlInfo* Arena::CreateMaybeMessage<::quic_trace::FlowControlInfo>(Arena*);
template<> ::quic_trace::Frame* Arena::CreateMaybeMessage<::quic_trace::Frame>(Arena*);
template<> ::quic_trace::ResetStreamInfo* Arena::CreateMaybeMessage<::quic_trace::ResetStreamInfo>(Arena*);
template<> ::quic_trace::StreamFrameInfo* Arena::CreateMaybeMessage<::quic_trace::StreamFrameInfo>(Arena*);
template<> ::quic_trace::Trace* Arena::CreateMaybeMessage<::quic_trace::Trace>(Arena*);
template<> ::quic_trace::TransportState* Arena::CreateMaybeMessage<::quic_trace::TransportState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace quic_trace {

enum FrameType : int {
  UNKNOWN_FRAME = 0,
  STREAM = 1,
  ACK = 2,
  RESET_STREAM = 3,
  CONNECTION_CLOSE = 4,
  MAX_DATA = 5,
  MAX_STREAM_DATA = 6,
  PING = 7,
  BLOCKED = 8,
  STREAM_BLOCKED = 9,
  PADDING = 10,
  CRYPTO = 11
};
bool FrameType_IsValid(int value);
constexpr FrameType FrameType_MIN = UNKNOWN_FRAME;
constexpr FrameType FrameType_MAX = CRYPTO;
constexpr int FrameType_ARRAYSIZE = FrameType_MAX + 1;

const std::string& FrameType_Name(FrameType value);
template<typename T>
inline const std::string& FrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FrameType_Name.");
  return FrameType_Name(static_cast<FrameType>(enum_t_value));
}
bool FrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FrameType* value);
enum CloseType : int {
  GOOGLE_QUIC_CONNECTION_CLOSE = 0,
  IETF_QUIC_TRANSPORT_CONNECTION_CLOSE = 1,
  IETF_QUIC_APPLICATION_CONNECTION_CLOSE = 2
};
bool CloseType_IsValid(int value);
constexpr CloseType CloseType_MIN = GOOGLE_QUIC_CONNECTION_CLOSE;
constexpr CloseType CloseType_MAX = IETF_QUIC_APPLICATION_CONNECTION_CLOSE;
constexpr int CloseType_ARRAYSIZE = CloseType_MAX + 1;

const std::string& CloseType_Name(CloseType value);
template<typename T>
inline const std::string& CloseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CloseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CloseType_Name.");
  return CloseType_Name(static_cast<CloseType>(enum_t_value));
}
bool CloseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CloseType* value);
enum EncryptionLevel : int {
  ENCRYPTION_UNKNOWN = 0,
  ENCRYPTION_INITIAL = 1,
  ENCRYPTION_0RTT = 2,
  ENCRYPTION_1RTT = 3,
  ENCRYPTION_HANDSHAKE = 4
};
bool EncryptionLevel_IsValid(int value);
constexpr EncryptionLevel EncryptionLevel_MIN = ENCRYPTION_UNKNOWN;
constexpr EncryptionLevel EncryptionLevel_MAX = ENCRYPTION_HANDSHAKE;
constexpr int EncryptionLevel_ARRAYSIZE = EncryptionLevel_MAX + 1;

const std::string& EncryptionLevel_Name(EncryptionLevel value);
template<typename T>
inline const std::string& EncryptionLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncryptionLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncryptionLevel_Name.");
  return EncryptionLevel_Name(static_cast<EncryptionLevel>(enum_t_value));
}
bool EncryptionLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncryptionLevel* value);
enum EventType : int {
  UNKNOWN_EVENT = 0,
  PACKET_SENT = 1,
  PACKET_RECEIVED = 2,
  PACKET_LOST = 3,
  APPLICATION_LIMITED = 4,
  EXTERNAL_PARAMETERS = 5
};
bool EventType_IsValid(int value);
constexpr EventType EventType_MIN = UNKNOWN_EVENT;
constexpr EventType EventType_MAX = EXTERNAL_PARAMETERS;
constexpr int EventType_ARRAYSIZE = EventType_MAX + 1;

const std::string& EventType_Name(EventType value);
template<typename T>
inline const std::string& EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventType_Name.");
  return EventType_Name(static_cast<EventType>(enum_t_value));
}
bool EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventType* value);
enum TransmissionReason : int {
  NORMAL_TRANSMISSION = 0,
  TAIL_LOSS_PROBE = 1,
  RTO_TRANSMISSION = 2,
  PROBING_TRANSMISSION = 3
};
bool TransmissionReason_IsValid(int value);
constexpr TransmissionReason TransmissionReason_MIN = NORMAL_TRANSMISSION;
constexpr TransmissionReason TransmissionReason_MAX = PROBING_TRANSMISSION;
constexpr int TransmissionReason_ARRAYSIZE = TransmissionReason_MAX + 1;

const std::string& TransmissionReason_Name(TransmissionReason value);
template<typename T>
inline const std::string& TransmissionReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransmissionReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransmissionReason_Name.");
  return TransmissionReason_Name(static_cast<TransmissionReason>(enum_t_value));
}
bool TransmissionReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransmissionReason* value);
// ===================================================================

class StreamFrameInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.StreamFrameInfo) */ {
 public:
  inline StreamFrameInfo() : StreamFrameInfo(nullptr) {}
  ~StreamFrameInfo() override;
  explicit PROTOBUF_CONSTEXPR StreamFrameInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamFrameInfo(const StreamFrameInfo& from);
  StreamFrameInfo(StreamFrameInfo&& from) noexcept
    : StreamFrameInfo() {
    *this = ::std::move(from);
  }

  inline StreamFrameInfo& operator=(const StreamFrameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamFrameInfo& operator=(StreamFrameInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StreamFrameInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamFrameInfo* internal_default_instance() {
    return reinterpret_cast<const StreamFrameInfo*>(
               &_StreamFrameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StreamFrameInfo& a, StreamFrameInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StreamFrameInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamFrameInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamFrameInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamFrameInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StreamFrameInfo& from);
  void MergeFrom(const StreamFrameInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamFrameInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.StreamFrameInfo";
  }
  protected:
  explicit StreamFrameInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
    kLengthFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kFinFieldNumber = 2,
  };
  // optional uint64 stream_id = 1;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  uint64_t stream_id() const;
  void set_stream_id(uint64_t value);
  private:
  uint64_t _internal_stream_id() const;
  void _internal_set_stream_id(uint64_t value);
  public:

  // optional uint64 length = 3;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  uint64_t length() const;
  void set_length(uint64_t value);
  private:
  uint64_t _internal_length() const;
  void _internal_set_length(uint64_t value);
  public:

  // optional uint64 offset = 4;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // optional bool fin = 2;
  bool has_fin() const;
  private:
  bool _internal_has_fin() const;
  public:
  void clear_fin();
  bool fin() const;
  void set_fin(bool value);
  private:
  bool _internal_fin() const;
  void _internal_set_fin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.StreamFrameInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t stream_id_;
  uint64_t length_;
  uint64_t offset_;
  bool fin_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// -------------------------------------------------------------------

class CryptoFrameInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.CryptoFrameInfo) */ {
 public:
  inline CryptoFrameInfo() : CryptoFrameInfo(nullptr) {}
  ~CryptoFrameInfo() override;
  explicit PROTOBUF_CONSTEXPR CryptoFrameInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CryptoFrameInfo(const CryptoFrameInfo& from);
  CryptoFrameInfo(CryptoFrameInfo&& from) noexcept
    : CryptoFrameInfo() {
    *this = ::std::move(from);
  }

  inline CryptoFrameInfo& operator=(const CryptoFrameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CryptoFrameInfo& operator=(CryptoFrameInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CryptoFrameInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CryptoFrameInfo* internal_default_instance() {
    return reinterpret_cast<const CryptoFrameInfo*>(
               &_CryptoFrameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CryptoFrameInfo& a, CryptoFrameInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CryptoFrameInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CryptoFrameInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CryptoFrameInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CryptoFrameInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CryptoFrameInfo& from);
  void MergeFrom(const CryptoFrameInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CryptoFrameInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.CryptoFrameInfo";
  }
  protected:
  explicit CryptoFrameInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // optional uint64 length = 1;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  uint64_t length() const;
  void set_length(uint64_t value);
  private:
  uint64_t _internal_length() const;
  void _internal_set_length(uint64_t value);
  public:

  // optional uint64 offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.CryptoFrameInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t length_;
  uint64_t offset_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// -------------------------------------------------------------------

class AckBlock final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.AckBlock) */ {
 public:
  inline AckBlock() : AckBlock(nullptr) {}
  ~AckBlock() override;
  explicit PROTOBUF_CONSTEXPR AckBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckBlock(const AckBlock& from);
  AckBlock(AckBlock&& from) noexcept
    : AckBlock() {
    *this = ::std::move(from);
  }

  inline AckBlock& operator=(const AckBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckBlock& operator=(AckBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AckBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckBlock* internal_default_instance() {
    return reinterpret_cast<const AckBlock*>(
               &_AckBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AckBlock& a, AckBlock& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AckBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckBlock>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AckBlock& from);
  void MergeFrom(const AckBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AckBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.AckBlock";
  }
  protected:
  explicit AckBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstPacketFieldNumber = 1,
    kLastPacketFieldNumber = 2,
  };
  // optional uint64 first_packet = 1;
  bool has_first_packet() const;
  private:
  bool _internal_has_first_packet() const;
  public:
  void clear_first_packet();
  uint64_t first_packet() const;
  void set_first_packet(uint64_t value);
  private:
  uint64_t _internal_first_packet() const;
  void _internal_set_first_packet(uint64_t value);
  public:

  // optional uint64 last_packet = 2;
  bool has_last_packet() const;
  private:
  bool _internal_has_last_packet() const;
  public:
  void clear_last_packet();
  uint64_t last_packet() const;
  void set_last_packet(uint64_t value);
  private:
  uint64_t _internal_last_packet() const;
  void _internal_set_last_packet(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.AckBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t first_packet_;
  uint64_t last_packet_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// -------------------------------------------------------------------

class AckInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.AckInfo) */ {
 public:
  inline AckInfo() : AckInfo(nullptr) {}
  ~AckInfo() override;
  explicit PROTOBUF_CONSTEXPR AckInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckInfo(const AckInfo& from);
  AckInfo(AckInfo&& from) noexcept
    : AckInfo() {
    *this = ::std::move(from);
  }

  inline AckInfo& operator=(const AckInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckInfo& operator=(AckInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AckInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckInfo* internal_default_instance() {
    return reinterpret_cast<const AckInfo*>(
               &_AckInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AckInfo& a, AckInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AckInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AckInfo& from);
  void MergeFrom(const AckInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AckInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.AckInfo";
  }
  protected:
  explicit AckInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckedPacketsFieldNumber = 1,
    kAckDelayUsFieldNumber = 2,
  };
  // repeated .quic_trace.AckBlock acked_packets = 1;
  int acked_packets_size() const;
  private:
  int _internal_acked_packets_size() const;
  public:
  void clear_acked_packets();
  ::quic_trace::AckBlock* mutable_acked_packets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::AckBlock >*
      mutable_acked_packets();
  private:
  const ::quic_trace::AckBlock& _internal_acked_packets(int index) const;
  ::quic_trace::AckBlock* _internal_add_acked_packets();
  public:
  const ::quic_trace::AckBlock& acked_packets(int index) const;
  ::quic_trace::AckBlock* add_acked_packets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::AckBlock >&
      acked_packets() const;

  // optional uint64 ack_delay_us = 2;
  bool has_ack_delay_us() const;
  private:
  bool _internal_has_ack_delay_us() const;
  public:
  void clear_ack_delay_us();
  uint64_t ack_delay_us() const;
  void set_ack_delay_us(uint64_t value);
  private:
  uint64_t _internal_ack_delay_us() const;
  void _internal_set_ack_delay_us(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.AckInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::AckBlock > acked_packets_;
  uint64_t ack_delay_us_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// -------------------------------------------------------------------

class ResetStreamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.ResetStreamInfo) */ {
 public:
  inline ResetStreamInfo() : ResetStreamInfo(nullptr) {}
  ~ResetStreamInfo() override;
  explicit PROTOBUF_CONSTEXPR ResetStreamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetStreamInfo(const ResetStreamInfo& from);
  ResetStreamInfo(ResetStreamInfo&& from) noexcept
    : ResetStreamInfo() {
    *this = ::std::move(from);
  }

  inline ResetStreamInfo& operator=(const ResetStreamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetStreamInfo& operator=(ResetStreamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ResetStreamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetStreamInfo* internal_default_instance() {
    return reinterpret_cast<const ResetStreamInfo*>(
               &_ResetStreamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ResetStreamInfo& a, ResetStreamInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ResetStreamInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetStreamInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetStreamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetStreamInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ResetStreamInfo& from);
  void MergeFrom(const ResetStreamInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResetStreamInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.ResetStreamInfo";
  }
  protected:
  explicit ResetStreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
    kFinalOffsetFieldNumber = 3,
    kApplicationErrorCodeFieldNumber = 2,
  };
  // optional uint64 stream_id = 1;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  uint64_t stream_id() const;
  void set_stream_id(uint64_t value);
  private:
  uint64_t _internal_stream_id() const;
  void _internal_set_stream_id(uint64_t value);
  public:

  // optional uint64 final_offset = 3;
  bool has_final_offset() const;
  private:
  bool _internal_has_final_offset() const;
  public:
  void clear_final_offset();
  uint64_t final_offset() const;
  void set_final_offset(uint64_t value);
  private:
  uint64_t _internal_final_offset() const;
  void _internal_set_final_offset(uint64_t value);
  public:

  // optional uint32 application_error_code = 2;
  bool has_application_error_code() const;
  private:
  bool _internal_has_application_error_code() const;
  public:
  void clear_application_error_code();
  uint32_t application_error_code() const;
  void set_application_error_code(uint32_t value);
  private:
  uint32_t _internal_application_error_code() const;
  void _internal_set_application_error_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.ResetStreamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t stream_id_;
  uint64_t final_offset_;
  uint32_t application_error_code_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// -------------------------------------------------------------------

class CloseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.CloseInfo) */ {
 public:
  inline CloseInfo() : CloseInfo(nullptr) {}
  ~CloseInfo() override;
  explicit PROTOBUF_CONSTEXPR CloseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseInfo(const CloseInfo& from);
  CloseInfo(CloseInfo&& from) noexcept
    : CloseInfo() {
    *this = ::std::move(from);
  }

  inline CloseInfo& operator=(const CloseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseInfo& operator=(CloseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CloseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseInfo* internal_default_instance() {
    return reinterpret_cast<const CloseInfo*>(
               &_CloseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CloseInfo& a, CloseInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CloseInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CloseInfo& from);
  void MergeFrom(const CloseInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CloseInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.CloseInfo";
  }
  protected:
  explicit CloseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonPhraseFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
    kCloseTypeFieldNumber = 3,
    kTransportCloseFrameTypeFieldNumber = 4,
  };
  // optional string reason_phrase = 2;
  bool has_reason_phrase() const;
  private:
  bool _internal_has_reason_phrase() const;
  public:
  void clear_reason_phrase();
  const std::string& reason_phrase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason_phrase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason_phrase();
  PROTOBUF_NODISCARD std::string* release_reason_phrase();
  void set_allocated_reason_phrase(std::string* reason_phrase);
  private:
  const std::string& _internal_reason_phrase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason_phrase(const std::string& value);
  std::string* _internal_mutable_reason_phrase();
  public:

  // optional uint32 error_code = 1;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // optional .quic_trace.CloseType close_type = 3;
  bool has_close_type() const;
  private:
  bool _internal_has_close_type() const;
  public:
  void clear_close_type();
  ::quic_trace::CloseType close_type() const;
  void set_close_type(::quic_trace::CloseType value);
  private:
  ::quic_trace::CloseType _internal_close_type() const;
  void _internal_set_close_type(::quic_trace::CloseType value);
  public:

  // optional uint64 transport_close_frame_type = 4;
  bool has_transport_close_frame_type() const;
  private:
  bool _internal_has_transport_close_frame_type() const;
  public:
  void clear_transport_close_frame_type();
  uint64_t transport_close_frame_type() const;
  void set_transport_close_frame_type(uint64_t value);
  private:
  uint64_t _internal_transport_close_frame_type() const;
  void _internal_set_transport_close_frame_type(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.CloseInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_phrase_;
  uint32_t error_code_;
  int close_type_;
  uint64_t transport_close_frame_type_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// -------------------------------------------------------------------

class FlowControlInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.FlowControlInfo) */ {
 public:
  inline FlowControlInfo() : FlowControlInfo(nullptr) {}
  ~FlowControlInfo() override;
  explicit PROTOBUF_CONSTEXPR FlowControlInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowControlInfo(const FlowControlInfo& from);
  FlowControlInfo(FlowControlInfo&& from) noexcept
    : FlowControlInfo() {
    *this = ::std::move(from);
  }

  inline FlowControlInfo& operator=(const FlowControlInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowControlInfo& operator=(FlowControlInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FlowControlInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowControlInfo* internal_default_instance() {
    return reinterpret_cast<const FlowControlInfo*>(
               &_FlowControlInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FlowControlInfo& a, FlowControlInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FlowControlInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowControlInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowControlInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowControlInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FlowControlInfo& from);
  void MergeFrom(const FlowControlInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlowControlInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.FlowControlInfo";
  }
  protected:
  explicit FlowControlInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxDataFieldNumber = 1,
    kStreamIdFieldNumber = 2,
  };
  // optional uint64 max_data = 1;
  bool has_max_data() const;
  private:
  bool _internal_has_max_data() const;
  public:
  void clear_max_data();
  uint64_t max_data() const;
  void set_max_data(uint64_t value);
  private:
  uint64_t _internal_max_data() const;
  void _internal_set_max_data(uint64_t value);
  public:

  // optional uint64 stream_id = 2;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  uint64_t stream_id() const;
  void set_stream_id(uint64_t value);
  private:
  uint64_t _internal_stream_id() const;
  void _internal_set_stream_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.FlowControlInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t max_data_;
  uint64_t stream_id_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// -------------------------------------------------------------------

class Frame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() override;
  explicit PROTOBUF_CONSTEXPR Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.Frame";
  }
  protected:
  explicit Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFrameInfoFieldNumber = 2,
    kAckInfoFieldNumber = 3,
    kResetStreamInfoFieldNumber = 4,
    kCloseInfoFieldNumber = 5,
    kFlowControlInfoFieldNumber = 6,
    kCryptoFrameInfoFieldNumber = 7,
    kFrameTypeFieldNumber = 1,
  };
  // optional .quic_trace.StreamFrameInfo stream_frame_info = 2;
  bool has_stream_frame_info() const;
  private:
  bool _internal_has_stream_frame_info() const;
  public:
  void clear_stream_frame_info();
  const ::quic_trace::StreamFrameInfo& stream_frame_info() const;
  PROTOBUF_NODISCARD ::quic_trace::StreamFrameInfo* release_stream_frame_info();
  ::quic_trace::StreamFrameInfo* mutable_stream_frame_info();
  void set_allocated_stream_frame_info(::quic_trace::StreamFrameInfo* stream_frame_info);
  private:
  const ::quic_trace::StreamFrameInfo& _internal_stream_frame_info() const;
  ::quic_trace::StreamFrameInfo* _internal_mutable_stream_frame_info();
  public:
  void unsafe_arena_set_allocated_stream_frame_info(
      ::quic_trace::StreamFrameInfo* stream_frame_info);
  ::quic_trace::StreamFrameInfo* unsafe_arena_release_stream_frame_info();

  // optional .quic_trace.AckInfo ack_info = 3;
  bool has_ack_info() const;
  private:
  bool _internal_has_ack_info() const;
  public:
  void clear_ack_info();
  const ::quic_trace::AckInfo& ack_info() const;
  PROTOBUF_NODISCARD ::quic_trace::AckInfo* release_ack_info();
  ::quic_trace::AckInfo* mutable_ack_info();
  void set_allocated_ack_info(::quic_trace::AckInfo* ack_info);
  private:
  const ::quic_trace::AckInfo& _internal_ack_info() const;
  ::quic_trace::AckInfo* _internal_mutable_ack_info();
  public:
  void unsafe_arena_set_allocated_ack_info(
      ::quic_trace::AckInfo* ack_info);
  ::quic_trace::AckInfo* unsafe_arena_release_ack_info();

  // optional .quic_trace.ResetStreamInfo reset_stream_info = 4;
  bool has_reset_stream_info() const;
  private:
  bool _internal_has_reset_stream_info() const;
  public:
  void clear_reset_stream_info();
  const ::quic_trace::ResetStreamInfo& reset_stream_info() const;
  PROTOBUF_NODISCARD ::quic_trace::ResetStreamInfo* release_reset_stream_info();
  ::quic_trace::ResetStreamInfo* mutable_reset_stream_info();
  void set_allocated_reset_stream_info(::quic_trace::ResetStreamInfo* reset_stream_info);
  private:
  const ::quic_trace::ResetStreamInfo& _internal_reset_stream_info() const;
  ::quic_trace::ResetStreamInfo* _internal_mutable_reset_stream_info();
  public:
  void unsafe_arena_set_allocated_reset_stream_info(
      ::quic_trace::ResetStreamInfo* reset_stream_info);
  ::quic_trace::ResetStreamInfo* unsafe_arena_release_reset_stream_info();

  // optional .quic_trace.CloseInfo close_info = 5;
  bool has_close_info() const;
  private:
  bool _internal_has_close_info() const;
  public:
  void clear_close_info();
  const ::quic_trace::CloseInfo& close_info() const;
  PROTOBUF_NODISCARD ::quic_trace::CloseInfo* release_close_info();
  ::quic_trace::CloseInfo* mutable_close_info();
  void set_allocated_close_info(::quic_trace::CloseInfo* close_info);
  private:
  const ::quic_trace::CloseInfo& _internal_close_info() const;
  ::quic_trace::CloseInfo* _internal_mutable_close_info();
  public:
  void unsafe_arena_set_allocated_close_info(
      ::quic_trace::CloseInfo* close_info);
  ::quic_trace::CloseInfo* unsafe_arena_release_close_info();

  // optional .quic_trace.FlowControlInfo flow_control_info = 6;
  bool has_flow_control_info() const;
  private:
  bool _internal_has_flow_control_info() const;
  public:
  void clear_flow_control_info();
  const ::quic_trace::FlowControlInfo& flow_control_info() const;
  PROTOBUF_NODISCARD ::quic_trace::FlowControlInfo* release_flow_control_info();
  ::quic_trace::FlowControlInfo* mutable_flow_control_info();
  void set_allocated_flow_control_info(::quic_trace::FlowControlInfo* flow_control_info);
  private:
  const ::quic_trace::FlowControlInfo& _internal_flow_control_info() const;
  ::quic_trace::FlowControlInfo* _internal_mutable_flow_control_info();
  public:
  void unsafe_arena_set_allocated_flow_control_info(
      ::quic_trace::FlowControlInfo* flow_control_info);
  ::quic_trace::FlowControlInfo* unsafe_arena_release_flow_control_info();

  // optional .quic_trace.CryptoFrameInfo crypto_frame_info = 7;
  bool has_crypto_frame_info() const;
  private:
  bool _internal_has_crypto_frame_info() const;
  public:
  void clear_crypto_frame_info();
  const ::quic_trace::CryptoFrameInfo& crypto_frame_info() const;
  PROTOBUF_NODISCARD ::quic_trace::CryptoFrameInfo* release_crypto_frame_info();
  ::quic_trace::CryptoFrameInfo* mutable_crypto_frame_info();
  void set_allocated_crypto_frame_info(::quic_trace::CryptoFrameInfo* crypto_frame_info);
  private:
  const ::quic_trace::CryptoFrameInfo& _internal_crypto_frame_info() const;
  ::quic_trace::CryptoFrameInfo* _internal_mutable_crypto_frame_info();
  public:
  void unsafe_arena_set_allocated_crypto_frame_info(
      ::quic_trace::CryptoFrameInfo* crypto_frame_info);
  ::quic_trace::CryptoFrameInfo* unsafe_arena_release_crypto_frame_info();

  // optional .quic_trace.FrameType frame_type = 1;
  bool has_frame_type() const;
  private:
  bool _internal_has_frame_type() const;
  public:
  void clear_frame_type();
  ::quic_trace::FrameType frame_type() const;
  void set_frame_type(::quic_trace::FrameType value);
  private:
  ::quic_trace::FrameType _internal_frame_type() const;
  void _internal_set_frame_type(::quic_trace::FrameType value);
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::quic_trace::StreamFrameInfo* stream_frame_info_;
  ::quic_trace::AckInfo* ack_info_;
  ::quic_trace::ResetStreamInfo* reset_stream_info_;
  ::quic_trace::CloseInfo* close_info_;
  ::quic_trace::FlowControlInfo* flow_control_info_;
  ::quic_trace::CryptoFrameInfo* crypto_frame_info_;
  int frame_type_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// -------------------------------------------------------------------

class TransportState final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.TransportState) */ {
 public:
  inline TransportState() : TransportState(nullptr) {}
  ~TransportState() override;
  explicit PROTOBUF_CONSTEXPR TransportState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransportState(const TransportState& from);
  TransportState(TransportState&& from) noexcept
    : TransportState() {
    *this = ::std::move(from);
  }

  inline TransportState& operator=(const TransportState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransportState& operator=(TransportState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TransportState& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransportState* internal_default_instance() {
    return reinterpret_cast<const TransportState*>(
               &_TransportState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TransportState& a, TransportState& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TransportState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransportState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransportState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransportState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TransportState& from);
  void MergeFrom(const TransportState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransportState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.TransportState";
  }
  protected:
  explicit TransportState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCongestionControlStateFieldNumber = 7,
    kMinRttUsFieldNumber = 1,
    kSmoothedRttUsFieldNumber = 2,
    kLastRttUsFieldNumber = 3,
    kInFlightBytesFieldNumber = 4,
    kCwndBytesFieldNumber = 5,
    kPacingRateBpsFieldNumber = 6,
  };
  // optional string congestion_control_state = 7;
  bool has_congestion_control_state() const;
  private:
  bool _internal_has_congestion_control_state() const;
  public:
  void clear_congestion_control_state();
  const std::string& congestion_control_state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_congestion_control_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_congestion_control_state();
  PROTOBUF_NODISCARD std::string* release_congestion_control_state();
  void set_allocated_congestion_control_state(std::string* congestion_control_state);
  private:
  const std::string& _internal_congestion_control_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_congestion_control_state(const std::string& value);
  std::string* _internal_mutable_congestion_control_state();
  public:

  // optional uint64 min_rtt_us = 1;
  bool has_min_rtt_us() const;
  private:
  bool _internal_has_min_rtt_us() const;
  public:
  void clear_min_rtt_us();
  uint64_t min_rtt_us() const;
  void set_min_rtt_us(uint64_t value);
  private:
  uint64_t _internal_min_rtt_us() const;
  void _internal_set_min_rtt_us(uint64_t value);
  public:

  // optional uint64 smoothed_rtt_us = 2;
  bool has_smoothed_rtt_us() const;
  private:
  bool _internal_has_smoothed_rtt_us() const;
  public:
  void clear_smoothed_rtt_us();
  uint64_t smoothed_rtt_us() const;
  void set_smoothed_rtt_us(uint64_t value);
  private:
  uint64_t _internal_smoothed_rtt_us() const;
  void _internal_set_smoothed_rtt_us(uint64_t value);
  public:

  // optional uint64 last_rtt_us = 3;
  bool has_last_rtt_us() const;
  private:
  bool _internal_has_last_rtt_us() const;
  public:
  void clear_last_rtt_us();
  uint64_t last_rtt_us() const;
  void set_last_rtt_us(uint64_t value);
  private:
  uint64_t _internal_last_rtt_us() const;
  void _internal_set_last_rtt_us(uint64_t value);
  public:

  // optional uint64 in_flight_bytes = 4;
  bool has_in_flight_bytes() const;
  private:
  bool _internal_has_in_flight_bytes() const;
  public:
  void clear_in_flight_bytes();
  uint64_t in_flight_bytes() const;
  void set_in_flight_bytes(uint64_t value);
  private:
  uint64_t _internal_in_flight_bytes() const;
  void _internal_set_in_flight_bytes(uint64_t value);
  public:

  // optional uint64 cwnd_bytes = 5;
  bool has_cwnd_bytes() const;
  private:
  bool _internal_has_cwnd_bytes() const;
  public:
  void clear_cwnd_bytes();
  uint64_t cwnd_bytes() const;
  void set_cwnd_bytes(uint64_t value);
  private:
  uint64_t _internal_cwnd_bytes() const;
  void _internal_set_cwnd_bytes(uint64_t value);
  public:

  // optional uint64 pacing_rate_bps = 6;
  bool has_pacing_rate_bps() const;
  private:
  bool _internal_has_pacing_rate_bps() const;
  public:
  void clear_pacing_rate_bps();
  uint64_t pacing_rate_bps() const;
  void set_pacing_rate_bps(uint64_t value);
  private:
  uint64_t _internal_pacing_rate_bps() const;
  void _internal_set_pacing_rate_bps(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.TransportState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr congestion_control_state_;
  uint64_t min_rtt_us_;
  uint64_t smoothed_rtt_us_;
  uint64_t last_rtt_us_;
  uint64_t in_flight_bytes_;
  uint64_t cwnd_bytes_;
  uint64_t pacing_rate_bps_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// -------------------------------------------------------------------

class ExternalNetworkParameters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.ExternalNetworkParameters) */ {
 public:
  inline ExternalNetworkParameters() : ExternalNetworkParameters(nullptr) {}
  ~ExternalNetworkParameters() override;
  explicit PROTOBUF_CONSTEXPR ExternalNetworkParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExternalNetworkParameters(const ExternalNetworkParameters& from);
  ExternalNetworkParameters(ExternalNetworkParameters&& from) noexcept
    : ExternalNetworkParameters() {
    *this = ::std::move(from);
  }

  inline ExternalNetworkParameters& operator=(const ExternalNetworkParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalNetworkParameters& operator=(ExternalNetworkParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExternalNetworkParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalNetworkParameters* internal_default_instance() {
    return reinterpret_cast<const ExternalNetworkParameters*>(
               &_ExternalNetworkParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ExternalNetworkParameters& a, ExternalNetworkParameters& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ExternalNetworkParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalNetworkParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalNetworkParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalNetworkParameters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExternalNetworkParameters& from);
  void MergeFrom(const ExternalNetworkParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExternalNetworkParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.ExternalNetworkParameters";
  }
  protected:
  explicit ExternalNetworkParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBandwidthBpsFieldNumber = 1,
    kRttUsFieldNumber = 2,
    kCwndBytesFieldNumber = 3,
  };
  // optional uint64 bandwidth_bps = 1;
  bool has_bandwidth_bps() const;
  private:
  bool _internal_has_bandwidth_bps() const;
  public:
  void clear_bandwidth_bps();
  uint64_t bandwidth_bps() const;
  void set_bandwidth_bps(uint64_t value);
  private:
  uint64_t _internal_bandwidth_bps() const;
  void _internal_set_bandwidth_bps(uint64_t value);
  public:

  // optional uint64 rtt_us = 2;
  bool has_rtt_us() const;
  private:
  bool _internal_has_rtt_us() const;
  public:
  void clear_rtt_us();
  uint64_t rtt_us() const;
  void set_rtt_us(uint64_t value);
  private:
  uint64_t _internal_rtt_us() const;
  void _internal_set_rtt_us(uint64_t value);
  public:

  // optional uint64 cwnd_bytes = 3;
  bool has_cwnd_bytes() const;
  private:
  bool _internal_has_cwnd_bytes() const;
  public:
  void clear_cwnd_bytes();
  uint64_t cwnd_bytes() const;
  void set_cwnd_bytes(uint64_t value);
  private:
  uint64_t _internal_cwnd_bytes() const;
  void _internal_set_cwnd_bytes(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.ExternalNetworkParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t bandwidth_bps_;
  uint64_t rtt_us_;
  uint64_t cwnd_bytes_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit PROTOBUF_CONSTEXPR Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFramesFieldNumber = 4,
    kTransportStateFieldNumber = 7,
    kExternalNetworkParametersFieldNumber = 8,
    kTimeUsFieldNumber = 1,
    kPacketNumberFieldNumber = 3,
    kEventTypeFieldNumber = 2,
    kEncryptionLevelFieldNumber = 6,
    kPacketSizeFieldNumber = 5,
    kTransmissionReasonFieldNumber = 9,
  };
  // repeated .quic_trace.Frame frames = 4;
  int frames_size() const;
  private:
  int _internal_frames_size() const;
  public:
  void clear_frames();
  ::quic_trace::Frame* mutable_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::Frame >*
      mutable_frames();
  private:
  const ::quic_trace::Frame& _internal_frames(int index) const;
  ::quic_trace::Frame* _internal_add_frames();
  public:
  const ::quic_trace::Frame& frames(int index) const;
  ::quic_trace::Frame* add_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::Frame >&
      frames() const;

  // optional .quic_trace.TransportState transport_state = 7;
  bool has_transport_state() const;
  private:
  bool _internal_has_transport_state() const;
  public:
  void clear_transport_state();
  const ::quic_trace::TransportState& transport_state() const;
  PROTOBUF_NODISCARD ::quic_trace::TransportState* release_transport_state();
  ::quic_trace::TransportState* mutable_transport_state();
  void set_allocated_transport_state(::quic_trace::TransportState* transport_state);
  private:
  const ::quic_trace::TransportState& _internal_transport_state() const;
  ::quic_trace::TransportState* _internal_mutable_transport_state();
  public:
  void unsafe_arena_set_allocated_transport_state(
      ::quic_trace::TransportState* transport_state);
  ::quic_trace::TransportState* unsafe_arena_release_transport_state();

  // optional .quic_trace.ExternalNetworkParameters external_network_parameters = 8;
  bool has_external_network_parameters() const;
  private:
  bool _internal_has_external_network_parameters() const;
  public:
  void clear_external_network_parameters();
  const ::quic_trace::ExternalNetworkParameters& external_network_parameters() const;
  PROTOBUF_NODISCARD ::quic_trace::ExternalNetworkParameters* release_external_network_parameters();
  ::quic_trace::ExternalNetworkParameters* mutable_external_network_parameters();
  void set_allocated_external_network_parameters(::quic_trace::ExternalNetworkParameters* external_network_parameters);
  private:
  const ::quic_trace::ExternalNetworkParameters& _internal_external_network_parameters() const;
  ::quic_trace::ExternalNetworkParameters* _internal_mutable_external_network_parameters();
  public:
  void unsafe_arena_set_allocated_external_network_parameters(
      ::quic_trace::ExternalNetworkParameters* external_network_parameters);
  ::quic_trace::ExternalNetworkParameters* unsafe_arena_release_external_network_parameters();

  // optional uint64 time_us = 1;
  bool has_time_us() const;
  private:
  bool _internal_has_time_us() const;
  public:
  void clear_time_us();
  uint64_t time_us() const;
  void set_time_us(uint64_t value);
  private:
  uint64_t _internal_time_us() const;
  void _internal_set_time_us(uint64_t value);
  public:

  // optional uint64 packet_number = 3;
  bool has_packet_number() const;
  private:
  bool _internal_has_packet_number() const;
  public:
  void clear_packet_number();
  uint64_t packet_number() const;
  void set_packet_number(uint64_t value);
  private:
  uint64_t _internal_packet_number() const;
  void _internal_set_packet_number(uint64_t value);
  public:

  // optional .quic_trace.EventType event_type = 2;
  bool has_event_type() const;
  private:
  bool _internal_has_event_type() const;
  public:
  void clear_event_type();
  ::quic_trace::EventType event_type() const;
  void set_event_type(::quic_trace::EventType value);
  private:
  ::quic_trace::EventType _internal_event_type() const;
  void _internal_set_event_type(::quic_trace::EventType value);
  public:

  // optional .quic_trace.EncryptionLevel encryption_level = 6;
  bool has_encryption_level() const;
  private:
  bool _internal_has_encryption_level() const;
  public:
  void clear_encryption_level();
  ::quic_trace::EncryptionLevel encryption_level() const;
  void set_encryption_level(::quic_trace::EncryptionLevel value);
  private:
  ::quic_trace::EncryptionLevel _internal_encryption_level() const;
  void _internal_set_encryption_level(::quic_trace::EncryptionLevel value);
  public:

  // optional uint64 packet_size = 5;
  bool has_packet_size() const;
  private:
  bool _internal_has_packet_size() const;
  public:
  void clear_packet_size();
  uint64_t packet_size() const;
  void set_packet_size(uint64_t value);
  private:
  uint64_t _internal_packet_size() const;
  void _internal_set_packet_size(uint64_t value);
  public:

  // optional .quic_trace.TransmissionReason transmission_reason = 9 [default = NORMAL_TRANSMISSION];
  bool has_transmission_reason() const;
  private:
  bool _internal_has_transmission_reason() const;
  public:
  void clear_transmission_reason();
  ::quic_trace::TransmissionReason transmission_reason() const;
  void set_transmission_reason(::quic_trace::TransmissionReason value);
  private:
  ::quic_trace::TransmissionReason _internal_transmission_reason() const;
  void _internal_set_transmission_reason(::quic_trace::TransmissionReason value);
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::Frame > frames_;
  ::quic_trace::TransportState* transport_state_;
  ::quic_trace::ExternalNetworkParameters* external_network_parameters_;
  uint64_t time_us_;
  uint64_t packet_number_;
  int event_type_;
  int encryption_level_;
  uint64_t packet_size_;
  int transmission_reason_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// -------------------------------------------------------------------

class Trace final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:quic_trace.Trace) */ {
 public:
  inline Trace() : Trace(nullptr) {}
  ~Trace() override;
  explicit PROTOBUF_CONSTEXPR Trace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trace(const Trace& from);
  Trace(Trace&& from) noexcept
    : Trace() {
    *this = ::std::move(from);
  }

  inline Trace& operator=(const Trace& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trace& operator=(Trace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Trace& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trace* internal_default_instance() {
    return reinterpret_cast<const Trace*>(
               &_Trace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Trace& a, Trace& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Trace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trace>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Trace& from);
  void MergeFrom(const Trace& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Trace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "quic_trace.Trace";
  }
  protected:
  explicit Trace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 4,
    kProtocolVersionFieldNumber = 1,
    kSourceConnectionIdFieldNumber = 2,
    kDestinationConnectionIdFieldNumber = 3,
  };
  // repeated .quic_trace.Event events = 4;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::quic_trace::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::Event >*
      mutable_events();
  private:
  const ::quic_trace::Event& _internal_events(int index) const;
  ::quic_trace::Event* _internal_add_events();
  public:
  const ::quic_trace::Event& events(int index) const;
  ::quic_trace::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::Event >&
      events() const;

  // optional bytes protocol_version = 1;
  bool has_protocol_version() const;
  private:
  bool _internal_has_protocol_version() const;
  public:
  void clear_protocol_version();
  const std::string& protocol_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol_version();
  PROTOBUF_NODISCARD std::string* release_protocol_version();
  void set_allocated_protocol_version(std::string* protocol_version);
  private:
  const std::string& _internal_protocol_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol_version(const std::string& value);
  std::string* _internal_mutable_protocol_version();
  public:

  // optional bytes source_connection_id = 2;
  bool has_source_connection_id() const;
  private:
  bool _internal_has_source_connection_id() const;
  public:
  void clear_source_connection_id();
  const std::string& source_connection_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_connection_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_connection_id();
  PROTOBUF_NODISCARD std::string* release_source_connection_id();
  void set_allocated_source_connection_id(std::string* source_connection_id);
  private:
  const std::string& _internal_source_connection_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_connection_id(const std::string& value);
  std::string* _internal_mutable_source_connection_id();
  public:

  // optional bytes destination_connection_id = 3;
  bool has_destination_connection_id() const;
  private:
  bool _internal_has_destination_connection_id() const;
  public:
  void clear_destination_connection_id();
  const std::string& destination_connection_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_connection_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_connection_id();
  PROTOBUF_NODISCARD std::string* release_destination_connection_id();
  void set_allocated_destination_connection_id(std::string* destination_connection_id);
  private:
  const std::string& _internal_destination_connection_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_connection_id(const std::string& value);
  std::string* _internal_mutable_destination_connection_id();
  public:

  // @@protoc_insertion_point(class_scope:quic_trace.Trace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::Event > events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_connection_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_connection_id_;
  friend struct ::TableStruct_quic_5ftrace_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StreamFrameInfo

// optional uint64 stream_id = 1;
inline bool StreamFrameInfo::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StreamFrameInfo::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void StreamFrameInfo::clear_stream_id() {
  stream_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t StreamFrameInfo::_internal_stream_id() const {
  return stream_id_;
}
inline uint64_t StreamFrameInfo::stream_id() const {
  // @@protoc_insertion_point(field_get:quic_trace.StreamFrameInfo.stream_id)
  return _internal_stream_id();
}
inline void StreamFrameInfo::_internal_set_stream_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  stream_id_ = value;
}
inline void StreamFrameInfo::set_stream_id(uint64_t value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:quic_trace.StreamFrameInfo.stream_id)
}

// optional bool fin = 2;
inline bool StreamFrameInfo::_internal_has_fin() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StreamFrameInfo::has_fin() const {
  return _internal_has_fin();
}
inline void StreamFrameInfo::clear_fin() {
  fin_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool StreamFrameInfo::_internal_fin() const {
  return fin_;
}
inline bool StreamFrameInfo::fin() const {
  // @@protoc_insertion_point(field_get:quic_trace.StreamFrameInfo.fin)
  return _internal_fin();
}
inline void StreamFrameInfo::_internal_set_fin(bool value) {
  _has_bits_[0] |= 0x00000008u;
  fin_ = value;
}
inline void StreamFrameInfo::set_fin(bool value) {
  _internal_set_fin(value);
  // @@protoc_insertion_point(field_set:quic_trace.StreamFrameInfo.fin)
}

// optional uint64 length = 3;
inline bool StreamFrameInfo::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StreamFrameInfo::has_length() const {
  return _internal_has_length();
}
inline void StreamFrameInfo::clear_length() {
  length_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t StreamFrameInfo::_internal_length() const {
  return length_;
}
inline uint64_t StreamFrameInfo::length() const {
  // @@protoc_insertion_point(field_get:quic_trace.StreamFrameInfo.length)
  return _internal_length();
}
inline void StreamFrameInfo::_internal_set_length(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  length_ = value;
}
inline void StreamFrameInfo::set_length(uint64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:quic_trace.StreamFrameInfo.length)
}

// optional uint64 offset = 4;
inline bool StreamFrameInfo::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StreamFrameInfo::has_offset() const {
  return _internal_has_offset();
}
inline void StreamFrameInfo::clear_offset() {
  offset_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t StreamFrameInfo::_internal_offset() const {
  return offset_;
}
inline uint64_t StreamFrameInfo::offset() const {
  // @@protoc_insertion_point(field_get:quic_trace.StreamFrameInfo.offset)
  return _internal_offset();
}
inline void StreamFrameInfo::_internal_set_offset(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  offset_ = value;
}
inline void StreamFrameInfo::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:quic_trace.StreamFrameInfo.offset)
}

// -------------------------------------------------------------------

// CryptoFrameInfo

// optional uint64 length = 1;
inline bool CryptoFrameInfo::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CryptoFrameInfo::has_length() const {
  return _internal_has_length();
}
inline void CryptoFrameInfo::clear_length() {
  length_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CryptoFrameInfo::_internal_length() const {
  return length_;
}
inline uint64_t CryptoFrameInfo::length() const {
  // @@protoc_insertion_point(field_get:quic_trace.CryptoFrameInfo.length)
  return _internal_length();
}
inline void CryptoFrameInfo::_internal_set_length(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  length_ = value;
}
inline void CryptoFrameInfo::set_length(uint64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:quic_trace.CryptoFrameInfo.length)
}

// optional uint64 offset = 2;
inline bool CryptoFrameInfo::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CryptoFrameInfo::has_offset() const {
  return _internal_has_offset();
}
inline void CryptoFrameInfo::clear_offset() {
  offset_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CryptoFrameInfo::_internal_offset() const {
  return offset_;
}
inline uint64_t CryptoFrameInfo::offset() const {
  // @@protoc_insertion_point(field_get:quic_trace.CryptoFrameInfo.offset)
  return _internal_offset();
}
inline void CryptoFrameInfo::_internal_set_offset(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  offset_ = value;
}
inline void CryptoFrameInfo::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:quic_trace.CryptoFrameInfo.offset)
}

// -------------------------------------------------------------------

// AckBlock

// optional uint64 first_packet = 1;
inline bool AckBlock::_internal_has_first_packet() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AckBlock::has_first_packet() const {
  return _internal_has_first_packet();
}
inline void AckBlock::clear_first_packet() {
  first_packet_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t AckBlock::_internal_first_packet() const {
  return first_packet_;
}
inline uint64_t AckBlock::first_packet() const {
  // @@protoc_insertion_point(field_get:quic_trace.AckBlock.first_packet)
  return _internal_first_packet();
}
inline void AckBlock::_internal_set_first_packet(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  first_packet_ = value;
}
inline void AckBlock::set_first_packet(uint64_t value) {
  _internal_set_first_packet(value);
  // @@protoc_insertion_point(field_set:quic_trace.AckBlock.first_packet)
}

// optional uint64 last_packet = 2;
inline bool AckBlock::_internal_has_last_packet() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AckBlock::has_last_packet() const {
  return _internal_has_last_packet();
}
inline void AckBlock::clear_last_packet() {
  last_packet_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t AckBlock::_internal_last_packet() const {
  return last_packet_;
}
inline uint64_t AckBlock::last_packet() const {
  // @@protoc_insertion_point(field_get:quic_trace.AckBlock.last_packet)
  return _internal_last_packet();
}
inline void AckBlock::_internal_set_last_packet(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  last_packet_ = value;
}
inline void AckBlock::set_last_packet(uint64_t value) {
  _internal_set_last_packet(value);
  // @@protoc_insertion_point(field_set:quic_trace.AckBlock.last_packet)
}

// -------------------------------------------------------------------

// AckInfo

// repeated .quic_trace.AckBlock acked_packets = 1;
inline int AckInfo::_internal_acked_packets_size() const {
  return acked_packets_.size();
}
inline int AckInfo::acked_packets_size() const {
  return _internal_acked_packets_size();
}
inline void AckInfo::clear_acked_packets() {
  acked_packets_.Clear();
}
inline ::quic_trace::AckBlock* AckInfo::mutable_acked_packets(int index) {
  // @@protoc_insertion_point(field_mutable:quic_trace.AckInfo.acked_packets)
  return acked_packets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::AckBlock >*
AckInfo::mutable_acked_packets() {
  // @@protoc_insertion_point(field_mutable_list:quic_trace.AckInfo.acked_packets)
  return &acked_packets_;
}
inline const ::quic_trace::AckBlock& AckInfo::_internal_acked_packets(int index) const {
  return acked_packets_.Get(index);
}
inline const ::quic_trace::AckBlock& AckInfo::acked_packets(int index) const {
  // @@protoc_insertion_point(field_get:quic_trace.AckInfo.acked_packets)
  return _internal_acked_packets(index);
}
inline ::quic_trace::AckBlock* AckInfo::_internal_add_acked_packets() {
  return acked_packets_.Add();
}
inline ::quic_trace::AckBlock* AckInfo::add_acked_packets() {
  ::quic_trace::AckBlock* _add = _internal_add_acked_packets();
  // @@protoc_insertion_point(field_add:quic_trace.AckInfo.acked_packets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::AckBlock >&
AckInfo::acked_packets() const {
  // @@protoc_insertion_point(field_list:quic_trace.AckInfo.acked_packets)
  return acked_packets_;
}

// optional uint64 ack_delay_us = 2;
inline bool AckInfo::_internal_has_ack_delay_us() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AckInfo::has_ack_delay_us() const {
  return _internal_has_ack_delay_us();
}
inline void AckInfo::clear_ack_delay_us() {
  ack_delay_us_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t AckInfo::_internal_ack_delay_us() const {
  return ack_delay_us_;
}
inline uint64_t AckInfo::ack_delay_us() const {
  // @@protoc_insertion_point(field_get:quic_trace.AckInfo.ack_delay_us)
  return _internal_ack_delay_us();
}
inline void AckInfo::_internal_set_ack_delay_us(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  ack_delay_us_ = value;
}
inline void AckInfo::set_ack_delay_us(uint64_t value) {
  _internal_set_ack_delay_us(value);
  // @@protoc_insertion_point(field_set:quic_trace.AckInfo.ack_delay_us)
}

// -------------------------------------------------------------------

// ResetStreamInfo

// optional uint64 stream_id = 1;
inline bool ResetStreamInfo::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResetStreamInfo::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void ResetStreamInfo::clear_stream_id() {
  stream_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ResetStreamInfo::_internal_stream_id() const {
  return stream_id_;
}
inline uint64_t ResetStreamInfo::stream_id() const {
  // @@protoc_insertion_point(field_get:quic_trace.ResetStreamInfo.stream_id)
  return _internal_stream_id();
}
inline void ResetStreamInfo::_internal_set_stream_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  stream_id_ = value;
}
inline void ResetStreamInfo::set_stream_id(uint64_t value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:quic_trace.ResetStreamInfo.stream_id)
}

// optional uint32 application_error_code = 2;
inline bool ResetStreamInfo::_internal_has_application_error_code() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResetStreamInfo::has_application_error_code() const {
  return _internal_has_application_error_code();
}
inline void ResetStreamInfo::clear_application_error_code() {
  application_error_code_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ResetStreamInfo::_internal_application_error_code() const {
  return application_error_code_;
}
inline uint32_t ResetStreamInfo::application_error_code() const {
  // @@protoc_insertion_point(field_get:quic_trace.ResetStreamInfo.application_error_code)
  return _internal_application_error_code();
}
inline void ResetStreamInfo::_internal_set_application_error_code(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  application_error_code_ = value;
}
inline void ResetStreamInfo::set_application_error_code(uint32_t value) {
  _internal_set_application_error_code(value);
  // @@protoc_insertion_point(field_set:quic_trace.ResetStreamInfo.application_error_code)
}

// optional uint64 final_offset = 3;
inline bool ResetStreamInfo::_internal_has_final_offset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResetStreamInfo::has_final_offset() const {
  return _internal_has_final_offset();
}
inline void ResetStreamInfo::clear_final_offset() {
  final_offset_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t ResetStreamInfo::_internal_final_offset() const {
  return final_offset_;
}
inline uint64_t ResetStreamInfo::final_offset() const {
  // @@protoc_insertion_point(field_get:quic_trace.ResetStreamInfo.final_offset)
  return _internal_final_offset();
}
inline void ResetStreamInfo::_internal_set_final_offset(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  final_offset_ = value;
}
inline void ResetStreamInfo::set_final_offset(uint64_t value) {
  _internal_set_final_offset(value);
  // @@protoc_insertion_point(field_set:quic_trace.ResetStreamInfo.final_offset)
}

// -------------------------------------------------------------------

// CloseInfo

// optional uint32 error_code = 1;
inline bool CloseInfo::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CloseInfo::has_error_code() const {
  return _internal_has_error_code();
}
inline void CloseInfo::clear_error_code() {
  error_code_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CloseInfo::_internal_error_code() const {
  return error_code_;
}
inline uint32_t CloseInfo::error_code() const {
  // @@protoc_insertion_point(field_get:quic_trace.CloseInfo.error_code)
  return _internal_error_code();
}
inline void CloseInfo::_internal_set_error_code(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  error_code_ = value;
}
inline void CloseInfo::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:quic_trace.CloseInfo.error_code)
}

// optional string reason_phrase = 2;
inline bool CloseInfo::_internal_has_reason_phrase() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CloseInfo::has_reason_phrase() const {
  return _internal_has_reason_phrase();
}
inline void CloseInfo::clear_reason_phrase() {
  reason_phrase_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CloseInfo::reason_phrase() const {
  // @@protoc_insertion_point(field_get:quic_trace.CloseInfo.reason_phrase)
  return _internal_reason_phrase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloseInfo::set_reason_phrase(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 reason_phrase_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:quic_trace.CloseInfo.reason_phrase)
}
inline std::string* CloseInfo::mutable_reason_phrase() {
  std::string* _s = _internal_mutable_reason_phrase();
  // @@protoc_insertion_point(field_mutable:quic_trace.CloseInfo.reason_phrase)
  return _s;
}
inline const std::string& CloseInfo::_internal_reason_phrase() const {
  return reason_phrase_.Get();
}
inline void CloseInfo::_internal_set_reason_phrase(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_phrase_.Set(value, GetArenaForAllocation());
}
inline std::string* CloseInfo::_internal_mutable_reason_phrase() {
  _has_bits_[0] |= 0x00000001u;
  return reason_phrase_.Mutable(GetArenaForAllocation());
}
inline std::string* CloseInfo::release_reason_phrase() {
  // @@protoc_insertion_point(field_release:quic_trace.CloseInfo.reason_phrase)
  if (!_internal_has_reason_phrase()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = reason_phrase_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_phrase_.IsDefault()) {
    reason_phrase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CloseInfo::set_allocated_reason_phrase(std::string* reason_phrase) {
  if (reason_phrase != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_phrase_.SetAllocated(reason_phrase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_phrase_.IsDefault()) {
    reason_phrase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:quic_trace.CloseInfo.reason_phrase)
}

// optional .quic_trace.CloseType close_type = 3;
inline bool CloseInfo::_internal_has_close_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CloseInfo::has_close_type() const {
  return _internal_has_close_type();
}
inline void CloseInfo::clear_close_type() {
  close_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::quic_trace::CloseType CloseInfo::_internal_close_type() const {
  return static_cast< ::quic_trace::CloseType >(close_type_);
}
inline ::quic_trace::CloseType CloseInfo::close_type() const {
  // @@protoc_insertion_point(field_get:quic_trace.CloseInfo.close_type)
  return _internal_close_type();
}
inline void CloseInfo::_internal_set_close_type(::quic_trace::CloseType value) {
  assert(::quic_trace::CloseType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  close_type_ = value;
}
inline void CloseInfo::set_close_type(::quic_trace::CloseType value) {
  _internal_set_close_type(value);
  // @@protoc_insertion_point(field_set:quic_trace.CloseInfo.close_type)
}

// optional uint64 transport_close_frame_type = 4;
inline bool CloseInfo::_internal_has_transport_close_frame_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CloseInfo::has_transport_close_frame_type() const {
  return _internal_has_transport_close_frame_type();
}
inline void CloseInfo::clear_transport_close_frame_type() {
  transport_close_frame_type_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CloseInfo::_internal_transport_close_frame_type() const {
  return transport_close_frame_type_;
}
inline uint64_t CloseInfo::transport_close_frame_type() const {
  // @@protoc_insertion_point(field_get:quic_trace.CloseInfo.transport_close_frame_type)
  return _internal_transport_close_frame_type();
}
inline void CloseInfo::_internal_set_transport_close_frame_type(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  transport_close_frame_type_ = value;
}
inline void CloseInfo::set_transport_close_frame_type(uint64_t value) {
  _internal_set_transport_close_frame_type(value);
  // @@protoc_insertion_point(field_set:quic_trace.CloseInfo.transport_close_frame_type)
}

// -------------------------------------------------------------------

// FlowControlInfo

// optional uint64 max_data = 1;
inline bool FlowControlInfo::_internal_has_max_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FlowControlInfo::has_max_data() const {
  return _internal_has_max_data();
}
inline void FlowControlInfo::clear_max_data() {
  max_data_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t FlowControlInfo::_internal_max_data() const {
  return max_data_;
}
inline uint64_t FlowControlInfo::max_data() const {
  // @@protoc_insertion_point(field_get:quic_trace.FlowControlInfo.max_data)
  return _internal_max_data();
}
inline void FlowControlInfo::_internal_set_max_data(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  max_data_ = value;
}
inline void FlowControlInfo::set_max_data(uint64_t value) {
  _internal_set_max_data(value);
  // @@protoc_insertion_point(field_set:quic_trace.FlowControlInfo.max_data)
}

// optional uint64 stream_id = 2;
inline bool FlowControlInfo::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FlowControlInfo::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void FlowControlInfo::clear_stream_id() {
  stream_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t FlowControlInfo::_internal_stream_id() const {
  return stream_id_;
}
inline uint64_t FlowControlInfo::stream_id() const {
  // @@protoc_insertion_point(field_get:quic_trace.FlowControlInfo.stream_id)
  return _internal_stream_id();
}
inline void FlowControlInfo::_internal_set_stream_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  stream_id_ = value;
}
inline void FlowControlInfo::set_stream_id(uint64_t value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:quic_trace.FlowControlInfo.stream_id)
}

// -------------------------------------------------------------------

// Frame

// optional .quic_trace.FrameType frame_type = 1;
inline bool Frame::_internal_has_frame_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Frame::has_frame_type() const {
  return _internal_has_frame_type();
}
inline void Frame::clear_frame_type() {
  frame_type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::quic_trace::FrameType Frame::_internal_frame_type() const {
  return static_cast< ::quic_trace::FrameType >(frame_type_);
}
inline ::quic_trace::FrameType Frame::frame_type() const {
  // @@protoc_insertion_point(field_get:quic_trace.Frame.frame_type)
  return _internal_frame_type();
}
inline void Frame::_internal_set_frame_type(::quic_trace::FrameType value) {
  assert(::quic_trace::FrameType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  frame_type_ = value;
}
inline void Frame::set_frame_type(::quic_trace::FrameType value) {
  _internal_set_frame_type(value);
  // @@protoc_insertion_point(field_set:quic_trace.Frame.frame_type)
}

// optional .quic_trace.StreamFrameInfo stream_frame_info = 2;
inline bool Frame::_internal_has_stream_frame_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || stream_frame_info_ != nullptr);
  return value;
}
inline bool Frame::has_stream_frame_info() const {
  return _internal_has_stream_frame_info();
}
inline void Frame::clear_stream_frame_info() {
  if (stream_frame_info_ != nullptr) stream_frame_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::quic_trace::StreamFrameInfo& Frame::_internal_stream_frame_info() const {
  const ::quic_trace::StreamFrameInfo* p = stream_frame_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::quic_trace::StreamFrameInfo&>(
      ::quic_trace::_StreamFrameInfo_default_instance_);
}
inline const ::quic_trace::StreamFrameInfo& Frame::stream_frame_info() const {
  // @@protoc_insertion_point(field_get:quic_trace.Frame.stream_frame_info)
  return _internal_stream_frame_info();
}
inline void Frame::unsafe_arena_set_allocated_stream_frame_info(
    ::quic_trace::StreamFrameInfo* stream_frame_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream_frame_info_);
  }
  stream_frame_info_ = stream_frame_info;
  if (stream_frame_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:quic_trace.Frame.stream_frame_info)
}
inline ::quic_trace::StreamFrameInfo* Frame::release_stream_frame_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::quic_trace::StreamFrameInfo* temp = stream_frame_info_;
  stream_frame_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::quic_trace::StreamFrameInfo* Frame::unsafe_arena_release_stream_frame_info() {
  // @@protoc_insertion_point(field_release:quic_trace.Frame.stream_frame_info)
  _has_bits_[0] &= ~0x00000001u;
  ::quic_trace::StreamFrameInfo* temp = stream_frame_info_;
  stream_frame_info_ = nullptr;
  return temp;
}
inline ::quic_trace::StreamFrameInfo* Frame::_internal_mutable_stream_frame_info() {
  _has_bits_[0] |= 0x00000001u;
  if (stream_frame_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::quic_trace::StreamFrameInfo>(GetArenaForAllocation());
    stream_frame_info_ = p;
  }
  return stream_frame_info_;
}
inline ::quic_trace::StreamFrameInfo* Frame::mutable_stream_frame_info() {
  ::quic_trace::StreamFrameInfo* _msg = _internal_mutable_stream_frame_info();
  // @@protoc_insertion_point(field_mutable:quic_trace.Frame.stream_frame_info)
  return _msg;
}
inline void Frame::set_allocated_stream_frame_info(::quic_trace::StreamFrameInfo* stream_frame_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stream_frame_info_;
  }
  if (stream_frame_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stream_frame_info);
    if (message_arena != submessage_arena) {
      stream_frame_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream_frame_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stream_frame_info_ = stream_frame_info;
  // @@protoc_insertion_point(field_set_allocated:quic_trace.Frame.stream_frame_info)
}

// optional .quic_trace.AckInfo ack_info = 3;
inline bool Frame::_internal_has_ack_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || ack_info_ != nullptr);
  return value;
}
inline bool Frame::has_ack_info() const {
  return _internal_has_ack_info();
}
inline void Frame::clear_ack_info() {
  if (ack_info_ != nullptr) ack_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::quic_trace::AckInfo& Frame::_internal_ack_info() const {
  const ::quic_trace::AckInfo* p = ack_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::quic_trace::AckInfo&>(
      ::quic_trace::_AckInfo_default_instance_);
}
inline const ::quic_trace::AckInfo& Frame::ack_info() const {
  // @@protoc_insertion_point(field_get:quic_trace.Frame.ack_info)
  return _internal_ack_info();
}
inline void Frame::unsafe_arena_set_allocated_ack_info(
    ::quic_trace::AckInfo* ack_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ack_info_);
  }
  ack_info_ = ack_info;
  if (ack_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:quic_trace.Frame.ack_info)
}
inline ::quic_trace::AckInfo* Frame::release_ack_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::quic_trace::AckInfo* temp = ack_info_;
  ack_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::quic_trace::AckInfo* Frame::unsafe_arena_release_ack_info() {
  // @@protoc_insertion_point(field_release:quic_trace.Frame.ack_info)
  _has_bits_[0] &= ~0x00000002u;
  ::quic_trace::AckInfo* temp = ack_info_;
  ack_info_ = nullptr;
  return temp;
}
inline ::quic_trace::AckInfo* Frame::_internal_mutable_ack_info() {
  _has_bits_[0] |= 0x00000002u;
  if (ack_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::quic_trace::AckInfo>(GetArenaForAllocation());
    ack_info_ = p;
  }
  return ack_info_;
}
inline ::quic_trace::AckInfo* Frame::mutable_ack_info() {
  ::quic_trace::AckInfo* _msg = _internal_mutable_ack_info();
  // @@protoc_insertion_point(field_mutable:quic_trace.Frame.ack_info)
  return _msg;
}
inline void Frame::set_allocated_ack_info(::quic_trace::AckInfo* ack_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ack_info_;
  }
  if (ack_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ack_info);
    if (message_arena != submessage_arena) {
      ack_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ack_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ack_info_ = ack_info;
  // @@protoc_insertion_point(field_set_allocated:quic_trace.Frame.ack_info)
}

// optional .quic_trace.ResetStreamInfo reset_stream_info = 4;
inline bool Frame::_internal_has_reset_stream_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || reset_stream_info_ != nullptr);
  return value;
}
inline bool Frame::has_reset_stream_info() const {
  return _internal_has_reset_stream_info();
}
inline void Frame::clear_reset_stream_info() {
  if (reset_stream_info_ != nullptr) reset_stream_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::quic_trace::ResetStreamInfo& Frame::_internal_reset_stream_info() const {
  const ::quic_trace::ResetStreamInfo* p = reset_stream_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::quic_trace::ResetStreamInfo&>(
      ::quic_trace::_ResetStreamInfo_default_instance_);
}
inline const ::quic_trace::ResetStreamInfo& Frame::reset_stream_info() const {
  // @@protoc_insertion_point(field_get:quic_trace.Frame.reset_stream_info)
  return _internal_reset_stream_info();
}
inline void Frame::unsafe_arena_set_allocated_reset_stream_info(
    ::quic_trace::ResetStreamInfo* reset_stream_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reset_stream_info_);
  }
  reset_stream_info_ = reset_stream_info;
  if (reset_stream_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:quic_trace.Frame.reset_stream_info)
}
inline ::quic_trace::ResetStreamInfo* Frame::release_reset_stream_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::quic_trace::ResetStreamInfo* temp = reset_stream_info_;
  reset_stream_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::quic_trace::ResetStreamInfo* Frame::unsafe_arena_release_reset_stream_info() {
  // @@protoc_insertion_point(field_release:quic_trace.Frame.reset_stream_info)
  _has_bits_[0] &= ~0x00000004u;
  ::quic_trace::ResetStreamInfo* temp = reset_stream_info_;
  reset_stream_info_ = nullptr;
  return temp;
}
inline ::quic_trace::ResetStreamInfo* Frame::_internal_mutable_reset_stream_info() {
  _has_bits_[0] |= 0x00000004u;
  if (reset_stream_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::quic_trace::ResetStreamInfo>(GetArenaForAllocation());
    reset_stream_info_ = p;
  }
  return reset_stream_info_;
}
inline ::quic_trace::ResetStreamInfo* Frame::mutable_reset_stream_info() {
  ::quic_trace::ResetStreamInfo* _msg = _internal_mutable_reset_stream_info();
  // @@protoc_insertion_point(field_mutable:quic_trace.Frame.reset_stream_info)
  return _msg;
}
inline void Frame::set_allocated_reset_stream_info(::quic_trace::ResetStreamInfo* reset_stream_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reset_stream_info_;
  }
  if (reset_stream_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reset_stream_info);
    if (message_arena != submessage_arena) {
      reset_stream_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reset_stream_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  reset_stream_info_ = reset_stream_info;
  // @@protoc_insertion_point(field_set_allocated:quic_trace.Frame.reset_stream_info)
}

// optional .quic_trace.CloseInfo close_info = 5;
inline bool Frame::_internal_has_close_info() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || close_info_ != nullptr);
  return value;
}
inline bool Frame::has_close_info() const {
  return _internal_has_close_info();
}
inline void Frame::clear_close_info() {
  if (close_info_ != nullptr) close_info_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::quic_trace::CloseInfo& Frame::_internal_close_info() const {
  const ::quic_trace::CloseInfo* p = close_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::quic_trace::CloseInfo&>(
      ::quic_trace::_CloseInfo_default_instance_);
}
inline const ::quic_trace::CloseInfo& Frame::close_info() const {
  // @@protoc_insertion_point(field_get:quic_trace.Frame.close_info)
  return _internal_close_info();
}
inline void Frame::unsafe_arena_set_allocated_close_info(
    ::quic_trace::CloseInfo* close_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(close_info_);
  }
  close_info_ = close_info;
  if (close_info) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:quic_trace.Frame.close_info)
}
inline ::quic_trace::CloseInfo* Frame::release_close_info() {
  _has_bits_[0] &= ~0x00000008u;
  ::quic_trace::CloseInfo* temp = close_info_;
  close_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::quic_trace::CloseInfo* Frame::unsafe_arena_release_close_info() {
  // @@protoc_insertion_point(field_release:quic_trace.Frame.close_info)
  _has_bits_[0] &= ~0x00000008u;
  ::quic_trace::CloseInfo* temp = close_info_;
  close_info_ = nullptr;
  return temp;
}
inline ::quic_trace::CloseInfo* Frame::_internal_mutable_close_info() {
  _has_bits_[0] |= 0x00000008u;
  if (close_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::quic_trace::CloseInfo>(GetArenaForAllocation());
    close_info_ = p;
  }
  return close_info_;
}
inline ::quic_trace::CloseInfo* Frame::mutable_close_info() {
  ::quic_trace::CloseInfo* _msg = _internal_mutable_close_info();
  // @@protoc_insertion_point(field_mutable:quic_trace.Frame.close_info)
  return _msg;
}
inline void Frame::set_allocated_close_info(::quic_trace::CloseInfo* close_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete close_info_;
  }
  if (close_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(close_info);
    if (message_arena != submessage_arena) {
      close_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, close_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  close_info_ = close_info;
  // @@protoc_insertion_point(field_set_allocated:quic_trace.Frame.close_info)
}

// optional .quic_trace.FlowControlInfo flow_control_info = 6;
inline bool Frame::_internal_has_flow_control_info() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || flow_control_info_ != nullptr);
  return value;
}
inline bool Frame::has_flow_control_info() const {
  return _internal_has_flow_control_info();
}
inline void Frame::clear_flow_control_info() {
  if (flow_control_info_ != nullptr) flow_control_info_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::quic_trace::FlowControlInfo& Frame::_internal_flow_control_info() const {
  const ::quic_trace::FlowControlInfo* p = flow_control_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::quic_trace::FlowControlInfo&>(
      ::quic_trace::_FlowControlInfo_default_instance_);
}
inline const ::quic_trace::FlowControlInfo& Frame::flow_control_info() const {
  // @@protoc_insertion_point(field_get:quic_trace.Frame.flow_control_info)
  return _internal_flow_control_info();
}
inline void Frame::unsafe_arena_set_allocated_flow_control_info(
    ::quic_trace::FlowControlInfo* flow_control_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_control_info_);
  }
  flow_control_info_ = flow_control_info;
  if (flow_control_info) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:quic_trace.Frame.flow_control_info)
}
inline ::quic_trace::FlowControlInfo* Frame::release_flow_control_info() {
  _has_bits_[0] &= ~0x00000010u;
  ::quic_trace::FlowControlInfo* temp = flow_control_info_;
  flow_control_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::quic_trace::FlowControlInfo* Frame::unsafe_arena_release_flow_control_info() {
  // @@protoc_insertion_point(field_release:quic_trace.Frame.flow_control_info)
  _has_bits_[0] &= ~0x00000010u;
  ::quic_trace::FlowControlInfo* temp = flow_control_info_;
  flow_control_info_ = nullptr;
  return temp;
}
inline ::quic_trace::FlowControlInfo* Frame::_internal_mutable_flow_control_info() {
  _has_bits_[0] |= 0x00000010u;
  if (flow_control_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::quic_trace::FlowControlInfo>(GetArenaForAllocation());
    flow_control_info_ = p;
  }
  return flow_control_info_;
}
inline ::quic_trace::FlowControlInfo* Frame::mutable_flow_control_info() {
  ::quic_trace::FlowControlInfo* _msg = _internal_mutable_flow_control_info();
  // @@protoc_insertion_point(field_mutable:quic_trace.Frame.flow_control_info)
  return _msg;
}
inline void Frame::set_allocated_flow_control_info(::quic_trace::FlowControlInfo* flow_control_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete flow_control_info_;
  }
  if (flow_control_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(flow_control_info);
    if (message_arena != submessage_arena) {
      flow_control_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_control_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  flow_control_info_ = flow_control_info;
  // @@protoc_insertion_point(field_set_allocated:quic_trace.Frame.flow_control_info)
}

// optional .quic_trace.CryptoFrameInfo crypto_frame_info = 7;
inline bool Frame::_internal_has_crypto_frame_info() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || crypto_frame_info_ != nullptr);
  return value;
}
inline bool Frame::has_crypto_frame_info() const {
  return _internal_has_crypto_frame_info();
}
inline void Frame::clear_crypto_frame_info() {
  if (crypto_frame_info_ != nullptr) crypto_frame_info_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::quic_trace::CryptoFrameInfo& Frame::_internal_crypto_frame_info() const {
  const ::quic_trace::CryptoFrameInfo* p = crypto_frame_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::quic_trace::CryptoFrameInfo&>(
      ::quic_trace::_CryptoFrameInfo_default_instance_);
}
inline const ::quic_trace::CryptoFrameInfo& Frame::crypto_frame_info() const {
  // @@protoc_insertion_point(field_get:quic_trace.Frame.crypto_frame_info)
  return _internal_crypto_frame_info();
}
inline void Frame::unsafe_arena_set_allocated_crypto_frame_info(
    ::quic_trace::CryptoFrameInfo* crypto_frame_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(crypto_frame_info_);
  }
  crypto_frame_info_ = crypto_frame_info;
  if (crypto_frame_info) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:quic_trace.Frame.crypto_frame_info)
}
inline ::quic_trace::CryptoFrameInfo* Frame::release_crypto_frame_info() {
  _has_bits_[0] &= ~0x00000020u;
  ::quic_trace::CryptoFrameInfo* temp = crypto_frame_info_;
  crypto_frame_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::quic_trace::CryptoFrameInfo* Frame::unsafe_arena_release_crypto_frame_info() {
  // @@protoc_insertion_point(field_release:quic_trace.Frame.crypto_frame_info)
  _has_bits_[0] &= ~0x00000020u;
  ::quic_trace::CryptoFrameInfo* temp = crypto_frame_info_;
  crypto_frame_info_ = nullptr;
  return temp;
}
inline ::quic_trace::CryptoFrameInfo* Frame::_internal_mutable_crypto_frame_info() {
  _has_bits_[0] |= 0x00000020u;
  if (crypto_frame_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::quic_trace::CryptoFrameInfo>(GetArenaForAllocation());
    crypto_frame_info_ = p;
  }
  return crypto_frame_info_;
}
inline ::quic_trace::CryptoFrameInfo* Frame::mutable_crypto_frame_info() {
  ::quic_trace::CryptoFrameInfo* _msg = _internal_mutable_crypto_frame_info();
  // @@protoc_insertion_point(field_mutable:quic_trace.Frame.crypto_frame_info)
  return _msg;
}
inline void Frame::set_allocated_crypto_frame_info(::quic_trace::CryptoFrameInfo* crypto_frame_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete crypto_frame_info_;
  }
  if (crypto_frame_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(crypto_frame_info);
    if (message_arena != submessage_arena) {
      crypto_frame_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crypto_frame_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  crypto_frame_info_ = crypto_frame_info;
  // @@protoc_insertion_point(field_set_allocated:quic_trace.Frame.crypto_frame_info)
}

// -------------------------------------------------------------------

// TransportState

// optional uint64 min_rtt_us = 1;
inline bool TransportState::_internal_has_min_rtt_us() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TransportState::has_min_rtt_us() const {
  return _internal_has_min_rtt_us();
}
inline void TransportState::clear_min_rtt_us() {
  min_rtt_us_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t TransportState::_internal_min_rtt_us() const {
  return min_rtt_us_;
}
inline uint64_t TransportState::min_rtt_us() const {
  // @@protoc_insertion_point(field_get:quic_trace.TransportState.min_rtt_us)
  return _internal_min_rtt_us();
}
inline void TransportState::_internal_set_min_rtt_us(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  min_rtt_us_ = value;
}
inline void TransportState::set_min_rtt_us(uint64_t value) {
  _internal_set_min_rtt_us(value);
  // @@protoc_insertion_point(field_set:quic_trace.TransportState.min_rtt_us)
}

// optional uint64 smoothed_rtt_us = 2;
inline bool TransportState::_internal_has_smoothed_rtt_us() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TransportState::has_smoothed_rtt_us() const {
  return _internal_has_smoothed_rtt_us();
}
inline void TransportState::clear_smoothed_rtt_us() {
  smoothed_rtt_us_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t TransportState::_internal_smoothed_rtt_us() const {
  return smoothed_rtt_us_;
}
inline uint64_t TransportState::smoothed_rtt_us() const {
  // @@protoc_insertion_point(field_get:quic_trace.TransportState.smoothed_rtt_us)
  return _internal_smoothed_rtt_us();
}
inline void TransportState::_internal_set_smoothed_rtt_us(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  smoothed_rtt_us_ = value;
}
inline void TransportState::set_smoothed_rtt_us(uint64_t value) {
  _internal_set_smoothed_rtt_us(value);
  // @@protoc_insertion_point(field_set:quic_trace.TransportState.smoothed_rtt_us)
}

// optional uint64 last_rtt_us = 3;
inline bool TransportState::_internal_has_last_rtt_us() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TransportState::has_last_rtt_us() const {
  return _internal_has_last_rtt_us();
}
inline void TransportState::clear_last_rtt_us() {
  last_rtt_us_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t TransportState::_internal_last_rtt_us() const {
  return last_rtt_us_;
}
inline uint64_t TransportState::last_rtt_us() const {
  // @@protoc_insertion_point(field_get:quic_trace.TransportState.last_rtt_us)
  return _internal_last_rtt_us();
}
inline void TransportState::_internal_set_last_rtt_us(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  last_rtt_us_ = value;
}
inline void TransportState::set_last_rtt_us(uint64_t value) {
  _internal_set_last_rtt_us(value);
  // @@protoc_insertion_point(field_set:quic_trace.TransportState.last_rtt_us)
}

// optional uint64 in_flight_bytes = 4;
inline bool TransportState::_internal_has_in_flight_bytes() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TransportState::has_in_flight_bytes() const {
  return _internal_has_in_flight_bytes();
}
inline void TransportState::clear_in_flight_bytes() {
  in_flight_bytes_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t TransportState::_internal_in_flight_bytes() const {
  return in_flight_bytes_;
}
inline uint64_t TransportState::in_flight_bytes() const {
  // @@protoc_insertion_point(field_get:quic_trace.TransportState.in_flight_bytes)
  return _internal_in_flight_bytes();
}
inline void TransportState::_internal_set_in_flight_bytes(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  in_flight_bytes_ = value;
}
inline void TransportState::set_in_flight_bytes(uint64_t value) {
  _internal_set_in_flight_bytes(value);
  // @@protoc_insertion_point(field_set:quic_trace.TransportState.in_flight_bytes)
}

// optional uint64 cwnd_bytes = 5;
inline bool TransportState::_internal_has_cwnd_bytes() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TransportState::has_cwnd_bytes() const {
  return _internal_has_cwnd_bytes();
}
inline void TransportState::clear_cwnd_bytes() {
  cwnd_bytes_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t TransportState::_internal_cwnd_bytes() const {
  return cwnd_bytes_;
}
inline uint64_t TransportState::cwnd_bytes() const {
  // @@protoc_insertion_point(field_get:quic_trace.TransportState.cwnd_bytes)
  return _internal_cwnd_bytes();
}
inline void TransportState::_internal_set_cwnd_bytes(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  cwnd_bytes_ = value;
}
inline void TransportState::set_cwnd_bytes(uint64_t value) {
  _internal_set_cwnd_bytes(value);
  // @@protoc_insertion_point(field_set:quic_trace.TransportState.cwnd_bytes)
}

// optional uint64 pacing_rate_bps = 6;
inline bool TransportState::_internal_has_pacing_rate_bps() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TransportState::has_pacing_rate_bps() const {
  return _internal_has_pacing_rate_bps();
}
inline void TransportState::clear_pacing_rate_bps() {
  pacing_rate_bps_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t TransportState::_internal_pacing_rate_bps() const {
  return pacing_rate_bps_;
}
inline uint64_t TransportState::pacing_rate_bps() const {
  // @@protoc_insertion_point(field_get:quic_trace.TransportState.pacing_rate_bps)
  return _internal_pacing_rate_bps();
}
inline void TransportState::_internal_set_pacing_rate_bps(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  pacing_rate_bps_ = value;
}
inline void TransportState::set_pacing_rate_bps(uint64_t value) {
  _internal_set_pacing_rate_bps(value);
  // @@protoc_insertion_point(field_set:quic_trace.TransportState.pacing_rate_bps)
}

// optional string congestion_control_state = 7;
inline bool TransportState::_internal_has_congestion_control_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransportState::has_congestion_control_state() const {
  return _internal_has_congestion_control_state();
}
inline void TransportState::clear_congestion_control_state() {
  congestion_control_state_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransportState::congestion_control_state() const {
  // @@protoc_insertion_point(field_get:quic_trace.TransportState.congestion_control_state)
  return _internal_congestion_control_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransportState::set_congestion_control_state(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 congestion_control_state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:quic_trace.TransportState.congestion_control_state)
}
inline std::string* TransportState::mutable_congestion_control_state() {
  std::string* _s = _internal_mutable_congestion_control_state();
  // @@protoc_insertion_point(field_mutable:quic_trace.TransportState.congestion_control_state)
  return _s;
}
inline const std::string& TransportState::_internal_congestion_control_state() const {
  return congestion_control_state_.Get();
}
inline void TransportState::_internal_set_congestion_control_state(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  congestion_control_state_.Set(value, GetArenaForAllocation());
}
inline std::string* TransportState::_internal_mutable_congestion_control_state() {
  _has_bits_[0] |= 0x00000001u;
  return congestion_control_state_.Mutable(GetArenaForAllocation());
}
inline std::string* TransportState::release_congestion_control_state() {
  // @@protoc_insertion_point(field_release:quic_trace.TransportState.congestion_control_state)
  if (!_internal_has_congestion_control_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = congestion_control_state_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (congestion_control_state_.IsDefault()) {
    congestion_control_state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransportState::set_allocated_congestion_control_state(std::string* congestion_control_state) {
  if (congestion_control_state != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  congestion_control_state_.SetAllocated(congestion_control_state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (congestion_control_state_.IsDefault()) {
    congestion_control_state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:quic_trace.TransportState.congestion_control_state)
}

// -------------------------------------------------------------------

// ExternalNetworkParameters

// optional uint64 bandwidth_bps = 1;
inline bool ExternalNetworkParameters::_internal_has_bandwidth_bps() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExternalNetworkParameters::has_bandwidth_bps() const {
  return _internal_has_bandwidth_bps();
}
inline void ExternalNetworkParameters::clear_bandwidth_bps() {
  bandwidth_bps_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ExternalNetworkParameters::_internal_bandwidth_bps() const {
  return bandwidth_bps_;
}
inline uint64_t ExternalNetworkParameters::bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:quic_trace.ExternalNetworkParameters.bandwidth_bps)
  return _internal_bandwidth_bps();
}
inline void ExternalNetworkParameters::_internal_set_bandwidth_bps(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  bandwidth_bps_ = value;
}
inline void ExternalNetworkParameters::set_bandwidth_bps(uint64_t value) {
  _internal_set_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:quic_trace.ExternalNetworkParameters.bandwidth_bps)
}

// optional uint64 rtt_us = 2;
inline bool ExternalNetworkParameters::_internal_has_rtt_us() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExternalNetworkParameters::has_rtt_us() const {
  return _internal_has_rtt_us();
}
inline void ExternalNetworkParameters::clear_rtt_us() {
  rtt_us_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t ExternalNetworkParameters::_internal_rtt_us() const {
  return rtt_us_;
}
inline uint64_t ExternalNetworkParameters::rtt_us() const {
  // @@protoc_insertion_point(field_get:quic_trace.ExternalNetworkParameters.rtt_us)
  return _internal_rtt_us();
}
inline void ExternalNetworkParameters::_internal_set_rtt_us(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  rtt_us_ = value;
}
inline void ExternalNetworkParameters::set_rtt_us(uint64_t value) {
  _internal_set_rtt_us(value);
  // @@protoc_insertion_point(field_set:quic_trace.ExternalNetworkParameters.rtt_us)
}

// optional uint64 cwnd_bytes = 3;
inline bool ExternalNetworkParameters::_internal_has_cwnd_bytes() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExternalNetworkParameters::has_cwnd_bytes() const {
  return _internal_has_cwnd_bytes();
}
inline void ExternalNetworkParameters::clear_cwnd_bytes() {
  cwnd_bytes_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t ExternalNetworkParameters::_internal_cwnd_bytes() const {
  return cwnd_bytes_;
}
inline uint64_t ExternalNetworkParameters::cwnd_bytes() const {
  // @@protoc_insertion_point(field_get:quic_trace.ExternalNetworkParameters.cwnd_bytes)
  return _internal_cwnd_bytes();
}
inline void ExternalNetworkParameters::_internal_set_cwnd_bytes(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  cwnd_bytes_ = value;
}
inline void ExternalNetworkParameters::set_cwnd_bytes(uint64_t value) {
  _internal_set_cwnd_bytes(value);
  // @@protoc_insertion_point(field_set:quic_trace.ExternalNetworkParameters.cwnd_bytes)
}

// -------------------------------------------------------------------

// Event

// optional uint64 time_us = 1;
inline bool Event::_internal_has_time_us() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Event::has_time_us() const {
  return _internal_has_time_us();
}
inline void Event::clear_time_us() {
  time_us_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t Event::_internal_time_us() const {
  return time_us_;
}
inline uint64_t Event::time_us() const {
  // @@protoc_insertion_point(field_get:quic_trace.Event.time_us)
  return _internal_time_us();
}
inline void Event::_internal_set_time_us(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  time_us_ = value;
}
inline void Event::set_time_us(uint64_t value) {
  _internal_set_time_us(value);
  // @@protoc_insertion_point(field_set:quic_trace.Event.time_us)
}

// optional .quic_trace.EventType event_type = 2;
inline bool Event::_internal_has_event_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Event::has_event_type() const {
  return _internal_has_event_type();
}
inline void Event::clear_event_type() {
  event_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::quic_trace::EventType Event::_internal_event_type() const {
  return static_cast< ::quic_trace::EventType >(event_type_);
}
inline ::quic_trace::EventType Event::event_type() const {
  // @@protoc_insertion_point(field_get:quic_trace.Event.event_type)
  return _internal_event_type();
}
inline void Event::_internal_set_event_type(::quic_trace::EventType value) {
  assert(::quic_trace::EventType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  event_type_ = value;
}
inline void Event::set_event_type(::quic_trace::EventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:quic_trace.Event.event_type)
}

// optional uint64 packet_number = 3;
inline bool Event::_internal_has_packet_number() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Event::has_packet_number() const {
  return _internal_has_packet_number();
}
inline void Event::clear_packet_number() {
  packet_number_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t Event::_internal_packet_number() const {
  return packet_number_;
}
inline uint64_t Event::packet_number() const {
  // @@protoc_insertion_point(field_get:quic_trace.Event.packet_number)
  return _internal_packet_number();
}
inline void Event::_internal_set_packet_number(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  packet_number_ = value;
}
inline void Event::set_packet_number(uint64_t value) {
  _internal_set_packet_number(value);
  // @@protoc_insertion_point(field_set:quic_trace.Event.packet_number)
}

// repeated .quic_trace.Frame frames = 4;
inline int Event::_internal_frames_size() const {
  return frames_.size();
}
inline int Event::frames_size() const {
  return _internal_frames_size();
}
inline void Event::clear_frames() {
  frames_.Clear();
}
inline ::quic_trace::Frame* Event::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:quic_trace.Event.frames)
  return frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::Frame >*
Event::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:quic_trace.Event.frames)
  return &frames_;
}
inline const ::quic_trace::Frame& Event::_internal_frames(int index) const {
  return frames_.Get(index);
}
inline const ::quic_trace::Frame& Event::frames(int index) const {
  // @@protoc_insertion_point(field_get:quic_trace.Event.frames)
  return _internal_frames(index);
}
inline ::quic_trace::Frame* Event::_internal_add_frames() {
  return frames_.Add();
}
inline ::quic_trace::Frame* Event::add_frames() {
  ::quic_trace::Frame* _add = _internal_add_frames();
  // @@protoc_insertion_point(field_add:quic_trace.Event.frames)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::Frame >&
Event::frames() const {
  // @@protoc_insertion_point(field_list:quic_trace.Event.frames)
  return frames_;
}

// optional uint64 packet_size = 5;
inline bool Event::_internal_has_packet_size() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Event::has_packet_size() const {
  return _internal_has_packet_size();
}
inline void Event::clear_packet_size() {
  packet_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t Event::_internal_packet_size() const {
  return packet_size_;
}
inline uint64_t Event::packet_size() const {
  // @@protoc_insertion_point(field_get:quic_trace.Event.packet_size)
  return _internal_packet_size();
}
inline void Event::_internal_set_packet_size(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  packet_size_ = value;
}
inline void Event::set_packet_size(uint64_t value) {
  _internal_set_packet_size(value);
  // @@protoc_insertion_point(field_set:quic_trace.Event.packet_size)
}

// optional .quic_trace.EncryptionLevel encryption_level = 6;
inline bool Event::_internal_has_encryption_level() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Event::has_encryption_level() const {
  return _internal_has_encryption_level();
}
inline void Event::clear_encryption_level() {
  encryption_level_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::quic_trace::EncryptionLevel Event::_internal_encryption_level() const {
  return static_cast< ::quic_trace::EncryptionLevel >(encryption_level_);
}
inline ::quic_trace::EncryptionLevel Event::encryption_level() const {
  // @@protoc_insertion_point(field_get:quic_trace.Event.encryption_level)
  return _internal_encryption_level();
}
inline void Event::_internal_set_encryption_level(::quic_trace::EncryptionLevel value) {
  assert(::quic_trace::EncryptionLevel_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  encryption_level_ = value;
}
inline void Event::set_encryption_level(::quic_trace::EncryptionLevel value) {
  _internal_set_encryption_level(value);
  // @@protoc_insertion_point(field_set:quic_trace.Event.encryption_level)
}

// optional .quic_trace.TransportState transport_state = 7;
inline bool Event::_internal_has_transport_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || transport_state_ != nullptr);
  return value;
}
inline bool Event::has_transport_state() const {
  return _internal_has_transport_state();
}
inline void Event::clear_transport_state() {
  if (transport_state_ != nullptr) transport_state_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::quic_trace::TransportState& Event::_internal_transport_state() const {
  const ::quic_trace::TransportState* p = transport_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::quic_trace::TransportState&>(
      ::quic_trace::_TransportState_default_instance_);
}
inline const ::quic_trace::TransportState& Event::transport_state() const {
  // @@protoc_insertion_point(field_get:quic_trace.Event.transport_state)
  return _internal_transport_state();
}
inline void Event::unsafe_arena_set_allocated_transport_state(
    ::quic_trace::TransportState* transport_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transport_state_);
  }
  transport_state_ = transport_state;
  if (transport_state) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:quic_trace.Event.transport_state)
}
inline ::quic_trace::TransportState* Event::release_transport_state() {
  _has_bits_[0] &= ~0x00000001u;
  ::quic_trace::TransportState* temp = transport_state_;
  transport_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::quic_trace::TransportState* Event::unsafe_arena_release_transport_state() {
  // @@protoc_insertion_point(field_release:quic_trace.Event.transport_state)
  _has_bits_[0] &= ~0x00000001u;
  ::quic_trace::TransportState* temp = transport_state_;
  transport_state_ = nullptr;
  return temp;
}
inline ::quic_trace::TransportState* Event::_internal_mutable_transport_state() {
  _has_bits_[0] |= 0x00000001u;
  if (transport_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::quic_trace::TransportState>(GetArenaForAllocation());
    transport_state_ = p;
  }
  return transport_state_;
}
inline ::quic_trace::TransportState* Event::mutable_transport_state() {
  ::quic_trace::TransportState* _msg = _internal_mutable_transport_state();
  // @@protoc_insertion_point(field_mutable:quic_trace.Event.transport_state)
  return _msg;
}
inline void Event::set_allocated_transport_state(::quic_trace::TransportState* transport_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transport_state_;
  }
  if (transport_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transport_state);
    if (message_arena != submessage_arena) {
      transport_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transport_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  transport_state_ = transport_state;
  // @@protoc_insertion_point(field_set_allocated:quic_trace.Event.transport_state)
}

// optional .quic_trace.ExternalNetworkParameters external_network_parameters = 8;
inline bool Event::_internal_has_external_network_parameters() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || external_network_parameters_ != nullptr);
  return value;
}
inline bool Event::has_external_network_parameters() const {
  return _internal_has_external_network_parameters();
}
inline void Event::clear_external_network_parameters() {
  if (external_network_parameters_ != nullptr) external_network_parameters_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::quic_trace::ExternalNetworkParameters& Event::_internal_external_network_parameters() const {
  const ::quic_trace::ExternalNetworkParameters* p = external_network_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::quic_trace::ExternalNetworkParameters&>(
      ::quic_trace::_ExternalNetworkParameters_default_instance_);
}
inline const ::quic_trace::ExternalNetworkParameters& Event::external_network_parameters() const {
  // @@protoc_insertion_point(field_get:quic_trace.Event.external_network_parameters)
  return _internal_external_network_parameters();
}
inline void Event::unsafe_arena_set_allocated_external_network_parameters(
    ::quic_trace::ExternalNetworkParameters* external_network_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(external_network_parameters_);
  }
  external_network_parameters_ = external_network_parameters;
  if (external_network_parameters) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:quic_trace.Event.external_network_parameters)
}
inline ::quic_trace::ExternalNetworkParameters* Event::release_external_network_parameters() {
  _has_bits_[0] &= ~0x00000002u;
  ::quic_trace::ExternalNetworkParameters* temp = external_network_parameters_;
  external_network_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::quic_trace::ExternalNetworkParameters* Event::unsafe_arena_release_external_network_parameters() {
  // @@protoc_insertion_point(field_release:quic_trace.Event.external_network_parameters)
  _has_bits_[0] &= ~0x00000002u;
  ::quic_trace::ExternalNetworkParameters* temp = external_network_parameters_;
  external_network_parameters_ = nullptr;
  return temp;
}
inline ::quic_trace::ExternalNetworkParameters* Event::_internal_mutable_external_network_parameters() {
  _has_bits_[0] |= 0x00000002u;
  if (external_network_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::quic_trace::ExternalNetworkParameters>(GetArenaForAllocation());
    external_network_parameters_ = p;
  }
  return external_network_parameters_;
}
inline ::quic_trace::ExternalNetworkParameters* Event::mutable_external_network_parameters() {
  ::quic_trace::ExternalNetworkParameters* _msg = _internal_mutable_external_network_parameters();
  // @@protoc_insertion_point(field_mutable:quic_trace.Event.external_network_parameters)
  return _msg;
}
inline void Event::set_allocated_external_network_parameters(::quic_trace::ExternalNetworkParameters* external_network_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete external_network_parameters_;
  }
  if (external_network_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_network_parameters);
    if (message_arena != submessage_arena) {
      external_network_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_network_parameters, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  external_network_parameters_ = external_network_parameters;
  // @@protoc_insertion_point(field_set_allocated:quic_trace.Event.external_network_parameters)
}

// optional .quic_trace.TransmissionReason transmission_reason = 9 [default = NORMAL_TRANSMISSION];
inline bool Event::_internal_has_transmission_reason() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Event::has_transmission_reason() const {
  return _internal_has_transmission_reason();
}
inline void Event::clear_transmission_reason() {
  transmission_reason_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::quic_trace::TransmissionReason Event::_internal_transmission_reason() const {
  return static_cast< ::quic_trace::TransmissionReason >(transmission_reason_);
}
inline ::quic_trace::TransmissionReason Event::transmission_reason() const {
  // @@protoc_insertion_point(field_get:quic_trace.Event.transmission_reason)
  return _internal_transmission_reason();
}
inline void Event::_internal_set_transmission_reason(::quic_trace::TransmissionReason value) {
  assert(::quic_trace::TransmissionReason_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  transmission_reason_ = value;
}
inline void Event::set_transmission_reason(::quic_trace::TransmissionReason value) {
  _internal_set_transmission_reason(value);
  // @@protoc_insertion_point(field_set:quic_trace.Event.transmission_reason)
}

// -------------------------------------------------------------------

// Trace

// optional bytes protocol_version = 1;
inline bool Trace::_internal_has_protocol_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Trace::has_protocol_version() const {
  return _internal_has_protocol_version();
}
inline void Trace::clear_protocol_version() {
  protocol_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Trace::protocol_version() const {
  // @@protoc_insertion_point(field_get:quic_trace.Trace.protocol_version)
  return _internal_protocol_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trace::set_protocol_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 protocol_version_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:quic_trace.Trace.protocol_version)
}
inline std::string* Trace::mutable_protocol_version() {
  std::string* _s = _internal_mutable_protocol_version();
  // @@protoc_insertion_point(field_mutable:quic_trace.Trace.protocol_version)
  return _s;
}
inline const std::string& Trace::_internal_protocol_version() const {
  return protocol_version_.Get();
}
inline void Trace::_internal_set_protocol_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  protocol_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Trace::_internal_mutable_protocol_version() {
  _has_bits_[0] |= 0x00000001u;
  return protocol_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Trace::release_protocol_version() {
  // @@protoc_insertion_point(field_release:quic_trace.Trace.protocol_version)
  if (!_internal_has_protocol_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = protocol_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protocol_version_.IsDefault()) {
    protocol_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Trace::set_allocated_protocol_version(std::string* protocol_version) {
  if (protocol_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  protocol_version_.SetAllocated(protocol_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protocol_version_.IsDefault()) {
    protocol_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:quic_trace.Trace.protocol_version)
}

// optional bytes source_connection_id = 2;
inline bool Trace::_internal_has_source_connection_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Trace::has_source_connection_id() const {
  return _internal_has_source_connection_id();
}
inline void Trace::clear_source_connection_id() {
  source_connection_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Trace::source_connection_id() const {
  // @@protoc_insertion_point(field_get:quic_trace.Trace.source_connection_id)
  return _internal_source_connection_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trace::set_source_connection_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 source_connection_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:quic_trace.Trace.source_connection_id)
}
inline std::string* Trace::mutable_source_connection_id() {
  std::string* _s = _internal_mutable_source_connection_id();
  // @@protoc_insertion_point(field_mutable:quic_trace.Trace.source_connection_id)
  return _s;
}
inline const std::string& Trace::_internal_source_connection_id() const {
  return source_connection_id_.Get();
}
inline void Trace::_internal_set_source_connection_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  source_connection_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Trace::_internal_mutable_source_connection_id() {
  _has_bits_[0] |= 0x00000002u;
  return source_connection_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Trace::release_source_connection_id() {
  // @@protoc_insertion_point(field_release:quic_trace.Trace.source_connection_id)
  if (!_internal_has_source_connection_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = source_connection_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_connection_id_.IsDefault()) {
    source_connection_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Trace::set_allocated_source_connection_id(std::string* source_connection_id) {
  if (source_connection_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  source_connection_id_.SetAllocated(source_connection_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_connection_id_.IsDefault()) {
    source_connection_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:quic_trace.Trace.source_connection_id)
}

// optional bytes destination_connection_id = 3;
inline bool Trace::_internal_has_destination_connection_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Trace::has_destination_connection_id() const {
  return _internal_has_destination_connection_id();
}
inline void Trace::clear_destination_connection_id() {
  destination_connection_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Trace::destination_connection_id() const {
  // @@protoc_insertion_point(field_get:quic_trace.Trace.destination_connection_id)
  return _internal_destination_connection_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trace::set_destination_connection_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 destination_connection_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:quic_trace.Trace.destination_connection_id)
}
inline std::string* Trace::mutable_destination_connection_id() {
  std::string* _s = _internal_mutable_destination_connection_id();
  // @@protoc_insertion_point(field_mutable:quic_trace.Trace.destination_connection_id)
  return _s;
}
inline const std::string& Trace::_internal_destination_connection_id() const {
  return destination_connection_id_.Get();
}
inline void Trace::_internal_set_destination_connection_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  destination_connection_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Trace::_internal_mutable_destination_connection_id() {
  _has_bits_[0] |= 0x00000004u;
  return destination_connection_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Trace::release_destination_connection_id() {
  // @@protoc_insertion_point(field_release:quic_trace.Trace.destination_connection_id)
  if (!_internal_has_destination_connection_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = destination_connection_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_connection_id_.IsDefault()) {
    destination_connection_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Trace::set_allocated_destination_connection_id(std::string* destination_connection_id) {
  if (destination_connection_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  destination_connection_id_.SetAllocated(destination_connection_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_connection_id_.IsDefault()) {
    destination_connection_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:quic_trace.Trace.destination_connection_id)
}

// repeated .quic_trace.Event events = 4;
inline int Trace::_internal_events_size() const {
  return events_.size();
}
inline int Trace::events_size() const {
  return _internal_events_size();
}
inline void Trace::clear_events() {
  events_.Clear();
}
inline ::quic_trace::Event* Trace::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:quic_trace.Trace.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::Event >*
Trace::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:quic_trace.Trace.events)
  return &events_;
}
inline const ::quic_trace::Event& Trace::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::quic_trace::Event& Trace::events(int index) const {
  // @@protoc_insertion_point(field_get:quic_trace.Trace.events)
  return _internal_events(index);
}
inline ::quic_trace::Event* Trace::_internal_add_events() {
  return events_.Add();
}
inline ::quic_trace::Event* Trace::add_events() {
  ::quic_trace::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:quic_trace.Trace.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::quic_trace::Event >&
Trace::events() const {
  // @@protoc_insertion_point(field_list:quic_trace.Trace.events)
  return events_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace quic_trace

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::quic_trace::FrameType> : ::std::true_type {};
template <> struct is_proto_enum< ::quic_trace::CloseType> : ::std::true_type {};
template <> struct is_proto_enum< ::quic_trace::EncryptionLevel> : ::std::true_type {};
template <> struct is_proto_enum< ::quic_trace::EventType> : ::std::true_type {};
template <> struct is_proto_enum< ::quic_trace::TransmissionReason> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_quic_5ftrace_2eproto
