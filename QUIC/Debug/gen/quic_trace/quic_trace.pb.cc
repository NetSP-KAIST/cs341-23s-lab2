// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: quic_trace.proto

#include "quic_trace.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace quic_trace {
PROTOBUF_CONSTEXPR StreamFrameInfo::StreamFrameInfo(
    ::_pbi::ConstantInitialized)
  : stream_id_(uint64_t{0u})
  , length_(uint64_t{0u})
  , offset_(uint64_t{0u})
  , fin_(false){}
struct StreamFrameInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamFrameInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamFrameInfoDefaultTypeInternal() {}
  union {
    StreamFrameInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamFrameInfoDefaultTypeInternal _StreamFrameInfo_default_instance_;
PROTOBUF_CONSTEXPR CryptoFrameInfo::CryptoFrameInfo(
    ::_pbi::ConstantInitialized)
  : length_(uint64_t{0u})
  , offset_(uint64_t{0u}){}
struct CryptoFrameInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CryptoFrameInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CryptoFrameInfoDefaultTypeInternal() {}
  union {
    CryptoFrameInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CryptoFrameInfoDefaultTypeInternal _CryptoFrameInfo_default_instance_;
PROTOBUF_CONSTEXPR AckBlock::AckBlock(
    ::_pbi::ConstantInitialized)
  : first_packet_(uint64_t{0u})
  , last_packet_(uint64_t{0u}){}
struct AckBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AckBlockDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AckBlockDefaultTypeInternal() {}
  union {
    AckBlock _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AckBlockDefaultTypeInternal _AckBlock_default_instance_;
PROTOBUF_CONSTEXPR AckInfo::AckInfo(
    ::_pbi::ConstantInitialized)
  : acked_packets_()
  , ack_delay_us_(uint64_t{0u}){}
struct AckInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AckInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AckInfoDefaultTypeInternal() {}
  union {
    AckInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AckInfoDefaultTypeInternal _AckInfo_default_instance_;
PROTOBUF_CONSTEXPR ResetStreamInfo::ResetStreamInfo(
    ::_pbi::ConstantInitialized)
  : stream_id_(uint64_t{0u})
  , final_offset_(uint64_t{0u})
  , application_error_code_(0u){}
struct ResetStreamInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResetStreamInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResetStreamInfoDefaultTypeInternal() {}
  union {
    ResetStreamInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResetStreamInfoDefaultTypeInternal _ResetStreamInfo_default_instance_;
PROTOBUF_CONSTEXPR CloseInfo::CloseInfo(
    ::_pbi::ConstantInitialized)
  : reason_phrase_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , error_code_(0u)
  , close_type_(0)

  , transport_close_frame_type_(uint64_t{0u}){}
struct CloseInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CloseInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CloseInfoDefaultTypeInternal() {}
  union {
    CloseInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CloseInfoDefaultTypeInternal _CloseInfo_default_instance_;
PROTOBUF_CONSTEXPR FlowControlInfo::FlowControlInfo(
    ::_pbi::ConstantInitialized)
  : max_data_(uint64_t{0u})
  , stream_id_(uint64_t{0u}){}
struct FlowControlInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowControlInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowControlInfoDefaultTypeInternal() {}
  union {
    FlowControlInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowControlInfoDefaultTypeInternal _FlowControlInfo_default_instance_;
PROTOBUF_CONSTEXPR Frame::Frame(
    ::_pbi::ConstantInitialized)
  : stream_frame_info_(nullptr)
  , ack_info_(nullptr)
  , reset_stream_info_(nullptr)
  , close_info_(nullptr)
  , flow_control_info_(nullptr)
  , crypto_frame_info_(nullptr)
  , frame_type_(0)
{}
struct FrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameDefaultTypeInternal() {}
  union {
    Frame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameDefaultTypeInternal _Frame_default_instance_;
PROTOBUF_CONSTEXPR TransportState::TransportState(
    ::_pbi::ConstantInitialized)
  : congestion_control_state_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , min_rtt_us_(uint64_t{0u})
  , smoothed_rtt_us_(uint64_t{0u})
  , last_rtt_us_(uint64_t{0u})
  , in_flight_bytes_(uint64_t{0u})
  , cwnd_bytes_(uint64_t{0u})
  , pacing_rate_bps_(uint64_t{0u}){}
struct TransportStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransportStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransportStateDefaultTypeInternal() {}
  union {
    TransportState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransportStateDefaultTypeInternal _TransportState_default_instance_;
PROTOBUF_CONSTEXPR ExternalNetworkParameters::ExternalNetworkParameters(
    ::_pbi::ConstantInitialized)
  : bandwidth_bps_(uint64_t{0u})
  , rtt_us_(uint64_t{0u})
  , cwnd_bytes_(uint64_t{0u}){}
struct ExternalNetworkParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExternalNetworkParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExternalNetworkParametersDefaultTypeInternal() {}
  union {
    ExternalNetworkParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExternalNetworkParametersDefaultTypeInternal _ExternalNetworkParameters_default_instance_;
PROTOBUF_CONSTEXPR Event::Event(
    ::_pbi::ConstantInitialized)
  : frames_()
  , transport_state_(nullptr)
  , external_network_parameters_(nullptr)
  , time_us_(uint64_t{0u})
  , packet_number_(uint64_t{0u})
  , event_type_(0)

  , encryption_level_(0)

  , packet_size_(uint64_t{0u})
  , transmission_reason_(0)
{}
struct EventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventDefaultTypeInternal() {}
  union {
    Event _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventDefaultTypeInternal _Event_default_instance_;
PROTOBUF_CONSTEXPR Trace::Trace(
    ::_pbi::ConstantInitialized)
  : events_()
  , protocol_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , source_connection_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , destination_connection_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct TraceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TraceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TraceDefaultTypeInternal() {}
  union {
    Trace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TraceDefaultTypeInternal _Trace_default_instance_;
}  // namespace quic_trace
namespace quic_trace {
bool FrameType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FrameType_strings[12] = {};

static const char FrameType_names[] =
  "ACK"
  "BLOCKED"
  "CONNECTION_CLOSE"
  "CRYPTO"
  "MAX_DATA"
  "MAX_STREAM_DATA"
  "PADDING"
  "PING"
  "RESET_STREAM"
  "STREAM"
  "STREAM_BLOCKED"
  "UNKNOWN_FRAME";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FrameType_entries[] = {
  { {FrameType_names + 0, 3}, 2 },
  { {FrameType_names + 3, 7}, 8 },
  { {FrameType_names + 10, 16}, 4 },
  { {FrameType_names + 26, 6}, 11 },
  { {FrameType_names + 32, 8}, 5 },
  { {FrameType_names + 40, 15}, 6 },
  { {FrameType_names + 55, 7}, 10 },
  { {FrameType_names + 62, 4}, 7 },
  { {FrameType_names + 66, 12}, 3 },
  { {FrameType_names + 78, 6}, 1 },
  { {FrameType_names + 84, 14}, 9 },
  { {FrameType_names + 98, 13}, 0 },
};

static const int FrameType_entries_by_number[] = {
  11, // 0 -> UNKNOWN_FRAME
  9, // 1 -> STREAM
  0, // 2 -> ACK
  8, // 3 -> RESET_STREAM
  2, // 4 -> CONNECTION_CLOSE
  4, // 5 -> MAX_DATA
  5, // 6 -> MAX_STREAM_DATA
  7, // 7 -> PING
  1, // 8 -> BLOCKED
  10, // 9 -> STREAM_BLOCKED
  6, // 10 -> PADDING
  3, // 11 -> CRYPTO
};

const std::string& FrameType_Name(
    FrameType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FrameType_entries,
          FrameType_entries_by_number,
          12, FrameType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FrameType_entries,
      FrameType_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FrameType_strings[idx].get();
}
bool FrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FrameType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FrameType_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<FrameType>(int_value);
  }
  return success;
}
bool CloseType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CloseType_strings[3] = {};

static const char CloseType_names[] =
  "GOOGLE_QUIC_CONNECTION_CLOSE"
  "IETF_QUIC_APPLICATION_CONNECTION_CLOSE"
  "IETF_QUIC_TRANSPORT_CONNECTION_CLOSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CloseType_entries[] = {
  { {CloseType_names + 0, 28}, 0 },
  { {CloseType_names + 28, 38}, 2 },
  { {CloseType_names + 66, 36}, 1 },
};

static const int CloseType_entries_by_number[] = {
  0, // 0 -> GOOGLE_QUIC_CONNECTION_CLOSE
  2, // 1 -> IETF_QUIC_TRANSPORT_CONNECTION_CLOSE
  1, // 2 -> IETF_QUIC_APPLICATION_CONNECTION_CLOSE
};

const std::string& CloseType_Name(
    CloseType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CloseType_entries,
          CloseType_entries_by_number,
          3, CloseType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CloseType_entries,
      CloseType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CloseType_strings[idx].get();
}
bool CloseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CloseType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CloseType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CloseType>(int_value);
  }
  return success;
}
bool EncryptionLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EncryptionLevel_strings[5] = {};

static const char EncryptionLevel_names[] =
  "ENCRYPTION_0RTT"
  "ENCRYPTION_1RTT"
  "ENCRYPTION_HANDSHAKE"
  "ENCRYPTION_INITIAL"
  "ENCRYPTION_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EncryptionLevel_entries[] = {
  { {EncryptionLevel_names + 0, 15}, 2 },
  { {EncryptionLevel_names + 15, 15}, 3 },
  { {EncryptionLevel_names + 30, 20}, 4 },
  { {EncryptionLevel_names + 50, 18}, 1 },
  { {EncryptionLevel_names + 68, 18}, 0 },
};

static const int EncryptionLevel_entries_by_number[] = {
  4, // 0 -> ENCRYPTION_UNKNOWN
  3, // 1 -> ENCRYPTION_INITIAL
  0, // 2 -> ENCRYPTION_0RTT
  1, // 3 -> ENCRYPTION_1RTT
  2, // 4 -> ENCRYPTION_HANDSHAKE
};

const std::string& EncryptionLevel_Name(
    EncryptionLevel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EncryptionLevel_entries,
          EncryptionLevel_entries_by_number,
          5, EncryptionLevel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EncryptionLevel_entries,
      EncryptionLevel_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EncryptionLevel_strings[idx].get();
}
bool EncryptionLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncryptionLevel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EncryptionLevel_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<EncryptionLevel>(int_value);
  }
  return success;
}
bool EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EventType_strings[6] = {};

static const char EventType_names[] =
  "APPLICATION_LIMITED"
  "EXTERNAL_PARAMETERS"
  "PACKET_LOST"
  "PACKET_RECEIVED"
  "PACKET_SENT"
  "UNKNOWN_EVENT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EventType_entries[] = {
  { {EventType_names + 0, 19}, 4 },
  { {EventType_names + 19, 19}, 5 },
  { {EventType_names + 38, 11}, 3 },
  { {EventType_names + 49, 15}, 2 },
  { {EventType_names + 64, 11}, 1 },
  { {EventType_names + 75, 13}, 0 },
};

static const int EventType_entries_by_number[] = {
  5, // 0 -> UNKNOWN_EVENT
  4, // 1 -> PACKET_SENT
  3, // 2 -> PACKET_RECEIVED
  2, // 3 -> PACKET_LOST
  0, // 4 -> APPLICATION_LIMITED
  1, // 5 -> EXTERNAL_PARAMETERS
};

const std::string& EventType_Name(
    EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EventType_entries,
          EventType_entries_by_number,
          6, EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EventType_entries,
      EventType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EventType_strings[idx].get();
}
bool EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EventType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<EventType>(int_value);
  }
  return success;
}
bool TransmissionReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TransmissionReason_strings[4] = {};

static const char TransmissionReason_names[] =
  "NORMAL_TRANSMISSION"
  "PROBING_TRANSMISSION"
  "RTO_TRANSMISSION"
  "TAIL_LOSS_PROBE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TransmissionReason_entries[] = {
  { {TransmissionReason_names + 0, 19}, 0 },
  { {TransmissionReason_names + 19, 20}, 3 },
  { {TransmissionReason_names + 39, 16}, 2 },
  { {TransmissionReason_names + 55, 15}, 1 },
};

static const int TransmissionReason_entries_by_number[] = {
  0, // 0 -> NORMAL_TRANSMISSION
  3, // 1 -> TAIL_LOSS_PROBE
  2, // 2 -> RTO_TRANSMISSION
  1, // 3 -> PROBING_TRANSMISSION
};

const std::string& TransmissionReason_Name(
    TransmissionReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TransmissionReason_entries,
          TransmissionReason_entries_by_number,
          4, TransmissionReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TransmissionReason_entries,
      TransmissionReason_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TransmissionReason_strings[idx].get();
}
bool TransmissionReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransmissionReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TransmissionReason_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TransmissionReason>(int_value);
  }
  return success;
}

// ===================================================================

class StreamFrameInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamFrameInfo>()._has_bits_);
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fin(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

StreamFrameInfo::StreamFrameInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.StreamFrameInfo)
}
StreamFrameInfo::StreamFrameInfo(const StreamFrameInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&stream_id_, &from.stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&fin_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(fin_));
  // @@protoc_insertion_point(copy_constructor:quic_trace.StreamFrameInfo)
}

inline void StreamFrameInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&stream_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fin_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(fin_));
}

StreamFrameInfo::~StreamFrameInfo() {
  // @@protoc_insertion_point(destructor:quic_trace.StreamFrameInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamFrameInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StreamFrameInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StreamFrameInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.StreamFrameInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fin_) -
        reinterpret_cast<char*>(&stream_id_)) + sizeof(fin_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StreamFrameInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 stream_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool fin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_fin(&has_bits);
          fin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamFrameInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.StreamFrameInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 stream_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_stream_id(), target);
  }

  // optional bool fin = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_fin(), target);
  }

  // optional uint64 length = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_length(), target);
  }

  // optional uint64 offset = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.StreamFrameInfo)
  return target;
}

size_t StreamFrameInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.StreamFrameInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 stream_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_stream_id());
    }

    // optional uint64 length = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_length());
    }

    // optional uint64 offset = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_offset());
    }

    // optional bool fin = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StreamFrameInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StreamFrameInfo*>(
      &from));
}

void StreamFrameInfo::MergeFrom(const StreamFrameInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.StreamFrameInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      stream_id_ = from.stream_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      length_ = from.length_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      fin_ = from.fin_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreamFrameInfo::CopyFrom(const StreamFrameInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.StreamFrameInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamFrameInfo::IsInitialized() const {
  return true;
}

void StreamFrameInfo::InternalSwap(StreamFrameInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamFrameInfo, fin_)
      + sizeof(StreamFrameInfo::fin_)
      - PROTOBUF_FIELD_OFFSET(StreamFrameInfo, stream_id_)>(
          reinterpret_cast<char*>(&stream_id_),
          reinterpret_cast<char*>(&other->stream_id_));
}

std::string StreamFrameInfo::GetTypeName() const {
  return "quic_trace.StreamFrameInfo";
}


// ===================================================================

class CryptoFrameInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CryptoFrameInfo>()._has_bits_);
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CryptoFrameInfo::CryptoFrameInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.CryptoFrameInfo)
}
CryptoFrameInfo::CryptoFrameInfo(const CryptoFrameInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&length_, &from.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&length_)) + sizeof(offset_));
  // @@protoc_insertion_point(copy_constructor:quic_trace.CryptoFrameInfo)
}

inline void CryptoFrameInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&length_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&length_)) + sizeof(offset_));
}

CryptoFrameInfo::~CryptoFrameInfo() {
  // @@protoc_insertion_point(destructor:quic_trace.CryptoFrameInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CryptoFrameInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CryptoFrameInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CryptoFrameInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.CryptoFrameInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&offset_) -
        reinterpret_cast<char*>(&length_)) + sizeof(offset_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CryptoFrameInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 length = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CryptoFrameInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.CryptoFrameInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 length = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_length(), target);
  }

  // optional uint64 offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.CryptoFrameInfo)
  return target;
}

size_t CryptoFrameInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.CryptoFrameInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 length = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_length());
    }

    // optional uint64 offset = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_offset());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CryptoFrameInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CryptoFrameInfo*>(
      &from));
}

void CryptoFrameInfo::MergeFrom(const CryptoFrameInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.CryptoFrameInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      length_ = from.length_;
    }
    if (cached_has_bits & 0x00000002u) {
      offset_ = from.offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CryptoFrameInfo::CopyFrom(const CryptoFrameInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.CryptoFrameInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CryptoFrameInfo::IsInitialized() const {
  return true;
}

void CryptoFrameInfo::InternalSwap(CryptoFrameInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CryptoFrameInfo, offset_)
      + sizeof(CryptoFrameInfo::offset_)
      - PROTOBUF_FIELD_OFFSET(CryptoFrameInfo, length_)>(
          reinterpret_cast<char*>(&length_),
          reinterpret_cast<char*>(&other->length_));
}

std::string CryptoFrameInfo::GetTypeName() const {
  return "quic_trace.CryptoFrameInfo";
}


// ===================================================================

class AckBlock::_Internal {
 public:
  using HasBits = decltype(std::declval<AckBlock>()._has_bits_);
  static void set_has_first_packet(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_packet(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AckBlock::AckBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.AckBlock)
}
AckBlock::AckBlock(const AckBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&first_packet_, &from.first_packet_,
    static_cast<size_t>(reinterpret_cast<char*>(&last_packet_) -
    reinterpret_cast<char*>(&first_packet_)) + sizeof(last_packet_));
  // @@protoc_insertion_point(copy_constructor:quic_trace.AckBlock)
}

inline void AckBlock::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&first_packet_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&last_packet_) -
    reinterpret_cast<char*>(&first_packet_)) + sizeof(last_packet_));
}

AckBlock::~AckBlock() {
  // @@protoc_insertion_point(destructor:quic_trace.AckBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AckBlock::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AckBlock::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AckBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.AckBlock)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&first_packet_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&last_packet_) -
        reinterpret_cast<char*>(&first_packet_)) + sizeof(last_packet_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AckBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 first_packet = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_first_packet(&has_bits);
          first_packet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 last_packet = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_last_packet(&has_bits);
          last_packet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AckBlock::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.AckBlock)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 first_packet = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_first_packet(), target);
  }

  // optional uint64 last_packet = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_last_packet(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.AckBlock)
  return target;
}

size_t AckBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.AckBlock)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 first_packet = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_first_packet());
    }

    // optional uint64 last_packet = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_last_packet());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AckBlock::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AckBlock*>(
      &from));
}

void AckBlock::MergeFrom(const AckBlock& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.AckBlock)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      first_packet_ = from.first_packet_;
    }
    if (cached_has_bits & 0x00000002u) {
      last_packet_ = from.last_packet_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AckBlock::CopyFrom(const AckBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.AckBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckBlock::IsInitialized() const {
  return true;
}

void AckBlock::InternalSwap(AckBlock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AckBlock, last_packet_)
      + sizeof(AckBlock::last_packet_)
      - PROTOBUF_FIELD_OFFSET(AckBlock, first_packet_)>(
          reinterpret_cast<char*>(&first_packet_),
          reinterpret_cast<char*>(&other->first_packet_));
}

std::string AckBlock::GetTypeName() const {
  return "quic_trace.AckBlock";
}


// ===================================================================

class AckInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AckInfo>()._has_bits_);
  static void set_has_ack_delay_us(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AckInfo::AckInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  acked_packets_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.AckInfo)
}
AckInfo::AckInfo(const AckInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      acked_packets_(from.acked_packets_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ack_delay_us_ = from.ack_delay_us_;
  // @@protoc_insertion_point(copy_constructor:quic_trace.AckInfo)
}

inline void AckInfo::SharedCtor() {
ack_delay_us_ = uint64_t{0u};
}

AckInfo::~AckInfo() {
  // @@protoc_insertion_point(destructor:quic_trace.AckInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AckInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AckInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AckInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.AckInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  acked_packets_.Clear();
  ack_delay_us_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AckInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .quic_trace.AckBlock acked_packets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_acked_packets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ack_delay_us = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ack_delay_us(&has_bits);
          ack_delay_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AckInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.AckInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .quic_trace.AckBlock acked_packets = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_acked_packets_size()); i < n; i++) {
    const auto& repfield = this->_internal_acked_packets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint64 ack_delay_us = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ack_delay_us(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.AckInfo)
  return target;
}

size_t AckInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.AckInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .quic_trace.AckBlock acked_packets = 1;
  total_size += 1UL * this->_internal_acked_packets_size();
  for (const auto& msg : this->acked_packets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint64 ack_delay_us = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ack_delay_us());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AckInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AckInfo*>(
      &from));
}

void AckInfo::MergeFrom(const AckInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.AckInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  acked_packets_.MergeFrom(from.acked_packets_);
  if (from._internal_has_ack_delay_us()) {
    _internal_set_ack_delay_us(from._internal_ack_delay_us());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AckInfo::CopyFrom(const AckInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.AckInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckInfo::IsInitialized() const {
  return true;
}

void AckInfo::InternalSwap(AckInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  acked_packets_.InternalSwap(&other->acked_packets_);
  swap(ack_delay_us_, other->ack_delay_us_);
}

std::string AckInfo::GetTypeName() const {
  return "quic_trace.AckInfo";
}


// ===================================================================

class ResetStreamInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ResetStreamInfo>()._has_bits_);
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_application_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_final_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ResetStreamInfo::ResetStreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.ResetStreamInfo)
}
ResetStreamInfo::ResetStreamInfo(const ResetStreamInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&stream_id_, &from.stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&application_error_code_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(application_error_code_));
  // @@protoc_insertion_point(copy_constructor:quic_trace.ResetStreamInfo)
}

inline void ResetStreamInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&stream_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&application_error_code_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(application_error_code_));
}

ResetStreamInfo::~ResetStreamInfo() {
  // @@protoc_insertion_point(destructor:quic_trace.ResetStreamInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResetStreamInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResetStreamInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ResetStreamInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.ResetStreamInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&application_error_code_) -
        reinterpret_cast<char*>(&stream_id_)) + sizeof(application_error_code_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ResetStreamInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 stream_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 application_error_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_application_error_code(&has_bits);
          application_error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 final_offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_final_offset(&has_bits);
          final_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResetStreamInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.ResetStreamInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 stream_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_stream_id(), target);
  }

  // optional uint32 application_error_code = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_application_error_code(), target);
  }

  // optional uint64 final_offset = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_final_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.ResetStreamInfo)
  return target;
}

size_t ResetStreamInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.ResetStreamInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 stream_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_stream_id());
    }

    // optional uint64 final_offset = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_final_offset());
    }

    // optional uint32 application_error_code = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_application_error_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ResetStreamInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ResetStreamInfo*>(
      &from));
}

void ResetStreamInfo::MergeFrom(const ResetStreamInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.ResetStreamInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      stream_id_ = from.stream_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      final_offset_ = from.final_offset_;
    }
    if (cached_has_bits & 0x00000004u) {
      application_error_code_ = from.application_error_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ResetStreamInfo::CopyFrom(const ResetStreamInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.ResetStreamInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetStreamInfo::IsInitialized() const {
  return true;
}

void ResetStreamInfo::InternalSwap(ResetStreamInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResetStreamInfo, application_error_code_)
      + sizeof(ResetStreamInfo::application_error_code_)
      - PROTOBUF_FIELD_OFFSET(ResetStreamInfo, stream_id_)>(
          reinterpret_cast<char*>(&stream_id_),
          reinterpret_cast<char*>(&other->stream_id_));
}

std::string ResetStreamInfo::GetTypeName() const {
  return "quic_trace.ResetStreamInfo";
}


// ===================================================================

class CloseInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CloseInfo>()._has_bits_);
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reason_phrase(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_close_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_transport_close_frame_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CloseInfo::CloseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.CloseInfo)
}
CloseInfo::CloseInfo(const CloseInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  reason_phrase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    reason_phrase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason_phrase()) {
    reason_phrase_.Set(from._internal_reason_phrase(), 
      GetArenaForAllocation());
  }
  ::memcpy(&error_code_, &from.error_code_,
    static_cast<size_t>(reinterpret_cast<char*>(&transport_close_frame_type_) -
    reinterpret_cast<char*>(&error_code_)) + sizeof(transport_close_frame_type_));
  // @@protoc_insertion_point(copy_constructor:quic_trace.CloseInfo)
}

inline void CloseInfo::SharedCtor() {
reason_phrase_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  reason_phrase_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&error_code_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&transport_close_frame_type_) -
    reinterpret_cast<char*>(&error_code_)) + sizeof(transport_close_frame_type_));
}

CloseInfo::~CloseInfo() {
  // @@protoc_insertion_point(destructor:quic_trace.CloseInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CloseInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  reason_phrase_.Destroy();
}

void CloseInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CloseInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.CloseInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    reason_phrase_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&error_code_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&transport_close_frame_type_) -
        reinterpret_cast<char*>(&error_code_)) + sizeof(transport_close_frame_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CloseInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_error_code(&has_bits);
          error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string reason_phrase = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_reason_phrase();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.CloseType close_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::quic_trace::CloseType_IsValid(val))) {
            _internal_set_close_type(static_cast<::quic_trace::CloseType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 transport_close_frame_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_transport_close_frame_type(&has_bits);
          transport_close_frame_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CloseInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.CloseInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 error_code = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_error_code(), target);
  }

  // optional string reason_phrase = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_reason_phrase(), target);
  }

  // optional .quic_trace.CloseType close_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_close_type(), target);
  }

  // optional uint64 transport_close_frame_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_transport_close_frame_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.CloseInfo)
  return target;
}

size_t CloseInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.CloseInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string reason_phrase = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reason_phrase());
    }

    // optional uint32 error_code = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_error_code());
    }

    // optional .quic_trace.CloseType close_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_close_type());
    }

    // optional uint64 transport_close_frame_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_transport_close_frame_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CloseInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CloseInfo*>(
      &from));
}

void CloseInfo::MergeFrom(const CloseInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.CloseInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_reason_phrase(from._internal_reason_phrase());
    }
    if (cached_has_bits & 0x00000002u) {
      error_code_ = from.error_code_;
    }
    if (cached_has_bits & 0x00000004u) {
      close_type_ = from.close_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      transport_close_frame_type_ = from.transport_close_frame_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CloseInfo::CopyFrom(const CloseInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.CloseInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseInfo::IsInitialized() const {
  return true;
}

void CloseInfo::InternalSwap(CloseInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &reason_phrase_, lhs_arena,
      &other->reason_phrase_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CloseInfo, transport_close_frame_type_)
      + sizeof(CloseInfo::transport_close_frame_type_)
      - PROTOBUF_FIELD_OFFSET(CloseInfo, error_code_)>(
          reinterpret_cast<char*>(&error_code_),
          reinterpret_cast<char*>(&other->error_code_));
}

std::string CloseInfo::GetTypeName() const {
  return "quic_trace.CloseInfo";
}


// ===================================================================

class FlowControlInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<FlowControlInfo>()._has_bits_);
  static void set_has_max_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FlowControlInfo::FlowControlInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.FlowControlInfo)
}
FlowControlInfo::FlowControlInfo(const FlowControlInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&max_data_, &from.max_data_,
    static_cast<size_t>(reinterpret_cast<char*>(&stream_id_) -
    reinterpret_cast<char*>(&max_data_)) + sizeof(stream_id_));
  // @@protoc_insertion_point(copy_constructor:quic_trace.FlowControlInfo)
}

inline void FlowControlInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&max_data_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&stream_id_) -
    reinterpret_cast<char*>(&max_data_)) + sizeof(stream_id_));
}

FlowControlInfo::~FlowControlInfo() {
  // @@protoc_insertion_point(destructor:quic_trace.FlowControlInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlowControlInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FlowControlInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FlowControlInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.FlowControlInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&max_data_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&stream_id_) -
        reinterpret_cast<char*>(&max_data_)) + sizeof(stream_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FlowControlInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 max_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_max_data(&has_bits);
          max_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 stream_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowControlInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.FlowControlInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 max_data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_max_data(), target);
  }

  // optional uint64 stream_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_stream_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.FlowControlInfo)
  return target;
}

size_t FlowControlInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.FlowControlInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 max_data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_data());
    }

    // optional uint64 stream_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_stream_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FlowControlInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FlowControlInfo*>(
      &from));
}

void FlowControlInfo::MergeFrom(const FlowControlInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.FlowControlInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      max_data_ = from.max_data_;
    }
    if (cached_has_bits & 0x00000002u) {
      stream_id_ = from.stream_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FlowControlInfo::CopyFrom(const FlowControlInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.FlowControlInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowControlInfo::IsInitialized() const {
  return true;
}

void FlowControlInfo::InternalSwap(FlowControlInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlowControlInfo, stream_id_)
      + sizeof(FlowControlInfo::stream_id_)
      - PROTOBUF_FIELD_OFFSET(FlowControlInfo, max_data_)>(
          reinterpret_cast<char*>(&max_data_),
          reinterpret_cast<char*>(&other->max_data_));
}

std::string FlowControlInfo::GetTypeName() const {
  return "quic_trace.FlowControlInfo";
}


// ===================================================================

class Frame::_Internal {
 public:
  using HasBits = decltype(std::declval<Frame>()._has_bits_);
  static void set_has_frame_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::quic_trace::StreamFrameInfo& stream_frame_info(const Frame* msg);
  static void set_has_stream_frame_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::quic_trace::AckInfo& ack_info(const Frame* msg);
  static void set_has_ack_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::quic_trace::ResetStreamInfo& reset_stream_info(const Frame* msg);
  static void set_has_reset_stream_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::quic_trace::CloseInfo& close_info(const Frame* msg);
  static void set_has_close_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::quic_trace::FlowControlInfo& flow_control_info(const Frame* msg);
  static void set_has_flow_control_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::quic_trace::CryptoFrameInfo& crypto_frame_info(const Frame* msg);
  static void set_has_crypto_frame_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::quic_trace::StreamFrameInfo&
Frame::_Internal::stream_frame_info(const Frame* msg) {
  return *msg->stream_frame_info_;
}
const ::quic_trace::AckInfo&
Frame::_Internal::ack_info(const Frame* msg) {
  return *msg->ack_info_;
}
const ::quic_trace::ResetStreamInfo&
Frame::_Internal::reset_stream_info(const Frame* msg) {
  return *msg->reset_stream_info_;
}
const ::quic_trace::CloseInfo&
Frame::_Internal::close_info(const Frame* msg) {
  return *msg->close_info_;
}
const ::quic_trace::FlowControlInfo&
Frame::_Internal::flow_control_info(const Frame* msg) {
  return *msg->flow_control_info_;
}
const ::quic_trace::CryptoFrameInfo&
Frame::_Internal::crypto_frame_info(const Frame* msg) {
  return *msg->crypto_frame_info_;
}
Frame::Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.Frame)
}
Frame::Frame(const Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_stream_frame_info()) {
    stream_frame_info_ = new ::quic_trace::StreamFrameInfo(*from.stream_frame_info_);
  } else {
    stream_frame_info_ = nullptr;
  }
  if (from._internal_has_ack_info()) {
    ack_info_ = new ::quic_trace::AckInfo(*from.ack_info_);
  } else {
    ack_info_ = nullptr;
  }
  if (from._internal_has_reset_stream_info()) {
    reset_stream_info_ = new ::quic_trace::ResetStreamInfo(*from.reset_stream_info_);
  } else {
    reset_stream_info_ = nullptr;
  }
  if (from._internal_has_close_info()) {
    close_info_ = new ::quic_trace::CloseInfo(*from.close_info_);
  } else {
    close_info_ = nullptr;
  }
  if (from._internal_has_flow_control_info()) {
    flow_control_info_ = new ::quic_trace::FlowControlInfo(*from.flow_control_info_);
  } else {
    flow_control_info_ = nullptr;
  }
  if (from._internal_has_crypto_frame_info()) {
    crypto_frame_info_ = new ::quic_trace::CryptoFrameInfo(*from.crypto_frame_info_);
  } else {
    crypto_frame_info_ = nullptr;
  }
  frame_type_ = from.frame_type_;
  // @@protoc_insertion_point(copy_constructor:quic_trace.Frame)
}

inline void Frame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&stream_frame_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frame_type_) -
    reinterpret_cast<char*>(&stream_frame_info_)) + sizeof(frame_type_));
}

Frame::~Frame() {
  // @@protoc_insertion_point(destructor:quic_trace.Frame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Frame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete stream_frame_info_;
  if (this != internal_default_instance()) delete ack_info_;
  if (this != internal_default_instance()) delete reset_stream_info_;
  if (this != internal_default_instance()) delete close_info_;
  if (this != internal_default_instance()) delete flow_control_info_;
  if (this != internal_default_instance()) delete crypto_frame_info_;
}

void Frame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.Frame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(stream_frame_info_ != nullptr);
      stream_frame_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(ack_info_ != nullptr);
      ack_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(reset_stream_info_ != nullptr);
      reset_stream_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(close_info_ != nullptr);
      close_info_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(flow_control_info_ != nullptr);
      flow_control_info_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(crypto_frame_info_ != nullptr);
      crypto_frame_info_->Clear();
    }
  }
  frame_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Frame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .quic_trace.FrameType frame_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::quic_trace::FrameType_IsValid(val))) {
            _internal_set_frame_type(static_cast<::quic_trace::FrameType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.StreamFrameInfo stream_frame_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_stream_frame_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.AckInfo ack_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ack_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.ResetStreamInfo reset_stream_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_reset_stream_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.CloseInfo close_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_close_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.FlowControlInfo flow_control_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_control_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.CryptoFrameInfo crypto_frame_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_crypto_frame_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Frame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.Frame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .quic_trace.FrameType frame_type = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_frame_type(), target);
  }

  // optional .quic_trace.StreamFrameInfo stream_frame_info = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::stream_frame_info(this),
        _Internal::stream_frame_info(this).GetCachedSize(), target, stream);
  }

  // optional .quic_trace.AckInfo ack_info = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::ack_info(this),
        _Internal::ack_info(this).GetCachedSize(), target, stream);
  }

  // optional .quic_trace.ResetStreamInfo reset_stream_info = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::reset_stream_info(this),
        _Internal::reset_stream_info(this).GetCachedSize(), target, stream);
  }

  // optional .quic_trace.CloseInfo close_info = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::close_info(this),
        _Internal::close_info(this).GetCachedSize(), target, stream);
  }

  // optional .quic_trace.FlowControlInfo flow_control_info = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::flow_control_info(this),
        _Internal::flow_control_info(this).GetCachedSize(), target, stream);
  }

  // optional .quic_trace.CryptoFrameInfo crypto_frame_info = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::crypto_frame_info(this),
        _Internal::crypto_frame_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.Frame)
  return target;
}

size_t Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.Frame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .quic_trace.StreamFrameInfo stream_frame_info = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stream_frame_info_);
    }

    // optional .quic_trace.AckInfo ack_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ack_info_);
    }

    // optional .quic_trace.ResetStreamInfo reset_stream_info = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *reset_stream_info_);
    }

    // optional .quic_trace.CloseInfo close_info = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *close_info_);
    }

    // optional .quic_trace.FlowControlInfo flow_control_info = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *flow_control_info_);
    }

    // optional .quic_trace.CryptoFrameInfo crypto_frame_info = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *crypto_frame_info_);
    }

    // optional .quic_trace.FrameType frame_type = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_frame_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Frame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Frame*>(
      &from));
}

void Frame::MergeFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.Frame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_stream_frame_info()->::quic_trace::StreamFrameInfo::MergeFrom(from._internal_stream_frame_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_ack_info()->::quic_trace::AckInfo::MergeFrom(from._internal_ack_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_reset_stream_info()->::quic_trace::ResetStreamInfo::MergeFrom(from._internal_reset_stream_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_close_info()->::quic_trace::CloseInfo::MergeFrom(from._internal_close_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_flow_control_info()->::quic_trace::FlowControlInfo::MergeFrom(from._internal_flow_control_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_crypto_frame_info()->::quic_trace::CryptoFrameInfo::MergeFrom(from._internal_crypto_frame_info());
    }
    if (cached_has_bits & 0x00000040u) {
      frame_type_ = from.frame_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Frame::CopyFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {
  return true;
}

void Frame::InternalSwap(Frame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Frame, frame_type_)
      + sizeof(Frame::frame_type_)
      - PROTOBUF_FIELD_OFFSET(Frame, stream_frame_info_)>(
          reinterpret_cast<char*>(&stream_frame_info_),
          reinterpret_cast<char*>(&other->stream_frame_info_));
}

std::string Frame::GetTypeName() const {
  return "quic_trace.Frame";
}


// ===================================================================

class TransportState::_Internal {
 public:
  using HasBits = decltype(std::declval<TransportState>()._has_bits_);
  static void set_has_min_rtt_us(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_smoothed_rtt_us(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_rtt_us(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_in_flight_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cwnd_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_pacing_rate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_congestion_control_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TransportState::TransportState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.TransportState)
}
TransportState::TransportState(const TransportState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  congestion_control_state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    congestion_control_state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_congestion_control_state()) {
    congestion_control_state_.Set(from._internal_congestion_control_state(), 
      GetArenaForAllocation());
  }
  ::memcpy(&min_rtt_us_, &from.min_rtt_us_,
    static_cast<size_t>(reinterpret_cast<char*>(&pacing_rate_bps_) -
    reinterpret_cast<char*>(&min_rtt_us_)) + sizeof(pacing_rate_bps_));
  // @@protoc_insertion_point(copy_constructor:quic_trace.TransportState)
}

inline void TransportState::SharedCtor() {
congestion_control_state_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  congestion_control_state_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&min_rtt_us_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pacing_rate_bps_) -
    reinterpret_cast<char*>(&min_rtt_us_)) + sizeof(pacing_rate_bps_));
}

TransportState::~TransportState() {
  // @@protoc_insertion_point(destructor:quic_trace.TransportState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransportState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  congestion_control_state_.Destroy();
}

void TransportState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TransportState::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.TransportState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    congestion_control_state_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&min_rtt_us_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pacing_rate_bps_) -
        reinterpret_cast<char*>(&min_rtt_us_)) + sizeof(pacing_rate_bps_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TransportState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 min_rtt_us = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_min_rtt_us(&has_bits);
          min_rtt_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 smoothed_rtt_us = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_smoothed_rtt_us(&has_bits);
          smoothed_rtt_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 last_rtt_us = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_last_rtt_us(&has_bits);
          last_rtt_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 in_flight_bytes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_in_flight_bytes(&has_bits);
          in_flight_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cwnd_bytes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_cwnd_bytes(&has_bits);
          cwnd_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pacing_rate_bps = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_pacing_rate_bps(&has_bits);
          pacing_rate_bps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string congestion_control_state = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_congestion_control_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransportState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.TransportState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 min_rtt_us = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_min_rtt_us(), target);
  }

  // optional uint64 smoothed_rtt_us = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_smoothed_rtt_us(), target);
  }

  // optional uint64 last_rtt_us = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_last_rtt_us(), target);
  }

  // optional uint64 in_flight_bytes = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_in_flight_bytes(), target);
  }

  // optional uint64 cwnd_bytes = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_cwnd_bytes(), target);
  }

  // optional uint64 pacing_rate_bps = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_pacing_rate_bps(), target);
  }

  // optional string congestion_control_state = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_congestion_control_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.TransportState)
  return target;
}

size_t TransportState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.TransportState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string congestion_control_state = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_congestion_control_state());
    }

    // optional uint64 min_rtt_us = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_min_rtt_us());
    }

    // optional uint64 smoothed_rtt_us = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_smoothed_rtt_us());
    }

    // optional uint64 last_rtt_us = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_last_rtt_us());
    }

    // optional uint64 in_flight_bytes = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_in_flight_bytes());
    }

    // optional uint64 cwnd_bytes = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cwnd_bytes());
    }

    // optional uint64 pacing_rate_bps = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pacing_rate_bps());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TransportState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TransportState*>(
      &from));
}

void TransportState::MergeFrom(const TransportState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.TransportState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_congestion_control_state(from._internal_congestion_control_state());
    }
    if (cached_has_bits & 0x00000002u) {
      min_rtt_us_ = from.min_rtt_us_;
    }
    if (cached_has_bits & 0x00000004u) {
      smoothed_rtt_us_ = from.smoothed_rtt_us_;
    }
    if (cached_has_bits & 0x00000008u) {
      last_rtt_us_ = from.last_rtt_us_;
    }
    if (cached_has_bits & 0x00000010u) {
      in_flight_bytes_ = from.in_flight_bytes_;
    }
    if (cached_has_bits & 0x00000020u) {
      cwnd_bytes_ = from.cwnd_bytes_;
    }
    if (cached_has_bits & 0x00000040u) {
      pacing_rate_bps_ = from.pacing_rate_bps_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TransportState::CopyFrom(const TransportState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.TransportState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransportState::IsInitialized() const {
  return true;
}

void TransportState::InternalSwap(TransportState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &congestion_control_state_, lhs_arena,
      &other->congestion_control_state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransportState, pacing_rate_bps_)
      + sizeof(TransportState::pacing_rate_bps_)
      - PROTOBUF_FIELD_OFFSET(TransportState, min_rtt_us_)>(
          reinterpret_cast<char*>(&min_rtt_us_),
          reinterpret_cast<char*>(&other->min_rtt_us_));
}

std::string TransportState::GetTypeName() const {
  return "quic_trace.TransportState";
}


// ===================================================================

class ExternalNetworkParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<ExternalNetworkParameters>()._has_bits_);
  static void set_has_bandwidth_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rtt_us(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cwnd_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ExternalNetworkParameters::ExternalNetworkParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.ExternalNetworkParameters)
}
ExternalNetworkParameters::ExternalNetworkParameters(const ExternalNetworkParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&bandwidth_bps_, &from.bandwidth_bps_,
    static_cast<size_t>(reinterpret_cast<char*>(&cwnd_bytes_) -
    reinterpret_cast<char*>(&bandwidth_bps_)) + sizeof(cwnd_bytes_));
  // @@protoc_insertion_point(copy_constructor:quic_trace.ExternalNetworkParameters)
}

inline void ExternalNetworkParameters::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&bandwidth_bps_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cwnd_bytes_) -
    reinterpret_cast<char*>(&bandwidth_bps_)) + sizeof(cwnd_bytes_));
}

ExternalNetworkParameters::~ExternalNetworkParameters() {
  // @@protoc_insertion_point(destructor:quic_trace.ExternalNetworkParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExternalNetworkParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ExternalNetworkParameters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExternalNetworkParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.ExternalNetworkParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&bandwidth_bps_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cwnd_bytes_) -
        reinterpret_cast<char*>(&bandwidth_bps_)) + sizeof(cwnd_bytes_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExternalNetworkParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 bandwidth_bps = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_bandwidth_bps(&has_bits);
          bandwidth_bps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 rtt_us = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rtt_us(&has_bits);
          rtt_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cwnd_bytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_cwnd_bytes(&has_bits);
          cwnd_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExternalNetworkParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.ExternalNetworkParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 bandwidth_bps = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_bandwidth_bps(), target);
  }

  // optional uint64 rtt_us = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_rtt_us(), target);
  }

  // optional uint64 cwnd_bytes = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_cwnd_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.ExternalNetworkParameters)
  return target;
}

size_t ExternalNetworkParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.ExternalNetworkParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 bandwidth_bps = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bandwidth_bps());
    }

    // optional uint64 rtt_us = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_rtt_us());
    }

    // optional uint64 cwnd_bytes = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cwnd_bytes());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExternalNetworkParameters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExternalNetworkParameters*>(
      &from));
}

void ExternalNetworkParameters::MergeFrom(const ExternalNetworkParameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.ExternalNetworkParameters)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      bandwidth_bps_ = from.bandwidth_bps_;
    }
    if (cached_has_bits & 0x00000002u) {
      rtt_us_ = from.rtt_us_;
    }
    if (cached_has_bits & 0x00000004u) {
      cwnd_bytes_ = from.cwnd_bytes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExternalNetworkParameters::CopyFrom(const ExternalNetworkParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.ExternalNetworkParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExternalNetworkParameters::IsInitialized() const {
  return true;
}

void ExternalNetworkParameters::InternalSwap(ExternalNetworkParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExternalNetworkParameters, cwnd_bytes_)
      + sizeof(ExternalNetworkParameters::cwnd_bytes_)
      - PROTOBUF_FIELD_OFFSET(ExternalNetworkParameters, bandwidth_bps_)>(
          reinterpret_cast<char*>(&bandwidth_bps_),
          reinterpret_cast<char*>(&other->bandwidth_bps_));
}

std::string ExternalNetworkParameters::GetTypeName() const {
  return "quic_trace.ExternalNetworkParameters";
}


// ===================================================================

class Event::_Internal {
 public:
  using HasBits = decltype(std::declval<Event>()._has_bits_);
  static void set_has_time_us(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_packet_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_packet_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_encryption_level(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::quic_trace::TransportState& transport_state(const Event* msg);
  static void set_has_transport_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::quic_trace::ExternalNetworkParameters& external_network_parameters(const Event* msg);
  static void set_has_external_network_parameters(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_transmission_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::quic_trace::TransportState&
Event::_Internal::transport_state(const Event* msg) {
  return *msg->transport_state_;
}
const ::quic_trace::ExternalNetworkParameters&
Event::_Internal::external_network_parameters(const Event* msg) {
  return *msg->external_network_parameters_;
}
Event::Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  frames_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.Event)
}
Event::Event(const Event& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      frames_(from.frames_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_transport_state()) {
    transport_state_ = new ::quic_trace::TransportState(*from.transport_state_);
  } else {
    transport_state_ = nullptr;
  }
  if (from._internal_has_external_network_parameters()) {
    external_network_parameters_ = new ::quic_trace::ExternalNetworkParameters(*from.external_network_parameters_);
  } else {
    external_network_parameters_ = nullptr;
  }
  ::memcpy(&time_us_, &from.time_us_,
    static_cast<size_t>(reinterpret_cast<char*>(&transmission_reason_) -
    reinterpret_cast<char*>(&time_us_)) + sizeof(transmission_reason_));
  // @@protoc_insertion_point(copy_constructor:quic_trace.Event)
}

inline void Event::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&transport_state_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&transmission_reason_) -
    reinterpret_cast<char*>(&transport_state_)) + sizeof(transmission_reason_));
}

Event::~Event() {
  // @@protoc_insertion_point(destructor:quic_trace.Event)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Event::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete transport_state_;
  if (this != internal_default_instance()) delete external_network_parameters_;
}

void Event::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Event::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.Event)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  frames_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(transport_state_ != nullptr);
      transport_state_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(external_network_parameters_ != nullptr);
      external_network_parameters_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&time_us_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&transmission_reason_) -
        reinterpret_cast<char*>(&time_us_)) + sizeof(transmission_reason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Event::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 time_us = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_time_us(&has_bits);
          time_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.EventType event_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::quic_trace::EventType_IsValid(val))) {
            _internal_set_event_type(static_cast<::quic_trace::EventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 packet_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_packet_number(&has_bits);
          packet_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .quic_trace.Frame frames = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_frames(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 packet_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_packet_size(&has_bits);
          packet_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.EncryptionLevel encryption_level = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::quic_trace::EncryptionLevel_IsValid(val))) {
            _internal_set_encryption_level(static_cast<::quic_trace::EncryptionLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.TransportState transport_state = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_transport_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.ExternalNetworkParameters external_network_parameters = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_external_network_parameters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .quic_trace.TransmissionReason transmission_reason = 9 [default = NORMAL_TRANSMISSION];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::quic_trace::TransmissionReason_IsValid(val))) {
            _internal_set_transmission_reason(static_cast<::quic_trace::TransmissionReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Event::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.Event)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 time_us = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_time_us(), target);
  }

  // optional .quic_trace.EventType event_type = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_event_type(), target);
  }

  // optional uint64 packet_number = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_packet_number(), target);
  }

  // repeated .quic_trace.Frame frames = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_frames_size()); i < n; i++) {
    const auto& repfield = this->_internal_frames(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 packet_size = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_packet_size(), target);
  }

  // optional .quic_trace.EncryptionLevel encryption_level = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_encryption_level(), target);
  }

  // optional .quic_trace.TransportState transport_state = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::transport_state(this),
        _Internal::transport_state(this).GetCachedSize(), target, stream);
  }

  // optional .quic_trace.ExternalNetworkParameters external_network_parameters = 8;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::external_network_parameters(this),
        _Internal::external_network_parameters(this).GetCachedSize(), target, stream);
  }

  // optional .quic_trace.TransmissionReason transmission_reason = 9 [default = NORMAL_TRANSMISSION];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_transmission_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.Event)
  return target;
}

size_t Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.Event)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .quic_trace.Frame frames = 4;
  total_size += 1UL * this->_internal_frames_size();
  for (const auto& msg : this->frames_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .quic_trace.TransportState transport_state = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transport_state_);
    }

    // optional .quic_trace.ExternalNetworkParameters external_network_parameters = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *external_network_parameters_);
    }

    // optional uint64 time_us = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_time_us());
    }

    // optional uint64 packet_number = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_packet_number());
    }

    // optional .quic_trace.EventType event_type = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_type());
    }

    // optional .quic_trace.EncryptionLevel encryption_level = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_encryption_level());
    }

    // optional uint64 packet_size = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_packet_size());
    }

    // optional .quic_trace.TransmissionReason transmission_reason = 9 [default = NORMAL_TRANSMISSION];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_transmission_reason());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Event::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Event*>(
      &from));
}

void Event::MergeFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.Event)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  frames_.MergeFrom(from.frames_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_transport_state()->::quic_trace::TransportState::MergeFrom(from._internal_transport_state());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_external_network_parameters()->::quic_trace::ExternalNetworkParameters::MergeFrom(from._internal_external_network_parameters());
    }
    if (cached_has_bits & 0x00000004u) {
      time_us_ = from.time_us_;
    }
    if (cached_has_bits & 0x00000008u) {
      packet_number_ = from.packet_number_;
    }
    if (cached_has_bits & 0x00000010u) {
      event_type_ = from.event_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      encryption_level_ = from.encryption_level_;
    }
    if (cached_has_bits & 0x00000040u) {
      packet_size_ = from.packet_size_;
    }
    if (cached_has_bits & 0x00000080u) {
      transmission_reason_ = from.transmission_reason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Event::CopyFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  return true;
}

void Event::InternalSwap(Event* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  frames_.InternalSwap(&other->frames_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Event, transmission_reason_)
      + sizeof(Event::transmission_reason_)
      - PROTOBUF_FIELD_OFFSET(Event, transport_state_)>(
          reinterpret_cast<char*>(&transport_state_),
          reinterpret_cast<char*>(&other->transport_state_));
}

std::string Event::GetTypeName() const {
  return "quic_trace.Event";
}


// ===================================================================

class Trace::_Internal {
 public:
  using HasBits = decltype(std::declval<Trace>()._has_bits_);
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_source_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_destination_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Trace::Trace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  events_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:quic_trace.Trace)
}
Trace::Trace(const Trace& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      events_(from.events_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  protocol_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    protocol_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_protocol_version()) {
    protocol_version_.Set(from._internal_protocol_version(), 
      GetArenaForAllocation());
  }
  source_connection_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    source_connection_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_source_connection_id()) {
    source_connection_id_.Set(from._internal_source_connection_id(), 
      GetArenaForAllocation());
  }
  destination_connection_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    destination_connection_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_destination_connection_id()) {
    destination_connection_id_.Set(from._internal_destination_connection_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:quic_trace.Trace)
}

inline void Trace::SharedCtor() {
protocol_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  protocol_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
source_connection_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  source_connection_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
destination_connection_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  destination_connection_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Trace::~Trace() {
  // @@protoc_insertion_point(destructor:quic_trace.Trace)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Trace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  protocol_version_.Destroy();
  source_connection_id_.Destroy();
  destination_connection_id_.Destroy();
}

void Trace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Trace::Clear() {
// @@protoc_insertion_point(message_clear_start:quic_trace.Trace)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  events_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      protocol_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      source_connection_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      destination_connection_id_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Trace::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes protocol_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_protocol_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes source_connection_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_source_connection_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes destination_connection_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_destination_connection_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .quic_trace.Event events = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Trace::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:quic_trace.Trace)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes protocol_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_protocol_version(), target);
  }

  // optional bytes source_connection_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_source_connection_id(), target);
  }

  // optional bytes destination_connection_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_destination_connection_id(), target);
  }

  // repeated .quic_trace.Event events = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:quic_trace.Trace)
  return target;
}

size_t Trace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:quic_trace.Trace)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .quic_trace.Event events = 4;
  total_size += 1UL * this->_internal_events_size();
  for (const auto& msg : this->events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes protocol_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_protocol_version());
    }

    // optional bytes source_connection_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_source_connection_id());
    }

    // optional bytes destination_connection_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_destination_connection_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Trace::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Trace*>(
      &from));
}

void Trace::MergeFrom(const Trace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:quic_trace.Trace)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  events_.MergeFrom(from.events_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_protocol_version(from._internal_protocol_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_source_connection_id(from._internal_source_connection_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_destination_connection_id(from._internal_destination_connection_id());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Trace::CopyFrom(const Trace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:quic_trace.Trace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trace::IsInitialized() const {
  return true;
}

void Trace::InternalSwap(Trace* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  events_.InternalSwap(&other->events_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &protocol_version_, lhs_arena,
      &other->protocol_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &source_connection_id_, lhs_arena,
      &other->source_connection_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &destination_connection_id_, lhs_arena,
      &other->destination_connection_id_, rhs_arena
  );
}

std::string Trace::GetTypeName() const {
  return "quic_trace.Trace";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace quic_trace
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::quic_trace::StreamFrameInfo*
Arena::CreateMaybeMessage< ::quic_trace::StreamFrameInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::StreamFrameInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::quic_trace::CryptoFrameInfo*
Arena::CreateMaybeMessage< ::quic_trace::CryptoFrameInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::CryptoFrameInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::quic_trace::AckBlock*
Arena::CreateMaybeMessage< ::quic_trace::AckBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::AckBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::quic_trace::AckInfo*
Arena::CreateMaybeMessage< ::quic_trace::AckInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::AckInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::quic_trace::ResetStreamInfo*
Arena::CreateMaybeMessage< ::quic_trace::ResetStreamInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::ResetStreamInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::quic_trace::CloseInfo*
Arena::CreateMaybeMessage< ::quic_trace::CloseInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::CloseInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::quic_trace::FlowControlInfo*
Arena::CreateMaybeMessage< ::quic_trace::FlowControlInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::FlowControlInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::quic_trace::Frame*
Arena::CreateMaybeMessage< ::quic_trace::Frame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::Frame >(arena);
}
template<> PROTOBUF_NOINLINE ::quic_trace::TransportState*
Arena::CreateMaybeMessage< ::quic_trace::TransportState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::TransportState >(arena);
}
template<> PROTOBUF_NOINLINE ::quic_trace::ExternalNetworkParameters*
Arena::CreateMaybeMessage< ::quic_trace::ExternalNetworkParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::ExternalNetworkParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::quic_trace::Event*
Arena::CreateMaybeMessage< ::quic_trace::Event >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::Event >(arena);
}
template<> PROTOBUF_NOINLINE ::quic_trace::Trace*
Arena::CreateMaybeMessage< ::quic_trace::Trace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::quic_trace::Trace >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
