// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_CHROME_TRACK_EVENT_PROTO_H_
#define PERFETTO_PROTOS_CHROME_TRACK_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"
#include "protos/perfetto/trace/track_event/debug_annotation.pbzero.h"
#include "protos/perfetto/trace/track_event/track_event.pbzero.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AndroidActivity;
class AndroidView;
class BlinkExecutionContext;
class BlinkHighEntropyAPI_CalledJsApi;
class BlinkHighEntropyAPI_JSFunctionArgument;
class BlinkSourceLocation;
class BrowsingContextState;
class ChromeBrowserContext;
class FrameTreeNodeInfo;
class GlobalRenderFrameHostId;
class RenderFrameHost;
class RenderProcessHost;
class SiteInstance;
class SiteInstanceGroup;
class V8StackFrame;
class V8StackFrame_ScriptLocation;
namespace perfetto_pbzero_enum_AndroidToolbar {
enum AllowCaptureReason : int32_t;
}  // namespace perfetto_pbzero_enum_AndroidToolbar
using AndroidToolbar_AllowCaptureReason = perfetto_pbzero_enum_AndroidToolbar::AllowCaptureReason;
namespace perfetto_pbzero_enum_AndroidToolbar {
enum BlockCaptureReason : int32_t;
}  // namespace perfetto_pbzero_enum_AndroidToolbar
using AndroidToolbar_BlockCaptureReason = perfetto_pbzero_enum_AndroidToolbar::BlockCaptureReason;
namespace perfetto_pbzero_enum_AndroidToolbar {
enum SnapshotDifference : int32_t;
}  // namespace perfetto_pbzero_enum_AndroidToolbar
using AndroidToolbar_SnapshotDifference = perfetto_pbzero_enum_AndroidToolbar::SnapshotDifference;
namespace perfetto_pbzero_enum_BackForwardCacheCanStoreDocumentResult {
enum BackForwardCacheNotRestoredReason : int32_t;
}  // namespace perfetto_pbzero_enum_BackForwardCacheCanStoreDocumentResult
using BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason = perfetto_pbzero_enum_BackForwardCacheCanStoreDocumentResult::BackForwardCacheNotRestoredReason;
namespace perfetto_pbzero_enum_BlinkExecutionContext {
enum ContextType : int32_t;
}  // namespace perfetto_pbzero_enum_BlinkExecutionContext
using BlinkExecutionContext_ContextType = perfetto_pbzero_enum_BlinkExecutionContext::ContextType;
namespace perfetto_pbzero_enum_BlinkHighEntropyAPI_JSFunctionArgument {
enum ArgumentType : int32_t;
}  // namespace perfetto_pbzero_enum_BlinkHighEntropyAPI_JSFunctionArgument
using BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType = perfetto_pbzero_enum_BlinkHighEntropyAPI_JSFunctionArgument::ArgumentType;
namespace perfetto_pbzero_enum_BlinkTaskScope {
enum TaskScopeType : int32_t;
}  // namespace perfetto_pbzero_enum_BlinkTaskScope
using BlinkTaskScope_TaskScopeType = perfetto_pbzero_enum_BlinkTaskScope::TaskScopeType;
namespace perfetto_pbzero_enum_ChildProcessLauncherPriority {
enum Importance : int32_t;
}  // namespace perfetto_pbzero_enum_ChildProcessLauncherPriority
using ChildProcessLauncherPriority_Importance = perfetto_pbzero_enum_ChildProcessLauncherPriority::Importance;
namespace perfetto_pbzero_enum_ChromeSamplingProfilerSampleCollected {
enum WriteStatus : int32_t;
}  // namespace perfetto_pbzero_enum_ChromeSamplingProfilerSampleCollected
using ChromeSamplingProfilerSampleCollected_WriteStatus = perfetto_pbzero_enum_ChromeSamplingProfilerSampleCollected::WriteStatus;
namespace perfetto_pbzero_enum_ChromeThreadPoolTask {
enum ExecutionMode : int32_t;
}  // namespace perfetto_pbzero_enum_ChromeThreadPoolTask
using ChromeThreadPoolTask_ExecutionMode = perfetto_pbzero_enum_ChromeThreadPoolTask::ExecutionMode;
namespace perfetto_pbzero_enum_ChromeThreadPoolTask {
enum Priority : int32_t;
}  // namespace perfetto_pbzero_enum_ChromeThreadPoolTask
using ChromeThreadPoolTask_Priority = perfetto_pbzero_enum_ChromeThreadPoolTask::Priority;
namespace perfetto_pbzero_enum_ChromeThreadPoolTask {
enum ShutdownBehavior : int32_t;
}  // namespace perfetto_pbzero_enum_ChromeThreadPoolTask
using ChromeThreadPoolTask_ShutdownBehavior = perfetto_pbzero_enum_ChromeThreadPoolTask::ShutdownBehavior;
namespace perfetto_pbzero_enum_EventLatency {
enum EventType : int32_t;
}  // namespace perfetto_pbzero_enum_EventLatency
using EventLatency_EventType = perfetto_pbzero_enum_EventLatency::EventType;
enum FrameDeleteIntention : int32_t;
namespace perfetto_pbzero_enum_FrameTreeNodeInfo {
enum FrameType : int32_t;
}  // namespace perfetto_pbzero_enum_FrameTreeNodeInfo
using FrameTreeNodeInfo_FrameType = perfetto_pbzero_enum_FrameTreeNodeInfo::FrameType;
enum MemoryPressureLevel : int32_t;
namespace perfetto_pbzero_enum_ProcessSingleton {
enum RemoteHungProcessTerminateReason : int32_t;
}  // namespace perfetto_pbzero_enum_ProcessSingleton
using ProcessSingleton_RemoteHungProcessTerminateReason = perfetto_pbzero_enum_ProcessSingleton::RemoteHungProcessTerminateReason;
namespace perfetto_pbzero_enum_ProcessSingleton {
enum RemoteProcessInteractionResult : int32_t;
}  // namespace perfetto_pbzero_enum_ProcessSingleton
using ProcessSingleton_RemoteProcessInteractionResult = perfetto_pbzero_enum_ProcessSingleton::RemoteProcessInteractionResult;
namespace perfetto_pbzero_enum_RenderFrameHost {
enum LifecycleState : int32_t;
}  // namespace perfetto_pbzero_enum_RenderFrameHost
using RenderFrameHost_LifecycleState = perfetto_pbzero_enum_RenderFrameHost::LifecycleState;
namespace perfetto_pbzero_enum_RendererMainThreadTaskExecution {
enum FrameType : int32_t;
}  // namespace perfetto_pbzero_enum_RendererMainThreadTaskExecution
using RendererMainThreadTaskExecution_FrameType = perfetto_pbzero_enum_RendererMainThreadTaskExecution::FrameType;
namespace perfetto_pbzero_enum_RendererMainThreadTaskExecution {
enum TaskType : int32_t;
}  // namespace perfetto_pbzero_enum_RendererMainThreadTaskExecution
using RendererMainThreadTaskExecution_TaskType = perfetto_pbzero_enum_RendererMainThreadTaskExecution::TaskType;
namespace perfetto_pbzero_enum_SequenceManagerTask {
enum Priority : int32_t;
}  // namespace perfetto_pbzero_enum_SequenceManagerTask
using SequenceManagerTask_Priority = perfetto_pbzero_enum_SequenceManagerTask::Priority;
namespace perfetto_pbzero_enum_SequenceManagerTask {
enum QueueName : int32_t;
}  // namespace perfetto_pbzero_enum_SequenceManagerTask
using SequenceManagerTask_QueueName = perfetto_pbzero_enum_SequenceManagerTask::QueueName;
enum ShouldSwapBrowsingInstance : int32_t;

enum ChromeAppState : int32_t {
  APP_STATE_FOREGROUND = 1,
  APP_STATE_BACKGROUND = 2,
};

constexpr ChromeAppState ChromeAppState_MIN = ChromeAppState::APP_STATE_FOREGROUND;
constexpr ChromeAppState ChromeAppState_MAX = ChromeAppState::APP_STATE_BACKGROUND;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ChromeAppState_Name(::perfetto::protos::pbzero::ChromeAppState value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ChromeAppState::APP_STATE_FOREGROUND:
    return "APP_STATE_FOREGROUND";

  case ::perfetto::protos::pbzero::ChromeAppState::APP_STATE_BACKGROUND:
    return "APP_STATE_BACKGROUND";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

enum MemoryPressureLevel : int32_t {
  MEMORY_PRESSURE_LEVEL_NONE = 0,
  MEMORY_PRESSURE_LEVEL_MODERATE = 1,
  MEMORY_PRESSURE_LEVEL_CRITICAL = 2,
};

constexpr MemoryPressureLevel MemoryPressureLevel_MIN = MemoryPressureLevel::MEMORY_PRESSURE_LEVEL_NONE;
constexpr MemoryPressureLevel MemoryPressureLevel_MAX = MemoryPressureLevel::MEMORY_PRESSURE_LEVEL_CRITICAL;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* MemoryPressureLevel_Name(::perfetto::protos::pbzero::MemoryPressureLevel value) {
  switch (value) {
  case ::perfetto::protos::pbzero::MemoryPressureLevel::MEMORY_PRESSURE_LEVEL_NONE:
    return "MEMORY_PRESSURE_LEVEL_NONE";

  case ::perfetto::protos::pbzero::MemoryPressureLevel::MEMORY_PRESSURE_LEVEL_MODERATE:
    return "MEMORY_PRESSURE_LEVEL_MODERATE";

  case ::perfetto::protos::pbzero::MemoryPressureLevel::MEMORY_PRESSURE_LEVEL_CRITICAL:
    return "MEMORY_PRESSURE_LEVEL_CRITICAL";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

enum FrameDeleteIntention : int32_t {
  FRAME_DELETE_INTENTION_NOT_MAIN_FRAME = 0,
  FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_SHUTDOWN = 1,
  FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_NAVIGATION_CANCELLED = 2,
};

constexpr FrameDeleteIntention FrameDeleteIntention_MIN = FrameDeleteIntention::FRAME_DELETE_INTENTION_NOT_MAIN_FRAME;
constexpr FrameDeleteIntention FrameDeleteIntention_MAX = FrameDeleteIntention::FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_NAVIGATION_CANCELLED;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* FrameDeleteIntention_Name(::perfetto::protos::pbzero::FrameDeleteIntention value) {
  switch (value) {
  case ::perfetto::protos::pbzero::FrameDeleteIntention::FRAME_DELETE_INTENTION_NOT_MAIN_FRAME:
    return "FRAME_DELETE_INTENTION_NOT_MAIN_FRAME";

  case ::perfetto::protos::pbzero::FrameDeleteIntention::FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_SHUTDOWN:
    return "FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_SHUTDOWN";

  case ::perfetto::protos::pbzero::FrameDeleteIntention::FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_NAVIGATION_CANCELLED:
    return "FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_NAVIGATION_CANCELLED";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

enum ShouldSwapBrowsingInstance : int32_t {
  SHOULD_SWAP_BROWSING_INSTANCE_NO = 0,
  SHOULD_SWAP_BROWSING_INSTANCE_YES_FORCE_SWAP = 1,
  SHOULD_SWAP_BROWSING_INSTANCE_YES_CROSS_SITE_PROACTIVE_SWAP = 2,
  SHOULD_SWAP_BROWSING_INSTANCE_YES_SAME_SITE_PROACTIVE_SWAP = 3,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_PROACTIVE_SWAP_DISABLED = 4,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_MAIN_FRAME = 5,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_HAS_RELATED_ACTIVE_CONTENTS = 6,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_DOES_NOT_HAVE_SITE = 7,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_SOURCE_URL_SCHEME_NOT_HTTP_OR_HTTPS = 8,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_DESTINATION_URL_SCHEME_NOT_HTTP_OR_HTTPS = 9,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_SITE_NAVIGATION = 10,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_RELOADING_ERROR_PAGE = 11,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_ALREADY_HAS_MATCHING_BROWSING_INSTANCE = 12,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_RENDERER_DEBUG_URL = 13,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_NEEDED_FOR_BACK_FORWARD_CACHE = 14,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_DOCUMENT_NAVIGATION = 15,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_URL_NAVIGATION = 16,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_WILL_REPLACE_ENTRY = 17,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_RELOAD = 18,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_GUEST = 19,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_HAS_NOT_COMMITTED_ANY_NAVIGATION = 20,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_UNLOAD_HANDLER_EXISTS_ON_SAME_SITE_NAVIGATION = 21,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_PRIMARY_MAIN_FRAME = 22,
};

constexpr ShouldSwapBrowsingInstance ShouldSwapBrowsingInstance_MIN = ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO;
constexpr ShouldSwapBrowsingInstance ShouldSwapBrowsingInstance_MAX = ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_PRIMARY_MAIN_FRAME;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ShouldSwapBrowsingInstance_Name(::perfetto::protos::pbzero::ShouldSwapBrowsingInstance value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_YES_FORCE_SWAP:
    return "SHOULD_SWAP_BROWSING_INSTANCE_YES_FORCE_SWAP";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_YES_CROSS_SITE_PROACTIVE_SWAP:
    return "SHOULD_SWAP_BROWSING_INSTANCE_YES_CROSS_SITE_PROACTIVE_SWAP";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_YES_SAME_SITE_PROACTIVE_SWAP:
    return "SHOULD_SWAP_BROWSING_INSTANCE_YES_SAME_SITE_PROACTIVE_SWAP";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_PROACTIVE_SWAP_DISABLED:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_PROACTIVE_SWAP_DISABLED";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_MAIN_FRAME:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_MAIN_FRAME";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_HAS_RELATED_ACTIVE_CONTENTS:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_HAS_RELATED_ACTIVE_CONTENTS";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_DOES_NOT_HAVE_SITE:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_DOES_NOT_HAVE_SITE";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_SOURCE_URL_SCHEME_NOT_HTTP_OR_HTTPS:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_SOURCE_URL_SCHEME_NOT_HTTP_OR_HTTPS";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_DESTINATION_URL_SCHEME_NOT_HTTP_OR_HTTPS:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_DESTINATION_URL_SCHEME_NOT_HTTP_OR_HTTPS";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_SITE_NAVIGATION:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_SITE_NAVIGATION";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_RELOADING_ERROR_PAGE:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_RELOADING_ERROR_PAGE";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_ALREADY_HAS_MATCHING_BROWSING_INSTANCE:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_ALREADY_HAS_MATCHING_BROWSING_INSTANCE";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_RENDERER_DEBUG_URL:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_RENDERER_DEBUG_URL";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_NEEDED_FOR_BACK_FORWARD_CACHE:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_NEEDED_FOR_BACK_FORWARD_CACHE";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_DOCUMENT_NAVIGATION:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_DOCUMENT_NAVIGATION";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_URL_NAVIGATION:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_URL_NAVIGATION";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_WILL_REPLACE_ENTRY:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_WILL_REPLACE_ENTRY";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_RELOAD:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_RELOAD";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_GUEST:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_GUEST";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_HAS_NOT_COMMITTED_ANY_NAVIGATION:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_HAS_NOT_COMMITTED_ANY_NAVIGATION";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_UNLOAD_HANDLER_EXISTS_ON_SAME_SITE_NAVIGATION:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_UNLOAD_HANDLER_EXISTS_ON_SAME_SITE_NAVIGATION";

  case ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance::SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_PRIMARY_MAIN_FRAME:
    return "SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_PRIMARY_MAIN_FRAME";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

enum DeviceThermalState : int32_t {
  DEVICE_THERMAL_STATE_UNKNOWN = 0,
  DEVICE_THERMAL_STATE_NOMINAL = 1,
  DEVICE_THERMAL_STATE_FAIR = 2,
  DEVICE_THERMAL_STATE_SERIOUS = 3,
  DEVICE_THERMAL_STATE_CRITICAL = 4,
};

constexpr DeviceThermalState DeviceThermalState_MIN = DeviceThermalState::DEVICE_THERMAL_STATE_UNKNOWN;
constexpr DeviceThermalState DeviceThermalState_MAX = DeviceThermalState::DEVICE_THERMAL_STATE_CRITICAL;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* DeviceThermalState_Name(::perfetto::protos::pbzero::DeviceThermalState value) {
  switch (value) {
  case ::perfetto::protos::pbzero::DeviceThermalState::DEVICE_THERMAL_STATE_UNKNOWN:
    return "DEVICE_THERMAL_STATE_UNKNOWN";

  case ::perfetto::protos::pbzero::DeviceThermalState::DEVICE_THERMAL_STATE_NOMINAL:
    return "DEVICE_THERMAL_STATE_NOMINAL";

  case ::perfetto::protos::pbzero::DeviceThermalState::DEVICE_THERMAL_STATE_FAIR:
    return "DEVICE_THERMAL_STATE_FAIR";

  case ::perfetto::protos::pbzero::DeviceThermalState::DEVICE_THERMAL_STATE_SERIOUS:
    return "DEVICE_THERMAL_STATE_SERIOUS";

  case ::perfetto::protos::pbzero::DeviceThermalState::DEVICE_THERMAL_STATE_CRITICAL:
    return "DEVICE_THERMAL_STATE_CRITICAL";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_BlinkHighEntropyAPI_JSFunctionArgument {
enum ArgumentType : int32_t {
  UNKNOWN_TYPE = 0,
  NULL_TYPE = 1,
  UNDEFINED = 2,
  BIGINT = 3,
  BOOLEAN = 4,
  FUNCTION = 5,
  NUMBER = 6,
  STRING = 7,
  SYMBOL = 8,
  OBJECT = 9,
};
} // namespace perfetto_pbzero_enum_BlinkHighEntropyAPI_JSFunctionArgument
using BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType = perfetto_pbzero_enum_BlinkHighEntropyAPI_JSFunctionArgument::ArgumentType;


constexpr BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType_MIN = BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::UNKNOWN_TYPE;
constexpr BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType_MAX = BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::OBJECT;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType_Name(::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType value) {
  switch (value) {
  case ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::UNKNOWN_TYPE:
    return "UNKNOWN_TYPE";

  case ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::NULL_TYPE:
    return "NULL_TYPE";

  case ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::UNDEFINED:
    return "UNDEFINED";

  case ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::BIGINT:
    return "BIGINT";

  case ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::BOOLEAN:
    return "BOOLEAN";

  case ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::FUNCTION:
    return "FUNCTION";

  case ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::NUMBER:
    return "NUMBER";

  case ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::STRING:
    return "STRING";

  case ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::SYMBOL:
    return "SYMBOL";

  case ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType::OBJECT:
    return "OBJECT";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_BlinkExecutionContext {
enum ContextType : int32_t {
  UNKNOWN_CONTEXT = 0,
  WINDOW = 1,
  WORKLET = 2,
  DEDICATED_WORKER = 3,
  SHARED_WORKER = 4,
  SERVICE_WORKER = 5,
};
} // namespace perfetto_pbzero_enum_BlinkExecutionContext
using BlinkExecutionContext_ContextType = perfetto_pbzero_enum_BlinkExecutionContext::ContextType;


constexpr BlinkExecutionContext_ContextType BlinkExecutionContext_ContextType_MIN = BlinkExecutionContext_ContextType::UNKNOWN_CONTEXT;
constexpr BlinkExecutionContext_ContextType BlinkExecutionContext_ContextType_MAX = BlinkExecutionContext_ContextType::SERVICE_WORKER;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* BlinkExecutionContext_ContextType_Name(::perfetto::protos::pbzero::BlinkExecutionContext_ContextType value) {
  switch (value) {
  case ::perfetto::protos::pbzero::BlinkExecutionContext_ContextType::UNKNOWN_CONTEXT:
    return "UNKNOWN_CONTEXT";

  case ::perfetto::protos::pbzero::BlinkExecutionContext_ContextType::WINDOW:
    return "WINDOW";

  case ::perfetto::protos::pbzero::BlinkExecutionContext_ContextType::WORKLET:
    return "WORKLET";

  case ::perfetto::protos::pbzero::BlinkExecutionContext_ContextType::DEDICATED_WORKER:
    return "DEDICATED_WORKER";

  case ::perfetto::protos::pbzero::BlinkExecutionContext_ContextType::SHARED_WORKER:
    return "SHARED_WORKER";

  case ::perfetto::protos::pbzero::BlinkExecutionContext_ContextType::SERVICE_WORKER:
    return "SERVICE_WORKER";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_AndroidToolbar {
enum BlockCaptureReason : int32_t {
  BLOCKED_UNKNOWN = 0,
  BLOCKED_TOOLBAR_OR_RESULT_NULL = 1,
  BLOCKED_VIEW_NOT_DIRTY = 2,
  BLOCKED_SNAPSHOT_SAME = 3,
  BLOCKED_URL_BAR_HAS_FOCUS = 4,
  BLOCKED_URL_BAR_FOCUS_IN_PROGRESS = 5,
  BLOCKED_OPTIONAL_BUTTON_ANIMATION_IN_PROGRESS = 6,
  BLOCKED_STATUS_ICON_ANIMATION_IN_PROGRESS = 7,
  BLOCKED_SCROLL_ABLATION = 8,
  BLOCKED_BROWSER_CONTROLS_LOCKED = 9,
  BLOCKED_TAB_SWITCHER_MODE = 10,
  BLOCKED_COMPOSITOR_IN_MOTION = 11,
};
} // namespace perfetto_pbzero_enum_AndroidToolbar
using AndroidToolbar_BlockCaptureReason = perfetto_pbzero_enum_AndroidToolbar::BlockCaptureReason;


constexpr AndroidToolbar_BlockCaptureReason AndroidToolbar_BlockCaptureReason_MIN = AndroidToolbar_BlockCaptureReason::BLOCKED_UNKNOWN;
constexpr AndroidToolbar_BlockCaptureReason AndroidToolbar_BlockCaptureReason_MAX = AndroidToolbar_BlockCaptureReason::BLOCKED_COMPOSITOR_IN_MOTION;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* AndroidToolbar_BlockCaptureReason_Name(::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason value) {
  switch (value) {
  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_UNKNOWN:
    return "BLOCKED_UNKNOWN";

  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_TOOLBAR_OR_RESULT_NULL:
    return "BLOCKED_TOOLBAR_OR_RESULT_NULL";

  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_VIEW_NOT_DIRTY:
    return "BLOCKED_VIEW_NOT_DIRTY";

  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_SNAPSHOT_SAME:
    return "BLOCKED_SNAPSHOT_SAME";

  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_URL_BAR_HAS_FOCUS:
    return "BLOCKED_URL_BAR_HAS_FOCUS";

  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_URL_BAR_FOCUS_IN_PROGRESS:
    return "BLOCKED_URL_BAR_FOCUS_IN_PROGRESS";

  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_OPTIONAL_BUTTON_ANIMATION_IN_PROGRESS:
    return "BLOCKED_OPTIONAL_BUTTON_ANIMATION_IN_PROGRESS";

  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_STATUS_ICON_ANIMATION_IN_PROGRESS:
    return "BLOCKED_STATUS_ICON_ANIMATION_IN_PROGRESS";

  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_SCROLL_ABLATION:
    return "BLOCKED_SCROLL_ABLATION";

  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_BROWSER_CONTROLS_LOCKED:
    return "BLOCKED_BROWSER_CONTROLS_LOCKED";

  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_TAB_SWITCHER_MODE:
    return "BLOCKED_TAB_SWITCHER_MODE";

  case ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason::BLOCKED_COMPOSITOR_IN_MOTION:
    return "BLOCKED_COMPOSITOR_IN_MOTION";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_AndroidToolbar {
enum AllowCaptureReason : int32_t {
  ALLOWED_UNKNOWN = 0,
  ALLOWED_FORCE_CAPTURE = 1,
  ALLOWED_SNAPSHOT_DIFFERENCE = 2,
};
} // namespace perfetto_pbzero_enum_AndroidToolbar
using AndroidToolbar_AllowCaptureReason = perfetto_pbzero_enum_AndroidToolbar::AllowCaptureReason;


constexpr AndroidToolbar_AllowCaptureReason AndroidToolbar_AllowCaptureReason_MIN = AndroidToolbar_AllowCaptureReason::ALLOWED_UNKNOWN;
constexpr AndroidToolbar_AllowCaptureReason AndroidToolbar_AllowCaptureReason_MAX = AndroidToolbar_AllowCaptureReason::ALLOWED_SNAPSHOT_DIFFERENCE;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* AndroidToolbar_AllowCaptureReason_Name(::perfetto::protos::pbzero::AndroidToolbar_AllowCaptureReason value) {
  switch (value) {
  case ::perfetto::protos::pbzero::AndroidToolbar_AllowCaptureReason::ALLOWED_UNKNOWN:
    return "ALLOWED_UNKNOWN";

  case ::perfetto::protos::pbzero::AndroidToolbar_AllowCaptureReason::ALLOWED_FORCE_CAPTURE:
    return "ALLOWED_FORCE_CAPTURE";

  case ::perfetto::protos::pbzero::AndroidToolbar_AllowCaptureReason::ALLOWED_SNAPSHOT_DIFFERENCE:
    return "ALLOWED_SNAPSHOT_DIFFERENCE";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_AndroidToolbar {
enum SnapshotDifference : int32_t {
  DIFF_NONE = 0,
  DIFF_NULL = 1,
  DIFF_TINT = 2,
  DIFF_TAB_COUNT = 3,
  DIFF_OPTIONAL_BUTTON_DATA = 4,
  DIFF_VISUAL_STATE = 5,
  DIFF_SECURITY_ICON = 6,
  DIFF_SHOWING_UPDATE_BADGE = 7,
  DIFF_PAINT_PREVIEW = 8,
  DIFF_PROGRESS = 9,
  DIFF_LOCATION_BAR_WIDTH = 10,
  DIFF_URL_TEXT = 11,
  DIFF_HOME_BUTTON_COLOR = 12,
  DIFF_TITLE_TEXT = 13,
  DIFF_CCT_ANIMATION = 14,
};
} // namespace perfetto_pbzero_enum_AndroidToolbar
using AndroidToolbar_SnapshotDifference = perfetto_pbzero_enum_AndroidToolbar::SnapshotDifference;


constexpr AndroidToolbar_SnapshotDifference AndroidToolbar_SnapshotDifference_MIN = AndroidToolbar_SnapshotDifference::DIFF_NONE;
constexpr AndroidToolbar_SnapshotDifference AndroidToolbar_SnapshotDifference_MAX = AndroidToolbar_SnapshotDifference::DIFF_CCT_ANIMATION;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* AndroidToolbar_SnapshotDifference_Name(::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference value) {
  switch (value) {
  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_NONE:
    return "DIFF_NONE";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_NULL:
    return "DIFF_NULL";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_TINT:
    return "DIFF_TINT";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_TAB_COUNT:
    return "DIFF_TAB_COUNT";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_OPTIONAL_BUTTON_DATA:
    return "DIFF_OPTIONAL_BUTTON_DATA";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_VISUAL_STATE:
    return "DIFF_VISUAL_STATE";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_SECURITY_ICON:
    return "DIFF_SECURITY_ICON";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_SHOWING_UPDATE_BADGE:
    return "DIFF_SHOWING_UPDATE_BADGE";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_PAINT_PREVIEW:
    return "DIFF_PAINT_PREVIEW";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_PROGRESS:
    return "DIFF_PROGRESS";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_LOCATION_BAR_WIDTH:
    return "DIFF_LOCATION_BAR_WIDTH";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_URL_TEXT:
    return "DIFF_URL_TEXT";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_HOME_BUTTON_COLOR:
    return "DIFF_HOME_BUTTON_COLOR";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_TITLE_TEXT:
    return "DIFF_TITLE_TEXT";

  case ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference::DIFF_CCT_ANIMATION:
    return "DIFF_CCT_ANIMATION";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_SequenceManagerTask {
enum Priority : int32_t {
  UNKNOWN = 0,
  CONTROL_PRIORITY = 1,
  HIGHEST_PRIORITY = 2,
  VERY_HIGH_PRIORITY = 3,
  HIGH_PRIORITY = 4,
  NORMAL_PRIORITY = 5,
  LOW_PRIORITY = 6,
  BEST_EFFORT_PRIORITY = 7,
};
} // namespace perfetto_pbzero_enum_SequenceManagerTask
using SequenceManagerTask_Priority = perfetto_pbzero_enum_SequenceManagerTask::Priority;


constexpr SequenceManagerTask_Priority SequenceManagerTask_Priority_MIN = SequenceManagerTask_Priority::UNKNOWN;
constexpr SequenceManagerTask_Priority SequenceManagerTask_Priority_MAX = SequenceManagerTask_Priority::BEST_EFFORT_PRIORITY;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* SequenceManagerTask_Priority_Name(::perfetto::protos::pbzero::SequenceManagerTask_Priority value) {
  switch (value) {
  case ::perfetto::protos::pbzero::SequenceManagerTask_Priority::UNKNOWN:
    return "UNKNOWN";

  case ::perfetto::protos::pbzero::SequenceManagerTask_Priority::CONTROL_PRIORITY:
    return "CONTROL_PRIORITY";

  case ::perfetto::protos::pbzero::SequenceManagerTask_Priority::HIGHEST_PRIORITY:
    return "HIGHEST_PRIORITY";

  case ::perfetto::protos::pbzero::SequenceManagerTask_Priority::VERY_HIGH_PRIORITY:
    return "VERY_HIGH_PRIORITY";

  case ::perfetto::protos::pbzero::SequenceManagerTask_Priority::HIGH_PRIORITY:
    return "HIGH_PRIORITY";

  case ::perfetto::protos::pbzero::SequenceManagerTask_Priority::NORMAL_PRIORITY:
    return "NORMAL_PRIORITY";

  case ::perfetto::protos::pbzero::SequenceManagerTask_Priority::LOW_PRIORITY:
    return "LOW_PRIORITY";

  case ::perfetto::protos::pbzero::SequenceManagerTask_Priority::BEST_EFFORT_PRIORITY:
    return "BEST_EFFORT_PRIORITY";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_SequenceManagerTask {
enum QueueName : int32_t {
  UNKNOWN_TQ = 0,
  DEFAULT_TQ = 1,
  TASK_ENVIRONMENT_DEFAULT_TQ = 2,
  TEST2_TQ = 3,
  TEST_TQ = 4,
  CONTROL_TQ = 5,
  SUBTHREAD_CONTROL_TQ = 6,
  SUBTHREAD_DEFAULT_TQ = 7,
  SUBTHREAD_INPUT_TQ = 8,
  UI_BEST_EFFORT_TQ = 9,
  UI_BOOTSTRAP_TQ = 10,
  UI_CONTROL_TQ = 11,
  UI_DEFAULT_TQ = 12,
  UI_NAVIGATION_NETWORK_RESPONSE_TQ = 13,
  UI_RUN_ALL_PENDING_TQ = 14,
  UI_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ = 15,
  UI_THREAD_TQ = 16,
  UI_USER_BLOCKING_TQ = 17,
  UI_USER_INPUT_TQ = 18,
  UI_USER_VISIBLE_TQ = 19,
  IO_BEST_EFFORT_TQ = 20,
  IO_BOOTSTRAP_TQ = 21,
  IO_CONTROL_TQ = 22,
  IO_DEFAULT_TQ = 23,
  IO_NAVIGATION_NETWORK_RESPONSE_TQ = 24,
  IO_RUN_ALL_PENDING_TQ = 25,
  IO_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ = 26,
  IO_THREAD_TQ = 27,
  IO_USER_BLOCKING_TQ = 28,
  IO_USER_INPUT_TQ = 29,
  IO_USER_VISIBLE_TQ = 30,
  COMPOSITOR_TQ = 31,
  DETACHED_TQ = 32,
  FRAME_DEFERRABLE_TQ = 33,
  FRAME_LOADING_CONTROL_TQ = 34,
  FRAME_LOADING_TQ = 35,
  FRAME_PAUSABLE_TQ = 36,
  FRAME_THROTTLEABLE_TQ = 37,
  FRAME_UNPAUSABLE_TQ = 38,
  IDLE_TQ = 39,
  INPUT_TQ = 40,
  IPC_TRACKING_FOR_CACHED_PAGES_TQ = 41,
  NON_WAKING_TQ = 42,
  OTHER_TQ = 43,
  V8_TQ = 44,
  WEB_SCHEDULING_TQ = 45,
  WORKER_IDLE_TQ = 46,
  WORKER_PAUSABLE_TQ = 47,
  WORKER_THREAD_INTERNAL_TQ = 48,
  WORKER_THROTTLEABLE_TQ = 49,
  WORKER_UNPAUSABLE_TQ = 50,
  WORKER_WEB_SCHEDULING_TQ = 51,
  UI_USER_BLOCKING_DEFERRABLE_TQ = 52,
  IO_USER_BLOCKING_DEFERRABLE_TQ = 53,
};
} // namespace perfetto_pbzero_enum_SequenceManagerTask
using SequenceManagerTask_QueueName = perfetto_pbzero_enum_SequenceManagerTask::QueueName;


constexpr SequenceManagerTask_QueueName SequenceManagerTask_QueueName_MIN = SequenceManagerTask_QueueName::UNKNOWN_TQ;
constexpr SequenceManagerTask_QueueName SequenceManagerTask_QueueName_MAX = SequenceManagerTask_QueueName::IO_USER_BLOCKING_DEFERRABLE_TQ;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* SequenceManagerTask_QueueName_Name(::perfetto::protos::pbzero::SequenceManagerTask_QueueName value) {
  switch (value) {
  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UNKNOWN_TQ:
    return "UNKNOWN_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::DEFAULT_TQ:
    return "DEFAULT_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::TASK_ENVIRONMENT_DEFAULT_TQ:
    return "TASK_ENVIRONMENT_DEFAULT_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::TEST2_TQ:
    return "TEST2_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::TEST_TQ:
    return "TEST_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::CONTROL_TQ:
    return "CONTROL_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::SUBTHREAD_CONTROL_TQ:
    return "SUBTHREAD_CONTROL_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::SUBTHREAD_DEFAULT_TQ:
    return "SUBTHREAD_DEFAULT_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::SUBTHREAD_INPUT_TQ:
    return "SUBTHREAD_INPUT_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_BEST_EFFORT_TQ:
    return "UI_BEST_EFFORT_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_BOOTSTRAP_TQ:
    return "UI_BOOTSTRAP_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_CONTROL_TQ:
    return "UI_CONTROL_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_DEFAULT_TQ:
    return "UI_DEFAULT_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_NAVIGATION_NETWORK_RESPONSE_TQ:
    return "UI_NAVIGATION_NETWORK_RESPONSE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_RUN_ALL_PENDING_TQ:
    return "UI_RUN_ALL_PENDING_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ:
    return "UI_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_THREAD_TQ:
    return "UI_THREAD_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_USER_BLOCKING_TQ:
    return "UI_USER_BLOCKING_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_USER_INPUT_TQ:
    return "UI_USER_INPUT_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_USER_VISIBLE_TQ:
    return "UI_USER_VISIBLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_BEST_EFFORT_TQ:
    return "IO_BEST_EFFORT_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_BOOTSTRAP_TQ:
    return "IO_BOOTSTRAP_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_CONTROL_TQ:
    return "IO_CONTROL_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_DEFAULT_TQ:
    return "IO_DEFAULT_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_NAVIGATION_NETWORK_RESPONSE_TQ:
    return "IO_NAVIGATION_NETWORK_RESPONSE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_RUN_ALL_PENDING_TQ:
    return "IO_RUN_ALL_PENDING_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ:
    return "IO_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_THREAD_TQ:
    return "IO_THREAD_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_USER_BLOCKING_TQ:
    return "IO_USER_BLOCKING_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_USER_INPUT_TQ:
    return "IO_USER_INPUT_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_USER_VISIBLE_TQ:
    return "IO_USER_VISIBLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::COMPOSITOR_TQ:
    return "COMPOSITOR_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::DETACHED_TQ:
    return "DETACHED_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::FRAME_DEFERRABLE_TQ:
    return "FRAME_DEFERRABLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::FRAME_LOADING_CONTROL_TQ:
    return "FRAME_LOADING_CONTROL_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::FRAME_LOADING_TQ:
    return "FRAME_LOADING_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::FRAME_PAUSABLE_TQ:
    return "FRAME_PAUSABLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::FRAME_THROTTLEABLE_TQ:
    return "FRAME_THROTTLEABLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::FRAME_UNPAUSABLE_TQ:
    return "FRAME_UNPAUSABLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IDLE_TQ:
    return "IDLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::INPUT_TQ:
    return "INPUT_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IPC_TRACKING_FOR_CACHED_PAGES_TQ:
    return "IPC_TRACKING_FOR_CACHED_PAGES_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::NON_WAKING_TQ:
    return "NON_WAKING_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::OTHER_TQ:
    return "OTHER_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::V8_TQ:
    return "V8_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::WEB_SCHEDULING_TQ:
    return "WEB_SCHEDULING_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::WORKER_IDLE_TQ:
    return "WORKER_IDLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::WORKER_PAUSABLE_TQ:
    return "WORKER_PAUSABLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::WORKER_THREAD_INTERNAL_TQ:
    return "WORKER_THREAD_INTERNAL_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::WORKER_THROTTLEABLE_TQ:
    return "WORKER_THROTTLEABLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::WORKER_UNPAUSABLE_TQ:
    return "WORKER_UNPAUSABLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::WORKER_WEB_SCHEDULING_TQ:
    return "WORKER_WEB_SCHEDULING_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::UI_USER_BLOCKING_DEFERRABLE_TQ:
    return "UI_USER_BLOCKING_DEFERRABLE_TQ";

  case ::perfetto::protos::pbzero::SequenceManagerTask_QueueName::IO_USER_BLOCKING_DEFERRABLE_TQ:
    return "IO_USER_BLOCKING_DEFERRABLE_TQ";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_ProcessSingleton {
enum RemoteProcessInteractionResult : int32_t {
  INTERACTION_RESULT_UNSPECIFIED = 0,
  TERMINATE_FAILED = 1,
  REMOTE_PROCESS_NOT_FOUND = 2,
  TERMINATE_WAIT_TIMEOUT = 3,
  RUNNING_PROCESS_NOTIFY_ERROR = 4,
  TERMINATE_NOT_ENOUGH_PERMISSIONS = 5,
  REMOTE_PROCESS_SHUTTING_DOWN = 6,
  PROFILE_UNLOCKED = 7,
  PROFILE_UNLOCKED_BEFORE_KILL = 8,
  SAME_BROWSER_INSTANCE = 9,
  SAME_BROWSER_INSTANCE_BEFORE_KILL = 10,
  FAILED_TO_EXTRACT_PID = 11,
  INVALID_LOCK_FILE = 12,
  ORPHANED_LOCK_FILE = 13,
  USER_REFUSED_TERMINATION = 14,
  TERMINATE_SUCCEEDED = 100,
};
} // namespace perfetto_pbzero_enum_ProcessSingleton
using ProcessSingleton_RemoteProcessInteractionResult = perfetto_pbzero_enum_ProcessSingleton::RemoteProcessInteractionResult;


constexpr ProcessSingleton_RemoteProcessInteractionResult ProcessSingleton_RemoteProcessInteractionResult_MIN = ProcessSingleton_RemoteProcessInteractionResult::INTERACTION_RESULT_UNSPECIFIED;
constexpr ProcessSingleton_RemoteProcessInteractionResult ProcessSingleton_RemoteProcessInteractionResult_MAX = ProcessSingleton_RemoteProcessInteractionResult::TERMINATE_SUCCEEDED;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ProcessSingleton_RemoteProcessInteractionResult_Name(::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::INTERACTION_RESULT_UNSPECIFIED:
    return "INTERACTION_RESULT_UNSPECIFIED";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::TERMINATE_FAILED:
    return "TERMINATE_FAILED";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::REMOTE_PROCESS_NOT_FOUND:
    return "REMOTE_PROCESS_NOT_FOUND";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::TERMINATE_WAIT_TIMEOUT:
    return "TERMINATE_WAIT_TIMEOUT";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::RUNNING_PROCESS_NOTIFY_ERROR:
    return "RUNNING_PROCESS_NOTIFY_ERROR";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::TERMINATE_NOT_ENOUGH_PERMISSIONS:
    return "TERMINATE_NOT_ENOUGH_PERMISSIONS";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::REMOTE_PROCESS_SHUTTING_DOWN:
    return "REMOTE_PROCESS_SHUTTING_DOWN";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::PROFILE_UNLOCKED:
    return "PROFILE_UNLOCKED";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::PROFILE_UNLOCKED_BEFORE_KILL:
    return "PROFILE_UNLOCKED_BEFORE_KILL";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::SAME_BROWSER_INSTANCE:
    return "SAME_BROWSER_INSTANCE";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::SAME_BROWSER_INSTANCE_BEFORE_KILL:
    return "SAME_BROWSER_INSTANCE_BEFORE_KILL";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::FAILED_TO_EXTRACT_PID:
    return "FAILED_TO_EXTRACT_PID";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::INVALID_LOCK_FILE:
    return "INVALID_LOCK_FILE";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::ORPHANED_LOCK_FILE:
    return "ORPHANED_LOCK_FILE";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::USER_REFUSED_TERMINATION:
    return "USER_REFUSED_TERMINATION";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult::TERMINATE_SUCCEEDED:
    return "TERMINATE_SUCCEEDED";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_ProcessSingleton {
enum RemoteHungProcessTerminateReason : int32_t {
  TERMINATE_REASON_UNSPECIFIED = 0,
  USER_ACCEPTED_TERMINATION = 1,
  NO_VISIBLE_WINDOW_FOUND = 2,
  NOTIFY_ATTEMPTS_EXCEEDED = 3,
  SOCKET_WRITE_FAILED = 4,
  SOCKET_READ_FAILED = 5,
};
} // namespace perfetto_pbzero_enum_ProcessSingleton
using ProcessSingleton_RemoteHungProcessTerminateReason = perfetto_pbzero_enum_ProcessSingleton::RemoteHungProcessTerminateReason;


constexpr ProcessSingleton_RemoteHungProcessTerminateReason ProcessSingleton_RemoteHungProcessTerminateReason_MIN = ProcessSingleton_RemoteHungProcessTerminateReason::TERMINATE_REASON_UNSPECIFIED;
constexpr ProcessSingleton_RemoteHungProcessTerminateReason ProcessSingleton_RemoteHungProcessTerminateReason_MAX = ProcessSingleton_RemoteHungProcessTerminateReason::SOCKET_READ_FAILED;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ProcessSingleton_RemoteHungProcessTerminateReason_Name(::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason::TERMINATE_REASON_UNSPECIFIED:
    return "TERMINATE_REASON_UNSPECIFIED";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason::USER_ACCEPTED_TERMINATION:
    return "USER_ACCEPTED_TERMINATION";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason::NO_VISIBLE_WINDOW_FOUND:
    return "NO_VISIBLE_WINDOW_FOUND";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason::NOTIFY_ATTEMPTS_EXCEEDED:
    return "NOTIFY_ATTEMPTS_EXCEEDED";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason::SOCKET_WRITE_FAILED:
    return "SOCKET_WRITE_FAILED";

  case ::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason::SOCKET_READ_FAILED:
    return "SOCKET_READ_FAILED";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_EventLatency {
enum EventType : int32_t {
  EVENT_TYPE_UNSPECIFIED = 0,
  MOUSE_PRESSED = 1,
  MOUSE_RELEASED = 2,
  MOUSE_WHEEL = 3,
  KEY_PRESSED = 4,
  KEY_RELEASED = 5,
  TOUCH_PRESSED = 6,
  TOUCH_RELEASED = 7,
  TOUCH_MOVED = 8,
  GESTURE_SCROLL_BEGIN = 9,
  GESTURE_SCROLL_UPDATE = 10,
  GESTURE_SCROLL_END = 11,
  GESTURE_DOUBLE_TAP = 12,
  GESTURE_LONG_PRESS = 13,
  GESTURE_LONG_TAP = 14,
  GESTURE_SHOW_PRESS = 15,
  GESTURE_TAP = 16,
  GESTURE_TAP_CANCEL = 17,
  GESTURE_TAP_DOWN = 18,
  GESTURE_TAP_UNCONFIRMED = 19,
  GESTURE_TWO_FINGER_TAP = 20,
  FIRST_GESTURE_SCROLL_UPDATE = 21,
  MOUSE_DRAGGED = 22,
  GESTURE_PINCH_BEGIN = 23,
  GESTURE_PINCH_END = 24,
  GESTURE_PINCH_UPDATE = 25,
  INERTIAL_GESTURE_SCROLL_UPDATE = 26,
};
} // namespace perfetto_pbzero_enum_EventLatency
using EventLatency_EventType = perfetto_pbzero_enum_EventLatency::EventType;


constexpr EventLatency_EventType EventLatency_EventType_MIN = EventLatency_EventType::EVENT_TYPE_UNSPECIFIED;
constexpr EventLatency_EventType EventLatency_EventType_MAX = EventLatency_EventType::INERTIAL_GESTURE_SCROLL_UPDATE;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* EventLatency_EventType_Name(::perfetto::protos::pbzero::EventLatency_EventType value) {
  switch (value) {
  case ::perfetto::protos::pbzero::EventLatency_EventType::EVENT_TYPE_UNSPECIFIED:
    return "EVENT_TYPE_UNSPECIFIED";

  case ::perfetto::protos::pbzero::EventLatency_EventType::MOUSE_PRESSED:
    return "MOUSE_PRESSED";

  case ::perfetto::protos::pbzero::EventLatency_EventType::MOUSE_RELEASED:
    return "MOUSE_RELEASED";

  case ::perfetto::protos::pbzero::EventLatency_EventType::MOUSE_WHEEL:
    return "MOUSE_WHEEL";

  case ::perfetto::protos::pbzero::EventLatency_EventType::KEY_PRESSED:
    return "KEY_PRESSED";

  case ::perfetto::protos::pbzero::EventLatency_EventType::KEY_RELEASED:
    return "KEY_RELEASED";

  case ::perfetto::protos::pbzero::EventLatency_EventType::TOUCH_PRESSED:
    return "TOUCH_PRESSED";

  case ::perfetto::protos::pbzero::EventLatency_EventType::TOUCH_RELEASED:
    return "TOUCH_RELEASED";

  case ::perfetto::protos::pbzero::EventLatency_EventType::TOUCH_MOVED:
    return "TOUCH_MOVED";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_SCROLL_BEGIN:
    return "GESTURE_SCROLL_BEGIN";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_SCROLL_UPDATE:
    return "GESTURE_SCROLL_UPDATE";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_SCROLL_END:
    return "GESTURE_SCROLL_END";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_DOUBLE_TAP:
    return "GESTURE_DOUBLE_TAP";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_LONG_PRESS:
    return "GESTURE_LONG_PRESS";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_LONG_TAP:
    return "GESTURE_LONG_TAP";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_SHOW_PRESS:
    return "GESTURE_SHOW_PRESS";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_TAP:
    return "GESTURE_TAP";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_TAP_CANCEL:
    return "GESTURE_TAP_CANCEL";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_TAP_DOWN:
    return "GESTURE_TAP_DOWN";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_TAP_UNCONFIRMED:
    return "GESTURE_TAP_UNCONFIRMED";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_TWO_FINGER_TAP:
    return "GESTURE_TWO_FINGER_TAP";

  case ::perfetto::protos::pbzero::EventLatency_EventType::FIRST_GESTURE_SCROLL_UPDATE:
    return "FIRST_GESTURE_SCROLL_UPDATE";

  case ::perfetto::protos::pbzero::EventLatency_EventType::MOUSE_DRAGGED:
    return "MOUSE_DRAGGED";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_PINCH_BEGIN:
    return "GESTURE_PINCH_BEGIN";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_PINCH_END:
    return "GESTURE_PINCH_END";

  case ::perfetto::protos::pbzero::EventLatency_EventType::GESTURE_PINCH_UPDATE:
    return "GESTURE_PINCH_UPDATE";

  case ::perfetto::protos::pbzero::EventLatency_EventType::INERTIAL_GESTURE_SCROLL_UPDATE:
    return "INERTIAL_GESTURE_SCROLL_UPDATE";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_RendererMainThreadTaskExecution {
enum TaskType : int32_t {
  TASK_TYPE_UNKNOWN = 0,
  TASK_TYPE_DOM_MANIPULATION = 1,
  TASK_TYPE_USER_INTERACTION = 2,
  TASK_TYPE_NETWORKING = 3,
  TASK_TYPE_NETWORKING_CONTROL = 4,
  TASK_TYPE_HISTORY_TRAVERSAL = 5,
  TASK_TYPE_EMBED = 6,
  TASK_TYPE_MEDIA_ELEMENT_EVENT = 7,
  TASK_TYPE_CANVAS_BLOB_SERIALIZATION = 8,
  TASK_TYPE_MICROTASK = 9,
  TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_HIGH_NESTING = 10,
  TASK_TYPE_REMOTE_EVENT = 11,
  TASK_TYPE_WEB_SOCKET = 12,
  TASK_TYPE_POSTED_MESSAGE = 13,
  TASK_TYPE_UNSHIPPED_PORT_MESSAGE = 14,
  TASK_TYPE_FILE_READING = 15,
  TASK_TYPE_DATABASE_ACCESS = 16,
  TASK_TYPE_PRESENTATION = 17,
  TASK_TYPE_SENSOR = 18,
  TASK_TYPE_PERFORMANCE_TIMELINE = 19,
  TASK_TYPE_WEB_GL = 20,
  TASK_TYPE_IDLE_TASK = 21,
  TASK_TYPE_MISC_PLATFORM_API = 22,
  TASK_TYPE_INTERNAL_DEFAULT = 23,
  TASK_TYPE_INTERNAL_LOADING = 24,
  TASK_TYPE_INTERNAL_TEST = 26,
  TASK_TYPE_INTERNAL_WEB_CRYPTO = 27,
  TASK_TYPE_INTERNAL_MEDIA = 29,
  TASK_TYPE_INTERNAL_MEDIA_REALTIME = 30,
  TASK_TYPE_INTERNAL_USER_INTERACTION = 32,
  TASK_TYPE_INTERNAL_INSPECTOR = 33,
  TASK_TYPE_MAIN_THREAD_TASK_QUEUE_V8 = 37,
  TASK_TYPE_MAIN_THREAD_TASK_QUEUE_COMPOSITOR = 38,
  TASK_TYPE_MAIN_THREAD_TASK_QUEUE_DEFAULT = 39,
  TASK_TYPE_MAIN_THREAD_TASK_QUEUE_INPUT = 40,
  TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IDLE = 41,
  TASK_TYPE_MAIN_THREAD_TASK_QUEUE_CONTROL = 43,
  TASK_TYPE_INTERNAL_INTERSECTION_OBSERVER = 44,
  TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_DEFAULT = 45,
  TASK_TYPE_WORKER_THREAD_TASK_QUEUE_DEFAULT = 46,
  TASK_TYPE_WORKER_THREAD_TASK_QUEUE_V8 = 47,
  TASK_TYPE_WORKER_THREAD_TASK_QUEUE_COMPOSITOR = 48,
  TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_INPUT = 49,
  TASK_TYPE_NETWORKING_WITH_URL_LOADER_ANNOTATION = 50,
  TASK_TYPE_WORKER_ANIMATION = 51,
  TASK_TYPE_INTERNAL_TRANSLATION = 55,
  TASK_TYPE_FONT_LOADING = 56,
  TASK_TYPE_APPLICATION_LIFECYCLE = 57,
  TASK_TYPE_BACKGROUND_FETCH = 58,
  TASK_TYPE_PERMISSION = 59,
  TASK_TYPE_SERVICE_WORKER_CLIENT_MESSAGE = 60,
  TASK_TYPE_INTERNAL_CONTENT_CAPTURE = 61,
  TASK_TYPE_MAIN_THREAD_TASK_QUEUE_MEMORY_PURGE = 62,
  TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED = 63,
  TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED_UNFREEZABLE = 64,
  TASK_TYPE_INTERNAL_CONTINUE_SCRIPT_LOADING = 65,
  TASK_TYPE_WEB_LOCKS = 66,
  TASK_TYPE_WEB_SCHEDULING_POSTED_TASK = 67,
  TASK_TYPE_INTERNAL_FRAME_LIFE_CYCLE_CONTROL = 68,
  TASK_TYPE_MAIN_THREAD_TASK_QUEUE_NON_WAKING = 69,
  TASK_TYPE_INTERNAL_FIND_IN_PAGE = 70,
  TASK_TYPE_INTERNAL_HIGH_PRIORITY_LOCAL_FRAME = 71,
  TASK_TYPE_JAVASCRIPT_TIMER_IMMEDIATE = 72,
  TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_LOW_NESTING = 73,
  TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IPC_TRACKING = 74,
  TASK_TYPE_NETWORKING_UNFREEZABLE = 75,
  TASK_TYPE_WAKE_LOCK = 76,
  TASK_TYPE_INTERNAL_INPUT_BLOCKING = 77,
  TASK_TYPE_WEB_GPU = 78,
  TASK_TYPE_INTERNAL_POST_MESSAGE_FORWARDING = 79,
  TASK_TYPE_INTERNAL_NAVIGATION_CANCELLATION = 80,
  TASK_TYPE_LOW_PRIORITY_SCRIPT_EXECUTION = 81,
  TASK_TYPE_STORAGE = 82,
};
} // namespace perfetto_pbzero_enum_RendererMainThreadTaskExecution
using RendererMainThreadTaskExecution_TaskType = perfetto_pbzero_enum_RendererMainThreadTaskExecution::TaskType;


constexpr RendererMainThreadTaskExecution_TaskType RendererMainThreadTaskExecution_TaskType_MIN = RendererMainThreadTaskExecution_TaskType::TASK_TYPE_UNKNOWN;
constexpr RendererMainThreadTaskExecution_TaskType RendererMainThreadTaskExecution_TaskType_MAX = RendererMainThreadTaskExecution_TaskType::TASK_TYPE_STORAGE;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* RendererMainThreadTaskExecution_TaskType_Name(::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType value) {
  switch (value) {
  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_UNKNOWN:
    return "TASK_TYPE_UNKNOWN";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_DOM_MANIPULATION:
    return "TASK_TYPE_DOM_MANIPULATION";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_USER_INTERACTION:
    return "TASK_TYPE_USER_INTERACTION";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_NETWORKING:
    return "TASK_TYPE_NETWORKING";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_NETWORKING_CONTROL:
    return "TASK_TYPE_NETWORKING_CONTROL";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_HISTORY_TRAVERSAL:
    return "TASK_TYPE_HISTORY_TRAVERSAL";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_EMBED:
    return "TASK_TYPE_EMBED";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MEDIA_ELEMENT_EVENT:
    return "TASK_TYPE_MEDIA_ELEMENT_EVENT";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_CANVAS_BLOB_SERIALIZATION:
    return "TASK_TYPE_CANVAS_BLOB_SERIALIZATION";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MICROTASK:
    return "TASK_TYPE_MICROTASK";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_HIGH_NESTING:
    return "TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_HIGH_NESTING";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_REMOTE_EVENT:
    return "TASK_TYPE_REMOTE_EVENT";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_WEB_SOCKET:
    return "TASK_TYPE_WEB_SOCKET";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_POSTED_MESSAGE:
    return "TASK_TYPE_POSTED_MESSAGE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_UNSHIPPED_PORT_MESSAGE:
    return "TASK_TYPE_UNSHIPPED_PORT_MESSAGE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_FILE_READING:
    return "TASK_TYPE_FILE_READING";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_DATABASE_ACCESS:
    return "TASK_TYPE_DATABASE_ACCESS";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_PRESENTATION:
    return "TASK_TYPE_PRESENTATION";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_SENSOR:
    return "TASK_TYPE_SENSOR";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_PERFORMANCE_TIMELINE:
    return "TASK_TYPE_PERFORMANCE_TIMELINE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_WEB_GL:
    return "TASK_TYPE_WEB_GL";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_IDLE_TASK:
    return "TASK_TYPE_IDLE_TASK";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MISC_PLATFORM_API:
    return "TASK_TYPE_MISC_PLATFORM_API";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_DEFAULT:
    return "TASK_TYPE_INTERNAL_DEFAULT";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_LOADING:
    return "TASK_TYPE_INTERNAL_LOADING";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_TEST:
    return "TASK_TYPE_INTERNAL_TEST";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_WEB_CRYPTO:
    return "TASK_TYPE_INTERNAL_WEB_CRYPTO";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_MEDIA:
    return "TASK_TYPE_INTERNAL_MEDIA";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_MEDIA_REALTIME:
    return "TASK_TYPE_INTERNAL_MEDIA_REALTIME";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_USER_INTERACTION:
    return "TASK_TYPE_INTERNAL_USER_INTERACTION";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_INSPECTOR:
    return "TASK_TYPE_INTERNAL_INSPECTOR";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_V8:
    return "TASK_TYPE_MAIN_THREAD_TASK_QUEUE_V8";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_COMPOSITOR:
    return "TASK_TYPE_MAIN_THREAD_TASK_QUEUE_COMPOSITOR";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_DEFAULT:
    return "TASK_TYPE_MAIN_THREAD_TASK_QUEUE_DEFAULT";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_INPUT:
    return "TASK_TYPE_MAIN_THREAD_TASK_QUEUE_INPUT";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IDLE:
    return "TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IDLE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_CONTROL:
    return "TASK_TYPE_MAIN_THREAD_TASK_QUEUE_CONTROL";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_INTERSECTION_OBSERVER:
    return "TASK_TYPE_INTERNAL_INTERSECTION_OBSERVER";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_DEFAULT:
    return "TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_DEFAULT";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_WORKER_THREAD_TASK_QUEUE_DEFAULT:
    return "TASK_TYPE_WORKER_THREAD_TASK_QUEUE_DEFAULT";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_WORKER_THREAD_TASK_QUEUE_V8:
    return "TASK_TYPE_WORKER_THREAD_TASK_QUEUE_V8";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_WORKER_THREAD_TASK_QUEUE_COMPOSITOR:
    return "TASK_TYPE_WORKER_THREAD_TASK_QUEUE_COMPOSITOR";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_INPUT:
    return "TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_INPUT";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_NETWORKING_WITH_URL_LOADER_ANNOTATION:
    return "TASK_TYPE_NETWORKING_WITH_URL_LOADER_ANNOTATION";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_WORKER_ANIMATION:
    return "TASK_TYPE_WORKER_ANIMATION";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_TRANSLATION:
    return "TASK_TYPE_INTERNAL_TRANSLATION";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_FONT_LOADING:
    return "TASK_TYPE_FONT_LOADING";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_APPLICATION_LIFECYCLE:
    return "TASK_TYPE_APPLICATION_LIFECYCLE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_BACKGROUND_FETCH:
    return "TASK_TYPE_BACKGROUND_FETCH";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_PERMISSION:
    return "TASK_TYPE_PERMISSION";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_SERVICE_WORKER_CLIENT_MESSAGE:
    return "TASK_TYPE_SERVICE_WORKER_CLIENT_MESSAGE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_CONTENT_CAPTURE:
    return "TASK_TYPE_INTERNAL_CONTENT_CAPTURE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_MEMORY_PURGE:
    return "TASK_TYPE_MAIN_THREAD_TASK_QUEUE_MEMORY_PURGE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED:
    return "TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED_UNFREEZABLE:
    return "TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED_UNFREEZABLE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_CONTINUE_SCRIPT_LOADING:
    return "TASK_TYPE_INTERNAL_CONTINUE_SCRIPT_LOADING";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_WEB_LOCKS:
    return "TASK_TYPE_WEB_LOCKS";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_WEB_SCHEDULING_POSTED_TASK:
    return "TASK_TYPE_WEB_SCHEDULING_POSTED_TASK";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_FRAME_LIFE_CYCLE_CONTROL:
    return "TASK_TYPE_INTERNAL_FRAME_LIFE_CYCLE_CONTROL";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_NON_WAKING:
    return "TASK_TYPE_MAIN_THREAD_TASK_QUEUE_NON_WAKING";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_FIND_IN_PAGE:
    return "TASK_TYPE_INTERNAL_FIND_IN_PAGE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_HIGH_PRIORITY_LOCAL_FRAME:
    return "TASK_TYPE_INTERNAL_HIGH_PRIORITY_LOCAL_FRAME";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_JAVASCRIPT_TIMER_IMMEDIATE:
    return "TASK_TYPE_JAVASCRIPT_TIMER_IMMEDIATE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_LOW_NESTING:
    return "TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_LOW_NESTING";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IPC_TRACKING:
    return "TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IPC_TRACKING";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_NETWORKING_UNFREEZABLE:
    return "TASK_TYPE_NETWORKING_UNFREEZABLE";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_WAKE_LOCK:
    return "TASK_TYPE_WAKE_LOCK";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_INPUT_BLOCKING:
    return "TASK_TYPE_INTERNAL_INPUT_BLOCKING";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_WEB_GPU:
    return "TASK_TYPE_WEB_GPU";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_POST_MESSAGE_FORWARDING:
    return "TASK_TYPE_INTERNAL_POST_MESSAGE_FORWARDING";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_INTERNAL_NAVIGATION_CANCELLATION:
    return "TASK_TYPE_INTERNAL_NAVIGATION_CANCELLATION";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_LOW_PRIORITY_SCRIPT_EXECUTION:
    return "TASK_TYPE_LOW_PRIORITY_SCRIPT_EXECUTION";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType::TASK_TYPE_STORAGE:
    return "TASK_TYPE_STORAGE";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_RendererMainThreadTaskExecution {
enum FrameType : int32_t {
  FRAME_TYPE_UNSPECIFIED = 0,
  FRAME_TYPE_MAIN_FRAME = 1,
  FRAME_TYPE_SAME_ORIGIN_SUBFRAME = 2,
  FRAME_TYPE_CROSS_ORIGIN_SUBFRAME = 3,
};
} // namespace perfetto_pbzero_enum_RendererMainThreadTaskExecution
using RendererMainThreadTaskExecution_FrameType = perfetto_pbzero_enum_RendererMainThreadTaskExecution::FrameType;


constexpr RendererMainThreadTaskExecution_FrameType RendererMainThreadTaskExecution_FrameType_MIN = RendererMainThreadTaskExecution_FrameType::FRAME_TYPE_UNSPECIFIED;
constexpr RendererMainThreadTaskExecution_FrameType RendererMainThreadTaskExecution_FrameType_MAX = RendererMainThreadTaskExecution_FrameType::FRAME_TYPE_CROSS_ORIGIN_SUBFRAME;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* RendererMainThreadTaskExecution_FrameType_Name(::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType value) {
  switch (value) {
  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType::FRAME_TYPE_UNSPECIFIED:
    return "FRAME_TYPE_UNSPECIFIED";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType::FRAME_TYPE_MAIN_FRAME:
    return "FRAME_TYPE_MAIN_FRAME";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType::FRAME_TYPE_SAME_ORIGIN_SUBFRAME:
    return "FRAME_TYPE_SAME_ORIGIN_SUBFRAME";

  case ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType::FRAME_TYPE_CROSS_ORIGIN_SUBFRAME:
    return "FRAME_TYPE_CROSS_ORIGIN_SUBFRAME";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_BackForwardCacheCanStoreDocumentResult {
enum BackForwardCacheNotRestoredReason : int32_t {
  NOT_MAIN_FRAME = 1,
  BACK_FORWARD_CACHE_DISABLED = 2,
  RELATED_ACTIVE_CONTENTS_EXIST = 3,
  HTTP_STATUS_NOT_OK = 4,
  SCHEME_NOT_HTTP_OR_HTTPS = 5,
  LOADING = 6,
  WAS_GRANTED_MEDIA_ACCESS = 7,
  BLOCKLISTED_FEATURES = 8,
  DISABLE_FOR_RENDER_FRAME_HOST_CALLED = 9,
  DOMAIN_NOT_ALLOWED = 10,
  HTTP_METHOD_NOT_GET = 11,
  SUBFRAME_IS_NAVIGATING = 12,
  TIMEOUT = 13,
  CACHE_LIMIT = 14,
  JAVASCRIPT_EXECUTION = 15,
  RENDERER_PROCESS_KILLED = 16,
  RENDERER_PROCESS_CRASHED = 17,
  GRANTED_MEDIA_STREAM_ACCESS = 19,
  SCHEDULER_TRACKED_FEATURE_USED = 20,
  CONFLICTING_BROWSING_INSTANCE = 21,
  CACHE_FLUSHED = 22,
  SERVICE_WORKER_VERSION_ACTIVATION = 23,
  SESSION_RESTORED = 24,
  UNKNOWN = 25,
  SERVICE_WORKER_POST_MESSAGE = 26,
  ENTERED_BACK_FORWARD_CACHE_BEFORE_SERVICE_WORKER_HOST_ADDED = 27,
  NOT_MOST_RECENT_NAVIGATION_ENTRY = 28,
  SERVICE_WORKER_CLAIM = 29,
  IGNORE_EVENT_AND_EVICT = 30,
  HAVE_INNER_CONTENTS = 31,
  TIMEOUT_PUTTING_IN_CACHE = 32,
  BACK_FORWARD_CACHE_DISABLED_BY_LOW_MEMORY = 33,
  BACK_FORWARD_CACHE_DISABLED_BY_COMMAND_LINE = 34,
  NETWORK_REQUEST_REDIRECTED = 35,
  NETWORK_REQUEST_TIMEOUT = 36,
  NETWORK_EXCEEDS_BUFFER_LIMIT = 37,
  NAVIGATION_CANCELLED_WHILE_RESTORING = 38,
  BACK_FORWARD_CACHE_DISABLED_FOR_PRERENDER = 39,
  USER_AGENT_OVERRIDE_DIFFERS = 40,
  NETWORK_REQUEST_DATAPIPE_DRAINED_AS_BYTES_CONSUMER = 41,
  FOREGROUND_CACHE_LIMIT = 42,
  BROWSING_INSTANCE_NOT_SWAPPED = 43,
  BACK_FORWARD_CACHE_DISABLED_FOR_DELEGATE = 44,
  OPT_IN_UNLOAD_HEADER_NOT_PRESENT = 45,
  UNLOAD_HANDLER_EXISTS_IN_MAIN_FRAME = 46,
  UNLOAD_HANDLER_EXISTS_IN_SUBFRAME = 47,
  SERVICE_WORKER_UNREGISTRATION = 48,
  CACHE_CONTROL_NO_STORE = 49,
  CACHE_CONTROL_NO_STORE_COOKIE_MODIFIED = 50,
  CACHE_CONTROL_NO_STORE_HTTP_ONLY_COOKIE_MODIFIED = 51,
  NO_RESPONSE_HEAD = 52,
  ACTIVATION_NAVIGATION_DISALLOWED_FOR_BUG_1234857 = 53,
  ERROR_DOCUMENT = 54,
  FENCED_FRAMES_EMBEDDER = 55,
};
} // namespace perfetto_pbzero_enum_BackForwardCacheCanStoreDocumentResult
using BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason = perfetto_pbzero_enum_BackForwardCacheCanStoreDocumentResult::BackForwardCacheNotRestoredReason;


constexpr BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_MIN = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::NOT_MAIN_FRAME;
constexpr BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_MAX = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::FENCED_FRAMES_EMBEDDER;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_Name(::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason value) {
  switch (value) {
  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::NOT_MAIN_FRAME:
    return "NOT_MAIN_FRAME";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::BACK_FORWARD_CACHE_DISABLED:
    return "BACK_FORWARD_CACHE_DISABLED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::RELATED_ACTIVE_CONTENTS_EXIST:
    return "RELATED_ACTIVE_CONTENTS_EXIST";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::HTTP_STATUS_NOT_OK:
    return "HTTP_STATUS_NOT_OK";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::SCHEME_NOT_HTTP_OR_HTTPS:
    return "SCHEME_NOT_HTTP_OR_HTTPS";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::LOADING:
    return "LOADING";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::WAS_GRANTED_MEDIA_ACCESS:
    return "WAS_GRANTED_MEDIA_ACCESS";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::BLOCKLISTED_FEATURES:
    return "BLOCKLISTED_FEATURES";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::DISABLE_FOR_RENDER_FRAME_HOST_CALLED:
    return "DISABLE_FOR_RENDER_FRAME_HOST_CALLED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::DOMAIN_NOT_ALLOWED:
    return "DOMAIN_NOT_ALLOWED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::HTTP_METHOD_NOT_GET:
    return "HTTP_METHOD_NOT_GET";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::SUBFRAME_IS_NAVIGATING:
    return "SUBFRAME_IS_NAVIGATING";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::TIMEOUT:
    return "TIMEOUT";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::CACHE_LIMIT:
    return "CACHE_LIMIT";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::JAVASCRIPT_EXECUTION:
    return "JAVASCRIPT_EXECUTION";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::RENDERER_PROCESS_KILLED:
    return "RENDERER_PROCESS_KILLED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::RENDERER_PROCESS_CRASHED:
    return "RENDERER_PROCESS_CRASHED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::GRANTED_MEDIA_STREAM_ACCESS:
    return "GRANTED_MEDIA_STREAM_ACCESS";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::SCHEDULER_TRACKED_FEATURE_USED:
    return "SCHEDULER_TRACKED_FEATURE_USED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::CONFLICTING_BROWSING_INSTANCE:
    return "CONFLICTING_BROWSING_INSTANCE";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::CACHE_FLUSHED:
    return "CACHE_FLUSHED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::SERVICE_WORKER_VERSION_ACTIVATION:
    return "SERVICE_WORKER_VERSION_ACTIVATION";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::SESSION_RESTORED:
    return "SESSION_RESTORED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::UNKNOWN:
    return "UNKNOWN";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::SERVICE_WORKER_POST_MESSAGE:
    return "SERVICE_WORKER_POST_MESSAGE";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::ENTERED_BACK_FORWARD_CACHE_BEFORE_SERVICE_WORKER_HOST_ADDED:
    return "ENTERED_BACK_FORWARD_CACHE_BEFORE_SERVICE_WORKER_HOST_ADDED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::NOT_MOST_RECENT_NAVIGATION_ENTRY:
    return "NOT_MOST_RECENT_NAVIGATION_ENTRY";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::SERVICE_WORKER_CLAIM:
    return "SERVICE_WORKER_CLAIM";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::IGNORE_EVENT_AND_EVICT:
    return "IGNORE_EVENT_AND_EVICT";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::HAVE_INNER_CONTENTS:
    return "HAVE_INNER_CONTENTS";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::TIMEOUT_PUTTING_IN_CACHE:
    return "TIMEOUT_PUTTING_IN_CACHE";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::BACK_FORWARD_CACHE_DISABLED_BY_LOW_MEMORY:
    return "BACK_FORWARD_CACHE_DISABLED_BY_LOW_MEMORY";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::BACK_FORWARD_CACHE_DISABLED_BY_COMMAND_LINE:
    return "BACK_FORWARD_CACHE_DISABLED_BY_COMMAND_LINE";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::NETWORK_REQUEST_REDIRECTED:
    return "NETWORK_REQUEST_REDIRECTED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::NETWORK_REQUEST_TIMEOUT:
    return "NETWORK_REQUEST_TIMEOUT";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::NETWORK_EXCEEDS_BUFFER_LIMIT:
    return "NETWORK_EXCEEDS_BUFFER_LIMIT";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::NAVIGATION_CANCELLED_WHILE_RESTORING:
    return "NAVIGATION_CANCELLED_WHILE_RESTORING";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::BACK_FORWARD_CACHE_DISABLED_FOR_PRERENDER:
    return "BACK_FORWARD_CACHE_DISABLED_FOR_PRERENDER";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::USER_AGENT_OVERRIDE_DIFFERS:
    return "USER_AGENT_OVERRIDE_DIFFERS";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::NETWORK_REQUEST_DATAPIPE_DRAINED_AS_BYTES_CONSUMER:
    return "NETWORK_REQUEST_DATAPIPE_DRAINED_AS_BYTES_CONSUMER";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::FOREGROUND_CACHE_LIMIT:
    return "FOREGROUND_CACHE_LIMIT";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::BROWSING_INSTANCE_NOT_SWAPPED:
    return "BROWSING_INSTANCE_NOT_SWAPPED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::BACK_FORWARD_CACHE_DISABLED_FOR_DELEGATE:
    return "BACK_FORWARD_CACHE_DISABLED_FOR_DELEGATE";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::OPT_IN_UNLOAD_HEADER_NOT_PRESENT:
    return "OPT_IN_UNLOAD_HEADER_NOT_PRESENT";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::UNLOAD_HANDLER_EXISTS_IN_MAIN_FRAME:
    return "UNLOAD_HANDLER_EXISTS_IN_MAIN_FRAME";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::UNLOAD_HANDLER_EXISTS_IN_SUBFRAME:
    return "UNLOAD_HANDLER_EXISTS_IN_SUBFRAME";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::SERVICE_WORKER_UNREGISTRATION:
    return "SERVICE_WORKER_UNREGISTRATION";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::CACHE_CONTROL_NO_STORE:
    return "CACHE_CONTROL_NO_STORE";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::CACHE_CONTROL_NO_STORE_COOKIE_MODIFIED:
    return "CACHE_CONTROL_NO_STORE_COOKIE_MODIFIED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::CACHE_CONTROL_NO_STORE_HTTP_ONLY_COOKIE_MODIFIED:
    return "CACHE_CONTROL_NO_STORE_HTTP_ONLY_COOKIE_MODIFIED";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::NO_RESPONSE_HEAD:
    return "NO_RESPONSE_HEAD";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::ACTIVATION_NAVIGATION_DISALLOWED_FOR_BUG_1234857:
    return "ACTIVATION_NAVIGATION_DISALLOWED_FOR_BUG_1234857";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::ERROR_DOCUMENT:
    return "ERROR_DOCUMENT";

  case ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason::FENCED_FRAMES_EMBEDDER:
    return "FENCED_FRAMES_EMBEDDER";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_ChromeThreadPoolTask {
enum Priority : int32_t {
  PRIORITY_UNSPECIFIED = 0,
  PRIORITY_BEST_EFFORT = 1,
  PRIORITY_USER_VISIBLE = 2,
  PRIORITY_USER_BLOCKING = 3,
};
} // namespace perfetto_pbzero_enum_ChromeThreadPoolTask
using ChromeThreadPoolTask_Priority = perfetto_pbzero_enum_ChromeThreadPoolTask::Priority;


constexpr ChromeThreadPoolTask_Priority ChromeThreadPoolTask_Priority_MIN = ChromeThreadPoolTask_Priority::PRIORITY_UNSPECIFIED;
constexpr ChromeThreadPoolTask_Priority ChromeThreadPoolTask_Priority_MAX = ChromeThreadPoolTask_Priority::PRIORITY_USER_BLOCKING;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ChromeThreadPoolTask_Priority_Name(::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority::PRIORITY_UNSPECIFIED:
    return "PRIORITY_UNSPECIFIED";

  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority::PRIORITY_BEST_EFFORT:
    return "PRIORITY_BEST_EFFORT";

  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority::PRIORITY_USER_VISIBLE:
    return "PRIORITY_USER_VISIBLE";

  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority::PRIORITY_USER_BLOCKING:
    return "PRIORITY_USER_BLOCKING";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_ChromeThreadPoolTask {
enum ExecutionMode : int32_t {
  EXECTUION_MODE_UNSPECIFIED = 0,
  EXECUTION_MODE_PARALLEL = 1,
  EXECUTION_MODE_SEQUENCED = 2,
  EXECUTION_MODE_SINGLE_THREAD = 3,
  EXECUTION_MODE_JOB = 4,
};
} // namespace perfetto_pbzero_enum_ChromeThreadPoolTask
using ChromeThreadPoolTask_ExecutionMode = perfetto_pbzero_enum_ChromeThreadPoolTask::ExecutionMode;


constexpr ChromeThreadPoolTask_ExecutionMode ChromeThreadPoolTask_ExecutionMode_MIN = ChromeThreadPoolTask_ExecutionMode::EXECTUION_MODE_UNSPECIFIED;
constexpr ChromeThreadPoolTask_ExecutionMode ChromeThreadPoolTask_ExecutionMode_MAX = ChromeThreadPoolTask_ExecutionMode::EXECUTION_MODE_JOB;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ChromeThreadPoolTask_ExecutionMode_Name(::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode::EXECTUION_MODE_UNSPECIFIED:
    return "EXECTUION_MODE_UNSPECIFIED";

  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode::EXECUTION_MODE_PARALLEL:
    return "EXECUTION_MODE_PARALLEL";

  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode::EXECUTION_MODE_SEQUENCED:
    return "EXECUTION_MODE_SEQUENCED";

  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode::EXECUTION_MODE_SINGLE_THREAD:
    return "EXECUTION_MODE_SINGLE_THREAD";

  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode::EXECUTION_MODE_JOB:
    return "EXECUTION_MODE_JOB";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_ChromeThreadPoolTask {
enum ShutdownBehavior : int32_t {
  SHUTDOWN_BEHAVIOR_UNSPECIFIED = 0,
  SHUTDOWN_BEHAVIOR_CONTINUE_ON_SHUTDOWN = 1,
  SHUTDOWN_BEHAVIOR_SKIP_ON_SHUTDOWN = 2,
  SHUTDOWN_BEHAVIOR_BLOCK_SHUTDOWN = 3,
};
} // namespace perfetto_pbzero_enum_ChromeThreadPoolTask
using ChromeThreadPoolTask_ShutdownBehavior = perfetto_pbzero_enum_ChromeThreadPoolTask::ShutdownBehavior;


constexpr ChromeThreadPoolTask_ShutdownBehavior ChromeThreadPoolTask_ShutdownBehavior_MIN = ChromeThreadPoolTask_ShutdownBehavior::SHUTDOWN_BEHAVIOR_UNSPECIFIED;
constexpr ChromeThreadPoolTask_ShutdownBehavior ChromeThreadPoolTask_ShutdownBehavior_MAX = ChromeThreadPoolTask_ShutdownBehavior::SHUTDOWN_BEHAVIOR_BLOCK_SHUTDOWN;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ChromeThreadPoolTask_ShutdownBehavior_Name(::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior::SHUTDOWN_BEHAVIOR_UNSPECIFIED:
    return "SHUTDOWN_BEHAVIOR_UNSPECIFIED";

  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior::SHUTDOWN_BEHAVIOR_CONTINUE_ON_SHUTDOWN:
    return "SHUTDOWN_BEHAVIOR_CONTINUE_ON_SHUTDOWN";

  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior::SHUTDOWN_BEHAVIOR_SKIP_ON_SHUTDOWN:
    return "SHUTDOWN_BEHAVIOR_SKIP_ON_SHUTDOWN";

  case ::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior::SHUTDOWN_BEHAVIOR_BLOCK_SHUTDOWN:
    return "SHUTDOWN_BEHAVIOR_BLOCK_SHUTDOWN";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_RenderFrameHost {
enum LifecycleState : int32_t {
  UNSPECIFIED = 0,
  SPECULATIVE = 1,
  PENDING_COMMIT = 2,
  PRERENDERING = 3,
  ACTIVE = 4,
  IN_BACK_FORWARD_CACHE = 5,
  RUNNING_UNLOAD_HANDLERS = 6,
  READY_TO_BE_DELETED = 7,
};
} // namespace perfetto_pbzero_enum_RenderFrameHost
using RenderFrameHost_LifecycleState = perfetto_pbzero_enum_RenderFrameHost::LifecycleState;


constexpr RenderFrameHost_LifecycleState RenderFrameHost_LifecycleState_MIN = RenderFrameHost_LifecycleState::UNSPECIFIED;
constexpr RenderFrameHost_LifecycleState RenderFrameHost_LifecycleState_MAX = RenderFrameHost_LifecycleState::READY_TO_BE_DELETED;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* RenderFrameHost_LifecycleState_Name(::perfetto::protos::pbzero::RenderFrameHost_LifecycleState value) {
  switch (value) {
  case ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState::UNSPECIFIED:
    return "UNSPECIFIED";

  case ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState::SPECULATIVE:
    return "SPECULATIVE";

  case ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState::PENDING_COMMIT:
    return "PENDING_COMMIT";

  case ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState::PRERENDERING:
    return "PRERENDERING";

  case ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState::ACTIVE:
    return "ACTIVE";

  case ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState::IN_BACK_FORWARD_CACHE:
    return "IN_BACK_FORWARD_CACHE";

  case ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState::RUNNING_UNLOAD_HANDLERS:
    return "RUNNING_UNLOAD_HANDLERS";

  case ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState::READY_TO_BE_DELETED:
    return "READY_TO_BE_DELETED";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_ChromeSamplingProfilerSampleCollected {
enum WriteStatus : int32_t {
  WRITE_STATUS_NONE = 0,
  WRITE_STATUS_BUFFERING_SAMPLE = 1,
  WRITE_STATUS_WRITING_BUFFERED = 2,
  WRITE_STATUS_WRITING_TO_TRACE = 3,
};
} // namespace perfetto_pbzero_enum_ChromeSamplingProfilerSampleCollected
using ChromeSamplingProfilerSampleCollected_WriteStatus = perfetto_pbzero_enum_ChromeSamplingProfilerSampleCollected::WriteStatus;


constexpr ChromeSamplingProfilerSampleCollected_WriteStatus ChromeSamplingProfilerSampleCollected_WriteStatus_MIN = ChromeSamplingProfilerSampleCollected_WriteStatus::WRITE_STATUS_NONE;
constexpr ChromeSamplingProfilerSampleCollected_WriteStatus ChromeSamplingProfilerSampleCollected_WriteStatus_MAX = ChromeSamplingProfilerSampleCollected_WriteStatus::WRITE_STATUS_WRITING_TO_TRACE;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ChromeSamplingProfilerSampleCollected_WriteStatus_Name(::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus::WRITE_STATUS_NONE:
    return "WRITE_STATUS_NONE";

  case ::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus::WRITE_STATUS_BUFFERING_SAMPLE:
    return "WRITE_STATUS_BUFFERING_SAMPLE";

  case ::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus::WRITE_STATUS_WRITING_BUFFERED:
    return "WRITE_STATUS_WRITING_BUFFERED";

  case ::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus::WRITE_STATUS_WRITING_TO_TRACE:
    return "WRITE_STATUS_WRITING_TO_TRACE";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_ChildProcessLauncherPriority {
enum Importance : int32_t {
  IMPORTANCE_NORMAL = 1,
  IMPORTANCE_MODERATE = 2,
  IMPORTANCE_IMPORTANT = 3,
};
} // namespace perfetto_pbzero_enum_ChildProcessLauncherPriority
using ChildProcessLauncherPriority_Importance = perfetto_pbzero_enum_ChildProcessLauncherPriority::Importance;


constexpr ChildProcessLauncherPriority_Importance ChildProcessLauncherPriority_Importance_MIN = ChildProcessLauncherPriority_Importance::IMPORTANCE_NORMAL;
constexpr ChildProcessLauncherPriority_Importance ChildProcessLauncherPriority_Importance_MAX = ChildProcessLauncherPriority_Importance::IMPORTANCE_IMPORTANT;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ChildProcessLauncherPriority_Importance_Name(::perfetto::protos::pbzero::ChildProcessLauncherPriority_Importance value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ChildProcessLauncherPriority_Importance::IMPORTANCE_NORMAL:
    return "IMPORTANCE_NORMAL";

  case ::perfetto::protos::pbzero::ChildProcessLauncherPriority_Importance::IMPORTANCE_MODERATE:
    return "IMPORTANCE_MODERATE";

  case ::perfetto::protos::pbzero::ChildProcessLauncherPriority_Importance::IMPORTANCE_IMPORTANT:
    return "IMPORTANCE_IMPORTANT";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_FrameTreeNodeInfo {
enum FrameType : int32_t {
  UNSPECIFIED_FRAME_TYPE = 0,
  SUBFRAME = 1,
  PRIMARY_MAIN_FRAME = 2,
  PRERENDER_MAIN_FRAME = 3,
  FENCED_FRAME_ROOT = 4,
};
} // namespace perfetto_pbzero_enum_FrameTreeNodeInfo
using FrameTreeNodeInfo_FrameType = perfetto_pbzero_enum_FrameTreeNodeInfo::FrameType;


constexpr FrameTreeNodeInfo_FrameType FrameTreeNodeInfo_FrameType_MIN = FrameTreeNodeInfo_FrameType::UNSPECIFIED_FRAME_TYPE;
constexpr FrameTreeNodeInfo_FrameType FrameTreeNodeInfo_FrameType_MAX = FrameTreeNodeInfo_FrameType::FENCED_FRAME_ROOT;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* FrameTreeNodeInfo_FrameType_Name(::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType value) {
  switch (value) {
  case ::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType::UNSPECIFIED_FRAME_TYPE:
    return "UNSPECIFIED_FRAME_TYPE";

  case ::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType::SUBFRAME:
    return "SUBFRAME";

  case ::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType::PRIMARY_MAIN_FRAME:
    return "PRIMARY_MAIN_FRAME";

  case ::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType::PRERENDER_MAIN_FRAME:
    return "PRERENDER_MAIN_FRAME";

  case ::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType::FENCED_FRAME_ROOT:
    return "FENCED_FRAME_ROOT";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_BlinkTaskScope {
enum TaskScopeType : int32_t {
  TASK_SCOPE_UNKNOWN = 0,
  TASK_SCOPE_CALLBACK = 1,
  TASK_SCOPE_SCHEDULED_ACTION = 2,
  TASK_SCOPE_SCRIPT_EXECUTION = 3,
  TASK_SCOPE_POST_MESSAGE = 4,
  TASK_SCOPE_POP_STATE = 5,
};
} // namespace perfetto_pbzero_enum_BlinkTaskScope
using BlinkTaskScope_TaskScopeType = perfetto_pbzero_enum_BlinkTaskScope::TaskScopeType;


constexpr BlinkTaskScope_TaskScopeType BlinkTaskScope_TaskScopeType_MIN = BlinkTaskScope_TaskScopeType::TASK_SCOPE_UNKNOWN;
constexpr BlinkTaskScope_TaskScopeType BlinkTaskScope_TaskScopeType_MAX = BlinkTaskScope_TaskScopeType::TASK_SCOPE_POP_STATE;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* BlinkTaskScope_TaskScopeType_Name(::perfetto::protos::pbzero::BlinkTaskScope_TaskScopeType value) {
  switch (value) {
  case ::perfetto::protos::pbzero::BlinkTaskScope_TaskScopeType::TASK_SCOPE_UNKNOWN:
    return "TASK_SCOPE_UNKNOWN";

  case ::perfetto::protos::pbzero::BlinkTaskScope_TaskScopeType::TASK_SCOPE_CALLBACK:
    return "TASK_SCOPE_CALLBACK";

  case ::perfetto::protos::pbzero::BlinkTaskScope_TaskScopeType::TASK_SCOPE_SCHEDULED_ACTION:
    return "TASK_SCOPE_SCHEDULED_ACTION";

  case ::perfetto::protos::pbzero::BlinkTaskScope_TaskScopeType::TASK_SCOPE_SCRIPT_EXECUTION:
    return "TASK_SCOPE_SCRIPT_EXECUTION";

  case ::perfetto::protos::pbzero::BlinkTaskScope_TaskScopeType::TASK_SCOPE_POST_MESSAGE:
    return "TASK_SCOPE_POST_MESSAGE";

  case ::perfetto::protos::pbzero::BlinkTaskScope_TaskScopeType::TASK_SCOPE_POP_STATE:
    return "TASK_SCOPE_POP_STATE";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class BlinkHighEntropyAPI_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlinkHighEntropyAPI_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlinkHighEntropyAPI_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlinkHighEntropyAPI_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_execution_context() const { return at<1>().valid(); }
  ::protozero::ConstBytes execution_context() const { return at<1>().as_bytes(); }
  bool has_called_api() const { return at<2>().valid(); }
  ::protozero::ConstBytes called_api() const { return at<2>().as_bytes(); }
};

class BlinkHighEntropyAPI : public ::protozero::Message {
 public:
  using Decoder = BlinkHighEntropyAPI_Decoder;
  enum : int32_t {
    kExecutionContextFieldNumber = 1,
    kCalledApiFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BlinkHighEntropyAPI"; }

  using JSFunctionArgument = ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument;
  using CalledJsApi = ::perfetto::protos::pbzero::BlinkHighEntropyAPI_CalledJsApi;

  using FieldMetadata_ExecutionContext =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlinkExecutionContext,
      BlinkHighEntropyAPI>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ExecutionContext kExecutionContext() { return {}; }
  template <typename T = BlinkExecutionContext> T* set_execution_context() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_CalledApi =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlinkHighEntropyAPI_CalledJsApi,
      BlinkHighEntropyAPI>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CalledApi kCalledApi() { return {}; }
  template <typename T = BlinkHighEntropyAPI_CalledJsApi> T* set_called_api() {
    return BeginNestedMessage<T>(2);
  }

};

class BlinkHighEntropyAPI_CalledJsApi_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  BlinkHighEntropyAPI_CalledJsApi_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlinkHighEntropyAPI_CalledJsApi_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlinkHighEntropyAPI_CalledJsApi_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_identifier() const { return at<1>().valid(); }
  ::protozero::ConstChars identifier() const { return at<1>().as_string(); }
  bool has_func_arguments() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> func_arguments() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_source_location() const { return at<3>().valid(); }
  ::protozero::ConstBytes source_location() const { return at<3>().as_bytes(); }
};

class BlinkHighEntropyAPI_CalledJsApi : public ::protozero::Message {
 public:
  using Decoder = BlinkHighEntropyAPI_CalledJsApi_Decoder;
  enum : int32_t {
    kIdentifierFieldNumber = 1,
    kFuncArgumentsFieldNumber = 2,
    kSourceLocationFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BlinkHighEntropyAPI.CalledJsApi"; }


  using FieldMetadata_Identifier =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      BlinkHighEntropyAPI_CalledJsApi>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Identifier kIdentifier() { return {}; }
  void set_identifier(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Identifier::kFieldId, data, size);
  }
  void set_identifier(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Identifier::kFieldId, chars.data, chars.size);
  }
  void set_identifier(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Identifier::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FuncArguments =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlinkHighEntropyAPI_JSFunctionArgument,
      BlinkHighEntropyAPI_CalledJsApi>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FuncArguments kFuncArguments() { return {}; }
  template <typename T = BlinkHighEntropyAPI_JSFunctionArgument> T* add_func_arguments() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_SourceLocation =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlinkSourceLocation,
      BlinkHighEntropyAPI_CalledJsApi>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SourceLocation kSourceLocation() { return {}; }
  template <typename T = BlinkSourceLocation> T* set_source_location() {
    return BeginNestedMessage<T>(3);
  }

};

class BlinkHighEntropyAPI_JSFunctionArgument_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlinkHighEntropyAPI_JSFunctionArgument_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlinkHighEntropyAPI_JSFunctionArgument_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlinkHighEntropyAPI_JSFunctionArgument_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_type() const { return at<1>().valid(); }
  int32_t type() const { return at<1>().as_int32(); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::ConstChars value() const { return at<2>().as_string(); }
};

class BlinkHighEntropyAPI_JSFunctionArgument : public ::protozero::Message {
 public:
  using Decoder = BlinkHighEntropyAPI_JSFunctionArgument_Decoder;
  enum : int32_t {
    kTypeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BlinkHighEntropyAPI.JSFunctionArgument"; }


  using ArgumentType = ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType;
  static inline const char* ArgumentType_Name(ArgumentType value) {
    return ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType_Name(value);
  }
  static const ArgumentType UNKNOWN_TYPE = ArgumentType::UNKNOWN_TYPE;
  static const ArgumentType NULL_TYPE = ArgumentType::NULL_TYPE;
  static const ArgumentType UNDEFINED = ArgumentType::UNDEFINED;
  static const ArgumentType BIGINT = ArgumentType::BIGINT;
  static const ArgumentType BOOLEAN = ArgumentType::BOOLEAN;
  static const ArgumentType FUNCTION = ArgumentType::FUNCTION;
  static const ArgumentType NUMBER = ArgumentType::NUMBER;
  static const ArgumentType STRING = ArgumentType::STRING;
  static const ArgumentType SYMBOL = ArgumentType::SYMBOL;
  static const ArgumentType OBJECT = ArgumentType::OBJECT;

  using FieldMetadata_Type =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType,
      BlinkHighEntropyAPI_JSFunctionArgument>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Type kType() { return {}; }
  void set_type(::perfetto::protos::pbzero::BlinkHighEntropyAPI_JSFunctionArgument_ArgumentType value) {
    static constexpr uint32_t field_id = FieldMetadata_Type::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Value =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      BlinkHighEntropyAPI_JSFunctionArgument>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Value kValue() { return {}; }
  void set_value(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Value::kFieldId, data, size);
  }
  void set_value(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Value::kFieldId, chars.data, chars.size);
  }
  void set_value(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Value::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class BlinkSourceLocation_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  BlinkSourceLocation_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlinkSourceLocation_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlinkSourceLocation_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_function_name() const { return at<1>().valid(); }
  ::protozero::ConstChars function_name() const { return at<1>().as_string(); }
  bool has_script_id() const { return at<2>().valid(); }
  int32_t script_id() const { return at<2>().as_int32(); }
  bool has_url() const { return at<3>().valid(); }
  ::protozero::ConstChars url() const { return at<3>().as_string(); }
  bool has_line_number() const { return at<4>().valid(); }
  int32_t line_number() const { return at<4>().as_int32(); }
  bool has_column_number() const { return at<5>().valid(); }
  int32_t column_number() const { return at<5>().as_int32(); }
  bool has_stack_trace() const { return at<6>().valid(); }
  ::protozero::ConstChars stack_trace() const { return at<6>().as_string(); }
  bool has_stack_frames() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> stack_frames() const { return GetRepeated<::protozero::ConstBytes>(7); }
};

class BlinkSourceLocation : public ::protozero::Message {
 public:
  using Decoder = BlinkSourceLocation_Decoder;
  enum : int32_t {
    kFunctionNameFieldNumber = 1,
    kScriptIdFieldNumber = 2,
    kUrlFieldNumber = 3,
    kLineNumberFieldNumber = 4,
    kColumnNumberFieldNumber = 5,
    kStackTraceFieldNumber = 6,
    kStackFramesFieldNumber = 7,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BlinkSourceLocation"; }


  using FieldMetadata_FunctionName =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      BlinkSourceLocation>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FunctionName kFunctionName() { return {}; }
  void set_function_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_FunctionName::kFieldId, data, size);
  }
  void set_function_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_FunctionName::kFieldId, chars.data, chars.size);
  }
  void set_function_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_FunctionName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ScriptId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      BlinkSourceLocation>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ScriptId kScriptId() { return {}; }
  void set_script_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ScriptId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Url =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      BlinkSourceLocation>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Url kUrl() { return {}; }
  void set_url(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Url::kFieldId, data, size);
  }
  void set_url(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Url::kFieldId, chars.data, chars.size);
  }
  void set_url(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Url::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LineNumber =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      BlinkSourceLocation>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LineNumber kLineNumber() { return {}; }
  void set_line_number(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LineNumber::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ColumnNumber =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      BlinkSourceLocation>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ColumnNumber kColumnNumber() { return {}; }
  void set_column_number(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ColumnNumber::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StackTrace =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      BlinkSourceLocation>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_StackTrace kStackTrace() { return {}; }
  void set_stack_trace(const char* data, size_t size) {
    AppendBytes(FieldMetadata_StackTrace::kFieldId, data, size);
  }
  void set_stack_trace(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_StackTrace::kFieldId, chars.data, chars.size);
  }
  void set_stack_trace(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_StackTrace::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StackFrames =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      V8StackFrame,
      BlinkSourceLocation>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_StackFrames kStackFrames() { return {}; }
  template <typename T = V8StackFrame> T* add_stack_frames() {
    return BeginNestedMessage<T>(7);
  }

};

class BlinkExecutionContext_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlinkExecutionContext_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlinkExecutionContext_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlinkExecutionContext_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_type() const { return at<1>().valid(); }
  int32_t type() const { return at<1>().as_int32(); }
  bool has_url() const { return at<2>().valid(); }
  ::protozero::ConstChars url() const { return at<2>().as_string(); }
  bool has_origin() const { return at<3>().valid(); }
  ::protozero::ConstChars origin() const { return at<3>().as_string(); }
};

class BlinkExecutionContext : public ::protozero::Message {
 public:
  using Decoder = BlinkExecutionContext_Decoder;
  enum : int32_t {
    kTypeFieldNumber = 1,
    kUrlFieldNumber = 2,
    kOriginFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BlinkExecutionContext"; }


  using ContextType = ::perfetto::protos::pbzero::BlinkExecutionContext_ContextType;
  static inline const char* ContextType_Name(ContextType value) {
    return ::perfetto::protos::pbzero::BlinkExecutionContext_ContextType_Name(value);
  }
  static const ContextType UNKNOWN_CONTEXT = ContextType::UNKNOWN_CONTEXT;
  static const ContextType WINDOW = ContextType::WINDOW;
  static const ContextType WORKLET = ContextType::WORKLET;
  static const ContextType DEDICATED_WORKER = ContextType::DEDICATED_WORKER;
  static const ContextType SHARED_WORKER = ContextType::SHARED_WORKER;
  static const ContextType SERVICE_WORKER = ContextType::SERVICE_WORKER;

  using FieldMetadata_Type =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::BlinkExecutionContext_ContextType,
      BlinkExecutionContext>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Type kType() { return {}; }
  void set_type(::perfetto::protos::pbzero::BlinkExecutionContext_ContextType value) {
    static constexpr uint32_t field_id = FieldMetadata_Type::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Url =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      BlinkExecutionContext>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Url kUrl() { return {}; }
  void set_url(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Url::kFieldId, data, size);
  }
  void set_url(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Url::kFieldId, chars.data, chars.size);
  }
  void set_url(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Url::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Origin =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      BlinkExecutionContext>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Origin kOrigin() { return {}; }
  void set_origin(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Origin::kFieldId, data, size);
  }
  void set_origin(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Origin::kFieldId, chars.data, chars.size);
  }
  void set_origin(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Origin::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class V8StackFrame_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  V8StackFrame_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit V8StackFrame_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit V8StackFrame_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_function_name() const { return at<1>().valid(); }
  ::protozero::ConstChars function_name() const { return at<1>().as_string(); }
  bool has_script_location() const { return at<2>().valid(); }
  ::protozero::ConstBytes script_location() const { return at<2>().as_bytes(); }
};

class V8StackFrame : public ::protozero::Message {
 public:
  using Decoder = V8StackFrame_Decoder;
  enum : int32_t {
    kFunctionNameFieldNumber = 1,
    kScriptLocationFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.V8StackFrame"; }

  using ScriptLocation = ::perfetto::protos::pbzero::V8StackFrame_ScriptLocation;

  using FieldMetadata_FunctionName =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      V8StackFrame>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FunctionName kFunctionName() { return {}; }
  void set_function_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_FunctionName::kFieldId, data, size);
  }
  void set_function_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_FunctionName::kFieldId, chars.data, chars.size);
  }
  void set_function_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_FunctionName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ScriptLocation =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      V8StackFrame_ScriptLocation,
      V8StackFrame>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ScriptLocation kScriptLocation() { return {}; }
  template <typename T = V8StackFrame_ScriptLocation> T* set_script_location() {
    return BeginNestedMessage<T>(2);
  }

};

class V8StackFrame_ScriptLocation_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  V8StackFrame_ScriptLocation_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit V8StackFrame_ScriptLocation_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit V8StackFrame_ScriptLocation_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_source_url() const { return at<1>().valid(); }
  ::protozero::ConstChars source_url() const { return at<1>().as_string(); }
  bool has_line_number() const { return at<2>().valid(); }
  int64_t line_number() const { return at<2>().as_int64(); }
  bool has_column_number() const { return at<3>().valid(); }
  int64_t column_number() const { return at<3>().as_int64(); }
};

class V8StackFrame_ScriptLocation : public ::protozero::Message {
 public:
  using Decoder = V8StackFrame_ScriptLocation_Decoder;
  enum : int32_t {
    kSourceUrlFieldNumber = 1,
    kLineNumberFieldNumber = 2,
    kColumnNumberFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.V8StackFrame.ScriptLocation"; }


  using FieldMetadata_SourceUrl =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      V8StackFrame_ScriptLocation>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SourceUrl kSourceUrl() { return {}; }
  void set_source_url(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SourceUrl::kFieldId, data, size);
  }
  void set_source_url(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SourceUrl::kFieldId, chars.data, chars.size);
  }
  void set_source_url(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SourceUrl::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LineNumber =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      V8StackFrame_ScriptLocation>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LineNumber kLineNumber() { return {}; }
  void set_line_number(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LineNumber::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ColumnNumber =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      V8StackFrame_ScriptLocation>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ColumnNumber kColumnNumber() { return {}; }
  void set_column_number(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ColumnNumber::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class UkmPageLoadTimingUpdate_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  UkmPageLoadTimingUpdate_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit UkmPageLoadTimingUpdate_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit UkmPageLoadTimingUpdate_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ukm_source_id() const { return at<1>().valid(); }
  int64_t ukm_source_id() const { return at<1>().as_int64(); }
  bool has_latest_url() const { return at<2>().valid(); }
  ::protozero::ConstChars latest_url() const { return at<2>().as_string(); }
  bool has_latest_cumulative_layout_shift() const { return at<3>().valid(); }
  float latest_cumulative_layout_shift() const { return at<3>().as_float(); }
  bool has_latest_largest_contentful_paint_ms() const { return at<4>().valid(); }
  double latest_largest_contentful_paint_ms() const { return at<4>().as_double(); }
  bool has_first_contentful_paint_ms() const { return at<5>().valid(); }
  double first_contentful_paint_ms() const { return at<5>().as_double(); }
};

class UkmPageLoadTimingUpdate : public ::protozero::Message {
 public:
  using Decoder = UkmPageLoadTimingUpdate_Decoder;
  enum : int32_t {
    kUkmSourceIdFieldNumber = 1,
    kLatestUrlFieldNumber = 2,
    kLatestCumulativeLayoutShiftFieldNumber = 3,
    kLatestLargestContentfulPaintMsFieldNumber = 4,
    kFirstContentfulPaintMsFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.UkmPageLoadTimingUpdate"; }


  using FieldMetadata_UkmSourceId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      UkmPageLoadTimingUpdate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_UkmSourceId kUkmSourceId() { return {}; }
  void set_ukm_source_id(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_UkmSourceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LatestUrl =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      UkmPageLoadTimingUpdate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LatestUrl kLatestUrl() { return {}; }
  void set_latest_url(const char* data, size_t size) {
    AppendBytes(FieldMetadata_LatestUrl::kFieldId, data, size);
  }
  void set_latest_url(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_LatestUrl::kFieldId, chars.data, chars.size);
  }
  void set_latest_url(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_LatestUrl::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LatestCumulativeLayoutShift =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      UkmPageLoadTimingUpdate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LatestCumulativeLayoutShift kLatestCumulativeLayoutShift() { return {}; }
  void set_latest_cumulative_layout_shift(float value) {
    static constexpr uint32_t field_id = FieldMetadata_LatestCumulativeLayoutShift::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LatestLargestContentfulPaintMs =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kDouble,
      double,
      UkmPageLoadTimingUpdate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LatestLargestContentfulPaintMs kLatestLargestContentfulPaintMs() { return {}; }
  void set_latest_largest_contentful_paint_ms(double value) {
    static constexpr uint32_t field_id = FieldMetadata_LatestLargestContentfulPaintMs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kDouble>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FirstContentfulPaintMs =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kDouble,
      double,
      UkmPageLoadTimingUpdate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FirstContentfulPaintMs kFirstContentfulPaintMs() { return {}; }
  void set_first_contentful_paint_ms(double value) {
    static constexpr uint32_t field_id = FieldMetadata_FirstContentfulPaintMs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kDouble>
        ::Append(*this, field_id, value);
  }
};

class ActiveProcesses_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ActiveProcesses_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ActiveProcesses_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ActiveProcesses_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> pid() const { return GetRepeated<int32_t>(1); }
};

class ActiveProcesses : public ::protozero::Message {
 public:
  using Decoder = ActiveProcesses_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ActiveProcesses"; }


  using FieldMetadata_Pid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ActiveProcesses>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Pid kPid() { return {}; }
  void add_pid(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Pid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class AndroidToolbar_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AndroidToolbar_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidToolbar_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidToolbar_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_block_capture_reason() const { return at<1>().valid(); }
  int32_t block_capture_reason() const { return at<1>().as_int32(); }
  bool has_allow_capture_reason() const { return at<2>().valid(); }
  int32_t allow_capture_reason() const { return at<2>().as_int32(); }
  bool has_snapshot_difference() const { return at<3>().valid(); }
  int32_t snapshot_difference() const { return at<3>().as_int32(); }
};

class AndroidToolbar : public ::protozero::Message {
 public:
  using Decoder = AndroidToolbar_Decoder;
  enum : int32_t {
    kBlockCaptureReasonFieldNumber = 1,
    kAllowCaptureReasonFieldNumber = 2,
    kSnapshotDifferenceFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.AndroidToolbar"; }


  using BlockCaptureReason = ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason;
  static inline const char* BlockCaptureReason_Name(BlockCaptureReason value) {
    return ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason_Name(value);
  }

  using AllowCaptureReason = ::perfetto::protos::pbzero::AndroidToolbar_AllowCaptureReason;
  static inline const char* AllowCaptureReason_Name(AllowCaptureReason value) {
    return ::perfetto::protos::pbzero::AndroidToolbar_AllowCaptureReason_Name(value);
  }

  using SnapshotDifference = ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference;
  static inline const char* SnapshotDifference_Name(SnapshotDifference value) {
    return ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference_Name(value);
  }
  static const BlockCaptureReason BLOCKED_UNKNOWN = BlockCaptureReason::BLOCKED_UNKNOWN;
  static const BlockCaptureReason BLOCKED_TOOLBAR_OR_RESULT_NULL = BlockCaptureReason::BLOCKED_TOOLBAR_OR_RESULT_NULL;
  static const BlockCaptureReason BLOCKED_VIEW_NOT_DIRTY = BlockCaptureReason::BLOCKED_VIEW_NOT_DIRTY;
  static const BlockCaptureReason BLOCKED_SNAPSHOT_SAME = BlockCaptureReason::BLOCKED_SNAPSHOT_SAME;
  static const BlockCaptureReason BLOCKED_URL_BAR_HAS_FOCUS = BlockCaptureReason::BLOCKED_URL_BAR_HAS_FOCUS;
  static const BlockCaptureReason BLOCKED_URL_BAR_FOCUS_IN_PROGRESS = BlockCaptureReason::BLOCKED_URL_BAR_FOCUS_IN_PROGRESS;
  static const BlockCaptureReason BLOCKED_OPTIONAL_BUTTON_ANIMATION_IN_PROGRESS = BlockCaptureReason::BLOCKED_OPTIONAL_BUTTON_ANIMATION_IN_PROGRESS;
  static const BlockCaptureReason BLOCKED_STATUS_ICON_ANIMATION_IN_PROGRESS = BlockCaptureReason::BLOCKED_STATUS_ICON_ANIMATION_IN_PROGRESS;
  static const BlockCaptureReason BLOCKED_SCROLL_ABLATION = BlockCaptureReason::BLOCKED_SCROLL_ABLATION;
  static const BlockCaptureReason BLOCKED_BROWSER_CONTROLS_LOCKED = BlockCaptureReason::BLOCKED_BROWSER_CONTROLS_LOCKED;
  static const BlockCaptureReason BLOCKED_TAB_SWITCHER_MODE = BlockCaptureReason::BLOCKED_TAB_SWITCHER_MODE;
  static const BlockCaptureReason BLOCKED_COMPOSITOR_IN_MOTION = BlockCaptureReason::BLOCKED_COMPOSITOR_IN_MOTION;
  static const AllowCaptureReason ALLOWED_UNKNOWN = AllowCaptureReason::ALLOWED_UNKNOWN;
  static const AllowCaptureReason ALLOWED_FORCE_CAPTURE = AllowCaptureReason::ALLOWED_FORCE_CAPTURE;
  static const AllowCaptureReason ALLOWED_SNAPSHOT_DIFFERENCE = AllowCaptureReason::ALLOWED_SNAPSHOT_DIFFERENCE;
  static const SnapshotDifference DIFF_NONE = SnapshotDifference::DIFF_NONE;
  static const SnapshotDifference DIFF_NULL = SnapshotDifference::DIFF_NULL;
  static const SnapshotDifference DIFF_TINT = SnapshotDifference::DIFF_TINT;
  static const SnapshotDifference DIFF_TAB_COUNT = SnapshotDifference::DIFF_TAB_COUNT;
  static const SnapshotDifference DIFF_OPTIONAL_BUTTON_DATA = SnapshotDifference::DIFF_OPTIONAL_BUTTON_DATA;
  static const SnapshotDifference DIFF_VISUAL_STATE = SnapshotDifference::DIFF_VISUAL_STATE;
  static const SnapshotDifference DIFF_SECURITY_ICON = SnapshotDifference::DIFF_SECURITY_ICON;
  static const SnapshotDifference DIFF_SHOWING_UPDATE_BADGE = SnapshotDifference::DIFF_SHOWING_UPDATE_BADGE;
  static const SnapshotDifference DIFF_PAINT_PREVIEW = SnapshotDifference::DIFF_PAINT_PREVIEW;
  static const SnapshotDifference DIFF_PROGRESS = SnapshotDifference::DIFF_PROGRESS;
  static const SnapshotDifference DIFF_LOCATION_BAR_WIDTH = SnapshotDifference::DIFF_LOCATION_BAR_WIDTH;
  static const SnapshotDifference DIFF_URL_TEXT = SnapshotDifference::DIFF_URL_TEXT;
  static const SnapshotDifference DIFF_HOME_BUTTON_COLOR = SnapshotDifference::DIFF_HOME_BUTTON_COLOR;
  static const SnapshotDifference DIFF_TITLE_TEXT = SnapshotDifference::DIFF_TITLE_TEXT;
  static const SnapshotDifference DIFF_CCT_ANIMATION = SnapshotDifference::DIFF_CCT_ANIMATION;

  using FieldMetadata_BlockCaptureReason =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason,
      AndroidToolbar>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockCaptureReason kBlockCaptureReason() { return {}; }
  void set_block_capture_reason(::perfetto::protos::pbzero::AndroidToolbar_BlockCaptureReason value) {
    static constexpr uint32_t field_id = FieldMetadata_BlockCaptureReason::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AllowCaptureReason =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::AndroidToolbar_AllowCaptureReason,
      AndroidToolbar>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AllowCaptureReason kAllowCaptureReason() { return {}; }
  void set_allow_capture_reason(::perfetto::protos::pbzero::AndroidToolbar_AllowCaptureReason value) {
    static constexpr uint32_t field_id = FieldMetadata_AllowCaptureReason::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SnapshotDifference =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference,
      AndroidToolbar>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SnapshotDifference kSnapshotDifference() { return {}; }
  void set_snapshot_difference(::perfetto::protos::pbzero::AndroidToolbar_SnapshotDifference value) {
    static constexpr uint32_t field_id = FieldMetadata_SnapshotDifference::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class SequenceManagerTask_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SequenceManagerTask_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SequenceManagerTask_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SequenceManagerTask_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_priority() const { return at<1>().valid(); }
  int32_t priority() const { return at<1>().as_int32(); }
  bool has_queue_name() const { return at<2>().valid(); }
  int32_t queue_name() const { return at<2>().as_int32(); }
};

class SequenceManagerTask : public ::protozero::Message {
 public:
  using Decoder = SequenceManagerTask_Decoder;
  enum : int32_t {
    kPriorityFieldNumber = 1,
    kQueueNameFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SequenceManagerTask"; }


  using Priority = ::perfetto::protos::pbzero::SequenceManagerTask_Priority;
  static inline const char* Priority_Name(Priority value) {
    return ::perfetto::protos::pbzero::SequenceManagerTask_Priority_Name(value);
  }

  using QueueName = ::perfetto::protos::pbzero::SequenceManagerTask_QueueName;
  static inline const char* QueueName_Name(QueueName value) {
    return ::perfetto::protos::pbzero::SequenceManagerTask_QueueName_Name(value);
  }
  static const Priority UNKNOWN = Priority::UNKNOWN;
  static const Priority CONTROL_PRIORITY = Priority::CONTROL_PRIORITY;
  static const Priority HIGHEST_PRIORITY = Priority::HIGHEST_PRIORITY;
  static const Priority VERY_HIGH_PRIORITY = Priority::VERY_HIGH_PRIORITY;
  static const Priority HIGH_PRIORITY = Priority::HIGH_PRIORITY;
  static const Priority NORMAL_PRIORITY = Priority::NORMAL_PRIORITY;
  static const Priority LOW_PRIORITY = Priority::LOW_PRIORITY;
  static const Priority BEST_EFFORT_PRIORITY = Priority::BEST_EFFORT_PRIORITY;
  static const QueueName UNKNOWN_TQ = QueueName::UNKNOWN_TQ;
  static const QueueName DEFAULT_TQ = QueueName::DEFAULT_TQ;
  static const QueueName TASK_ENVIRONMENT_DEFAULT_TQ = QueueName::TASK_ENVIRONMENT_DEFAULT_TQ;
  static const QueueName TEST2_TQ = QueueName::TEST2_TQ;
  static const QueueName TEST_TQ = QueueName::TEST_TQ;
  static const QueueName CONTROL_TQ = QueueName::CONTROL_TQ;
  static const QueueName SUBTHREAD_CONTROL_TQ = QueueName::SUBTHREAD_CONTROL_TQ;
  static const QueueName SUBTHREAD_DEFAULT_TQ = QueueName::SUBTHREAD_DEFAULT_TQ;
  static const QueueName SUBTHREAD_INPUT_TQ = QueueName::SUBTHREAD_INPUT_TQ;
  static const QueueName UI_BEST_EFFORT_TQ = QueueName::UI_BEST_EFFORT_TQ;
  static const QueueName UI_BOOTSTRAP_TQ = QueueName::UI_BOOTSTRAP_TQ;
  static const QueueName UI_CONTROL_TQ = QueueName::UI_CONTROL_TQ;
  static const QueueName UI_DEFAULT_TQ = QueueName::UI_DEFAULT_TQ;
  static const QueueName UI_NAVIGATION_NETWORK_RESPONSE_TQ = QueueName::UI_NAVIGATION_NETWORK_RESPONSE_TQ;
  static const QueueName UI_RUN_ALL_PENDING_TQ = QueueName::UI_RUN_ALL_PENDING_TQ;
  static const QueueName UI_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ = QueueName::UI_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ;
  static const QueueName UI_THREAD_TQ = QueueName::UI_THREAD_TQ;
  static const QueueName UI_USER_BLOCKING_TQ = QueueName::UI_USER_BLOCKING_TQ;
  static const QueueName UI_USER_INPUT_TQ = QueueName::UI_USER_INPUT_TQ;
  static const QueueName UI_USER_VISIBLE_TQ = QueueName::UI_USER_VISIBLE_TQ;
  static const QueueName IO_BEST_EFFORT_TQ = QueueName::IO_BEST_EFFORT_TQ;
  static const QueueName IO_BOOTSTRAP_TQ = QueueName::IO_BOOTSTRAP_TQ;
  static const QueueName IO_CONTROL_TQ = QueueName::IO_CONTROL_TQ;
  static const QueueName IO_DEFAULT_TQ = QueueName::IO_DEFAULT_TQ;
  static const QueueName IO_NAVIGATION_NETWORK_RESPONSE_TQ = QueueName::IO_NAVIGATION_NETWORK_RESPONSE_TQ;
  static const QueueName IO_RUN_ALL_PENDING_TQ = QueueName::IO_RUN_ALL_PENDING_TQ;
  static const QueueName IO_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ = QueueName::IO_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ;
  static const QueueName IO_THREAD_TQ = QueueName::IO_THREAD_TQ;
  static const QueueName IO_USER_BLOCKING_TQ = QueueName::IO_USER_BLOCKING_TQ;
  static const QueueName IO_USER_INPUT_TQ = QueueName::IO_USER_INPUT_TQ;
  static const QueueName IO_USER_VISIBLE_TQ = QueueName::IO_USER_VISIBLE_TQ;
  static const QueueName COMPOSITOR_TQ = QueueName::COMPOSITOR_TQ;
  static const QueueName DETACHED_TQ = QueueName::DETACHED_TQ;
  static const QueueName FRAME_DEFERRABLE_TQ = QueueName::FRAME_DEFERRABLE_TQ;
  static const QueueName FRAME_LOADING_CONTROL_TQ = QueueName::FRAME_LOADING_CONTROL_TQ;
  static const QueueName FRAME_LOADING_TQ = QueueName::FRAME_LOADING_TQ;
  static const QueueName FRAME_PAUSABLE_TQ = QueueName::FRAME_PAUSABLE_TQ;
  static const QueueName FRAME_THROTTLEABLE_TQ = QueueName::FRAME_THROTTLEABLE_TQ;
  static const QueueName FRAME_UNPAUSABLE_TQ = QueueName::FRAME_UNPAUSABLE_TQ;
  static const QueueName IDLE_TQ = QueueName::IDLE_TQ;
  static const QueueName INPUT_TQ = QueueName::INPUT_TQ;
  static const QueueName IPC_TRACKING_FOR_CACHED_PAGES_TQ = QueueName::IPC_TRACKING_FOR_CACHED_PAGES_TQ;
  static const QueueName NON_WAKING_TQ = QueueName::NON_WAKING_TQ;
  static const QueueName OTHER_TQ = QueueName::OTHER_TQ;
  static const QueueName V8_TQ = QueueName::V8_TQ;
  static const QueueName WEB_SCHEDULING_TQ = QueueName::WEB_SCHEDULING_TQ;
  static const QueueName WORKER_IDLE_TQ = QueueName::WORKER_IDLE_TQ;
  static const QueueName WORKER_PAUSABLE_TQ = QueueName::WORKER_PAUSABLE_TQ;
  static const QueueName WORKER_THREAD_INTERNAL_TQ = QueueName::WORKER_THREAD_INTERNAL_TQ;
  static const QueueName WORKER_THROTTLEABLE_TQ = QueueName::WORKER_THROTTLEABLE_TQ;
  static const QueueName WORKER_UNPAUSABLE_TQ = QueueName::WORKER_UNPAUSABLE_TQ;
  static const QueueName WORKER_WEB_SCHEDULING_TQ = QueueName::WORKER_WEB_SCHEDULING_TQ;
  static const QueueName UI_USER_BLOCKING_DEFERRABLE_TQ = QueueName::UI_USER_BLOCKING_DEFERRABLE_TQ;
  static const QueueName IO_USER_BLOCKING_DEFERRABLE_TQ = QueueName::IO_USER_BLOCKING_DEFERRABLE_TQ;

  using FieldMetadata_Priority =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::SequenceManagerTask_Priority,
      SequenceManagerTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Priority kPriority() { return {}; }
  void set_priority(::perfetto::protos::pbzero::SequenceManagerTask_Priority value) {
    static constexpr uint32_t field_id = FieldMetadata_Priority::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_QueueName =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::SequenceManagerTask_QueueName,
      SequenceManagerTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_QueueName kQueueName() { return {}; }
  void set_queue_name(::perfetto::protos::pbzero::SequenceManagerTask_QueueName value) {
    static constexpr uint32_t field_id = FieldMetadata_QueueName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class AndroidIPC_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AndroidIPC_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidIPC_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidIPC_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_dur_ms() const { return at<2>().valid(); }
  int64_t dur_ms() const { return at<2>().as_int64(); }
};

class AndroidIPC : public ::protozero::Message {
 public:
  using Decoder = AndroidIPC_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kDurMsFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.AndroidIPC"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      AndroidIPC>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Name kName() { return {}; }
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DurMs =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      AndroidIPC>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DurMs kDurMs() { return {}; }
  void set_dur_ms(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DurMs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class NavigationHandle_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  NavigationHandle_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit NavigationHandle_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit NavigationHandle_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_navigation_id() const { return at<1>().valid(); }
  int64_t navigation_id() const { return at<1>().as_int64(); }
  bool has_has_committed() const { return at<2>().valid(); }
  bool has_committed() const { return at<2>().as_bool(); }
  bool has_is_error_page() const { return at<3>().valid(); }
  bool is_error_page() const { return at<3>().as_bool(); }
  bool has_frame_tree_node() const { return at<4>().valid(); }
  ::protozero::ConstBytes frame_tree_node() const { return at<4>().as_bytes(); }
  bool has_render_frame_host() const { return at<5>().valid(); }
  ::protozero::ConstBytes render_frame_host() const { return at<5>().as_bytes(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class NavigationHandle : public ::protozero::Message {
 public:
  using Decoder = NavigationHandle_Decoder;
  enum : int32_t {
    kNavigationIdFieldNumber = 1,
    kHasCommittedFieldNumber = 2,
    kIsErrorPageFieldNumber = 3,
    kFrameTreeNodeFieldNumber = 4,
    kRenderFrameHostFieldNumber = 5,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.NavigationHandle"; }


  using FieldMetadata_NavigationId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_NavigationId kNavigationId() { return {}; }
  void set_navigation_id(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_NavigationId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasCommitted =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasCommitted kHasCommitted() { return {}; }
  void set_has_committed(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasCommitted::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsErrorPage =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsErrorPage kIsErrorPage() { return {}; }
  void set_is_error_page(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsErrorPage::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrameTreeNode =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FrameTreeNodeInfo,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNode kFrameTreeNode() { return {}; }
  template <typename T = FrameTreeNodeInfo> T* set_frame_tree_node() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_RenderFrameHost =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderFrameHost kRenderFrameHost() { return {}; }
  template <typename T = RenderFrameHost> T* set_render_frame_host() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class ProcessSingleton_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProcessSingleton_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessSingleton_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessSingleton_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_remote_process_interaction_result() const { return at<1>().valid(); }
  int32_t remote_process_interaction_result() const { return at<1>().as_int32(); }
  bool has_remote_process_terminate_reason() const { return at<2>().valid(); }
  int32_t remote_process_terminate_reason() const { return at<2>().as_int32(); }
};

class ProcessSingleton : public ::protozero::Message {
 public:
  using Decoder = ProcessSingleton_Decoder;
  enum : int32_t {
    kRemoteProcessInteractionResultFieldNumber = 1,
    kRemoteProcessTerminateReasonFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ProcessSingleton"; }


  using RemoteProcessInteractionResult = ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult;
  static inline const char* RemoteProcessInteractionResult_Name(RemoteProcessInteractionResult value) {
    return ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult_Name(value);
  }

  using RemoteHungProcessTerminateReason = ::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason;
  static inline const char* RemoteHungProcessTerminateReason_Name(RemoteHungProcessTerminateReason value) {
    return ::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason_Name(value);
  }
  static const RemoteProcessInteractionResult INTERACTION_RESULT_UNSPECIFIED = RemoteProcessInteractionResult::INTERACTION_RESULT_UNSPECIFIED;
  static const RemoteProcessInteractionResult TERMINATE_FAILED = RemoteProcessInteractionResult::TERMINATE_FAILED;
  static const RemoteProcessInteractionResult REMOTE_PROCESS_NOT_FOUND = RemoteProcessInteractionResult::REMOTE_PROCESS_NOT_FOUND;
  static const RemoteProcessInteractionResult TERMINATE_WAIT_TIMEOUT = RemoteProcessInteractionResult::TERMINATE_WAIT_TIMEOUT;
  static const RemoteProcessInteractionResult RUNNING_PROCESS_NOTIFY_ERROR = RemoteProcessInteractionResult::RUNNING_PROCESS_NOTIFY_ERROR;
  static const RemoteProcessInteractionResult TERMINATE_NOT_ENOUGH_PERMISSIONS = RemoteProcessInteractionResult::TERMINATE_NOT_ENOUGH_PERMISSIONS;
  static const RemoteProcessInteractionResult REMOTE_PROCESS_SHUTTING_DOWN = RemoteProcessInteractionResult::REMOTE_PROCESS_SHUTTING_DOWN;
  static const RemoteProcessInteractionResult PROFILE_UNLOCKED = RemoteProcessInteractionResult::PROFILE_UNLOCKED;
  static const RemoteProcessInteractionResult PROFILE_UNLOCKED_BEFORE_KILL = RemoteProcessInteractionResult::PROFILE_UNLOCKED_BEFORE_KILL;
  static const RemoteProcessInteractionResult SAME_BROWSER_INSTANCE = RemoteProcessInteractionResult::SAME_BROWSER_INSTANCE;
  static const RemoteProcessInteractionResult SAME_BROWSER_INSTANCE_BEFORE_KILL = RemoteProcessInteractionResult::SAME_BROWSER_INSTANCE_BEFORE_KILL;
  static const RemoteProcessInteractionResult FAILED_TO_EXTRACT_PID = RemoteProcessInteractionResult::FAILED_TO_EXTRACT_PID;
  static const RemoteProcessInteractionResult INVALID_LOCK_FILE = RemoteProcessInteractionResult::INVALID_LOCK_FILE;
  static const RemoteProcessInteractionResult ORPHANED_LOCK_FILE = RemoteProcessInteractionResult::ORPHANED_LOCK_FILE;
  static const RemoteProcessInteractionResult USER_REFUSED_TERMINATION = RemoteProcessInteractionResult::USER_REFUSED_TERMINATION;
  static const RemoteProcessInteractionResult TERMINATE_SUCCEEDED = RemoteProcessInteractionResult::TERMINATE_SUCCEEDED;
  static const RemoteHungProcessTerminateReason TERMINATE_REASON_UNSPECIFIED = RemoteHungProcessTerminateReason::TERMINATE_REASON_UNSPECIFIED;
  static const RemoteHungProcessTerminateReason USER_ACCEPTED_TERMINATION = RemoteHungProcessTerminateReason::USER_ACCEPTED_TERMINATION;
  static const RemoteHungProcessTerminateReason NO_VISIBLE_WINDOW_FOUND = RemoteHungProcessTerminateReason::NO_VISIBLE_WINDOW_FOUND;
  static const RemoteHungProcessTerminateReason NOTIFY_ATTEMPTS_EXCEEDED = RemoteHungProcessTerminateReason::NOTIFY_ATTEMPTS_EXCEEDED;
  static const RemoteHungProcessTerminateReason SOCKET_WRITE_FAILED = RemoteHungProcessTerminateReason::SOCKET_WRITE_FAILED;
  static const RemoteHungProcessTerminateReason SOCKET_READ_FAILED = RemoteHungProcessTerminateReason::SOCKET_READ_FAILED;

  using FieldMetadata_RemoteProcessInteractionResult =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult,
      ProcessSingleton>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RemoteProcessInteractionResult kRemoteProcessInteractionResult() { return {}; }
  void set_remote_process_interaction_result(::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult value) {
    static constexpr uint32_t field_id = FieldMetadata_RemoteProcessInteractionResult::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RemoteProcessTerminateReason =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason,
      ProcessSingleton>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RemoteProcessTerminateReason kRemoteProcessTerminateReason() { return {}; }
  void set_remote_process_terminate_reason(::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason value) {
    static constexpr uint32_t field_id = FieldMetadata_RemoteProcessTerminateReason::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class EventLatency_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  EventLatency_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EventLatency_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EventLatency_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_type() const { return at<1>().valid(); }
  int32_t event_type() const { return at<1>().as_int32(); }
  bool has_has_high_latency() const { return at<2>().valid(); }
  bool has_high_latency() const { return at<2>().as_bool(); }
  bool has_high_latency_stage() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> high_latency_stage() const { return GetRepeated<::protozero::ConstChars>(3); }
};

class EventLatency : public ::protozero::Message {
 public:
  using Decoder = EventLatency_Decoder;
  enum : int32_t {
    kEventTypeFieldNumber = 1,
    kHasHighLatencyFieldNumber = 2,
    kHighLatencyStageFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.EventLatency"; }


  using EventType = ::perfetto::protos::pbzero::EventLatency_EventType;
  static inline const char* EventType_Name(EventType value) {
    return ::perfetto::protos::pbzero::EventLatency_EventType_Name(value);
  }
  static const EventType EVENT_TYPE_UNSPECIFIED = EventType::EVENT_TYPE_UNSPECIFIED;
  static const EventType MOUSE_PRESSED = EventType::MOUSE_PRESSED;
  static const EventType MOUSE_RELEASED = EventType::MOUSE_RELEASED;
  static const EventType MOUSE_WHEEL = EventType::MOUSE_WHEEL;
  static const EventType KEY_PRESSED = EventType::KEY_PRESSED;
  static const EventType KEY_RELEASED = EventType::KEY_RELEASED;
  static const EventType TOUCH_PRESSED = EventType::TOUCH_PRESSED;
  static const EventType TOUCH_RELEASED = EventType::TOUCH_RELEASED;
  static const EventType TOUCH_MOVED = EventType::TOUCH_MOVED;
  static const EventType GESTURE_SCROLL_BEGIN = EventType::GESTURE_SCROLL_BEGIN;
  static const EventType GESTURE_SCROLL_UPDATE = EventType::GESTURE_SCROLL_UPDATE;
  static const EventType GESTURE_SCROLL_END = EventType::GESTURE_SCROLL_END;
  static const EventType GESTURE_DOUBLE_TAP = EventType::GESTURE_DOUBLE_TAP;
  static const EventType GESTURE_LONG_PRESS = EventType::GESTURE_LONG_PRESS;
  static const EventType GESTURE_LONG_TAP = EventType::GESTURE_LONG_TAP;
  static const EventType GESTURE_SHOW_PRESS = EventType::GESTURE_SHOW_PRESS;
  static const EventType GESTURE_TAP = EventType::GESTURE_TAP;
  static const EventType GESTURE_TAP_CANCEL = EventType::GESTURE_TAP_CANCEL;
  static const EventType GESTURE_TAP_DOWN = EventType::GESTURE_TAP_DOWN;
  static const EventType GESTURE_TAP_UNCONFIRMED = EventType::GESTURE_TAP_UNCONFIRMED;
  static const EventType GESTURE_TWO_FINGER_TAP = EventType::GESTURE_TWO_FINGER_TAP;
  static const EventType FIRST_GESTURE_SCROLL_UPDATE = EventType::FIRST_GESTURE_SCROLL_UPDATE;
  static const EventType MOUSE_DRAGGED = EventType::MOUSE_DRAGGED;
  static const EventType GESTURE_PINCH_BEGIN = EventType::GESTURE_PINCH_BEGIN;
  static const EventType GESTURE_PINCH_END = EventType::GESTURE_PINCH_END;
  static const EventType GESTURE_PINCH_UPDATE = EventType::GESTURE_PINCH_UPDATE;
  static const EventType INERTIAL_GESTURE_SCROLL_UPDATE = EventType::INERTIAL_GESTURE_SCROLL_UPDATE;

  using FieldMetadata_EventType =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::EventLatency_EventType,
      EventLatency>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_EventType kEventType() { return {}; }
  void set_event_type(::perfetto::protos::pbzero::EventLatency_EventType value) {
    static constexpr uint32_t field_id = FieldMetadata_EventType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasHighLatency =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      EventLatency>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasHighLatency kHasHighLatency() { return {}; }
  void set_has_high_latency(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasHighLatency::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HighLatencyStage =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      EventLatency>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HighLatencyStage kHighLatencyStage() { return {}; }
  void add_high_latency_stage(const char* data, size_t size) {
    AppendBytes(FieldMetadata_HighLatencyStage::kFieldId, data, size);
  }
  void add_high_latency_stage(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_HighLatencyStage::kFieldId, chars.data, chars.size);
  }
  void add_high_latency_stage(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_HighLatencyStage::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class RendererMainThreadTaskExecution_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RendererMainThreadTaskExecution_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RendererMainThreadTaskExecution_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RendererMainThreadTaskExecution_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_task_type() const { return at<1>().valid(); }
  int32_t task_type() const { return at<1>().as_int32(); }
  bool has_frame_visible() const { return at<2>().valid(); }
  bool frame_visible() const { return at<2>().as_bool(); }
  bool has_page_visible() const { return at<3>().valid(); }
  bool page_visible() const { return at<3>().as_bool(); }
  bool has_frame_type() const { return at<4>().valid(); }
  int32_t frame_type() const { return at<4>().as_int32(); }
  bool has_is_ad_frame() const { return at<5>().valid(); }
  bool is_ad_frame() const { return at<5>().as_bool(); }
};

class RendererMainThreadTaskExecution : public ::protozero::Message {
 public:
  using Decoder = RendererMainThreadTaskExecution_Decoder;
  enum : int32_t {
    kTaskTypeFieldNumber = 1,
    kFrameVisibleFieldNumber = 2,
    kPageVisibleFieldNumber = 3,
    kFrameTypeFieldNumber = 4,
    kIsAdFrameFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RendererMainThreadTaskExecution"; }


  using TaskType = ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType;
  static inline const char* TaskType_Name(TaskType value) {
    return ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType_Name(value);
  }

  using FrameType = ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType;
  static inline const char* FrameType_Name(FrameType value) {
    return ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType_Name(value);
  }
  static const TaskType TASK_TYPE_UNKNOWN = TaskType::TASK_TYPE_UNKNOWN;
  static const TaskType TASK_TYPE_DOM_MANIPULATION = TaskType::TASK_TYPE_DOM_MANIPULATION;
  static const TaskType TASK_TYPE_USER_INTERACTION = TaskType::TASK_TYPE_USER_INTERACTION;
  static const TaskType TASK_TYPE_NETWORKING = TaskType::TASK_TYPE_NETWORKING;
  static const TaskType TASK_TYPE_NETWORKING_CONTROL = TaskType::TASK_TYPE_NETWORKING_CONTROL;
  static const TaskType TASK_TYPE_HISTORY_TRAVERSAL = TaskType::TASK_TYPE_HISTORY_TRAVERSAL;
  static const TaskType TASK_TYPE_EMBED = TaskType::TASK_TYPE_EMBED;
  static const TaskType TASK_TYPE_MEDIA_ELEMENT_EVENT = TaskType::TASK_TYPE_MEDIA_ELEMENT_EVENT;
  static const TaskType TASK_TYPE_CANVAS_BLOB_SERIALIZATION = TaskType::TASK_TYPE_CANVAS_BLOB_SERIALIZATION;
  static const TaskType TASK_TYPE_MICROTASK = TaskType::TASK_TYPE_MICROTASK;
  static const TaskType TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_HIGH_NESTING = TaskType::TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_HIGH_NESTING;
  static const TaskType TASK_TYPE_REMOTE_EVENT = TaskType::TASK_TYPE_REMOTE_EVENT;
  static const TaskType TASK_TYPE_WEB_SOCKET = TaskType::TASK_TYPE_WEB_SOCKET;
  static const TaskType TASK_TYPE_POSTED_MESSAGE = TaskType::TASK_TYPE_POSTED_MESSAGE;
  static const TaskType TASK_TYPE_UNSHIPPED_PORT_MESSAGE = TaskType::TASK_TYPE_UNSHIPPED_PORT_MESSAGE;
  static const TaskType TASK_TYPE_FILE_READING = TaskType::TASK_TYPE_FILE_READING;
  static const TaskType TASK_TYPE_DATABASE_ACCESS = TaskType::TASK_TYPE_DATABASE_ACCESS;
  static const TaskType TASK_TYPE_PRESENTATION = TaskType::TASK_TYPE_PRESENTATION;
  static const TaskType TASK_TYPE_SENSOR = TaskType::TASK_TYPE_SENSOR;
  static const TaskType TASK_TYPE_PERFORMANCE_TIMELINE = TaskType::TASK_TYPE_PERFORMANCE_TIMELINE;
  static const TaskType TASK_TYPE_WEB_GL = TaskType::TASK_TYPE_WEB_GL;
  static const TaskType TASK_TYPE_IDLE_TASK = TaskType::TASK_TYPE_IDLE_TASK;
  static const TaskType TASK_TYPE_MISC_PLATFORM_API = TaskType::TASK_TYPE_MISC_PLATFORM_API;
  static const TaskType TASK_TYPE_INTERNAL_DEFAULT = TaskType::TASK_TYPE_INTERNAL_DEFAULT;
  static const TaskType TASK_TYPE_INTERNAL_LOADING = TaskType::TASK_TYPE_INTERNAL_LOADING;
  static const TaskType TASK_TYPE_INTERNAL_TEST = TaskType::TASK_TYPE_INTERNAL_TEST;
  static const TaskType TASK_TYPE_INTERNAL_WEB_CRYPTO = TaskType::TASK_TYPE_INTERNAL_WEB_CRYPTO;
  static const TaskType TASK_TYPE_INTERNAL_MEDIA = TaskType::TASK_TYPE_INTERNAL_MEDIA;
  static const TaskType TASK_TYPE_INTERNAL_MEDIA_REALTIME = TaskType::TASK_TYPE_INTERNAL_MEDIA_REALTIME;
  static const TaskType TASK_TYPE_INTERNAL_USER_INTERACTION = TaskType::TASK_TYPE_INTERNAL_USER_INTERACTION;
  static const TaskType TASK_TYPE_INTERNAL_INSPECTOR = TaskType::TASK_TYPE_INTERNAL_INSPECTOR;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_V8 = TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_V8;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_COMPOSITOR = TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_COMPOSITOR;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_DEFAULT = TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_DEFAULT;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_INPUT = TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_INPUT;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IDLE = TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IDLE;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_CONTROL = TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_CONTROL;
  static const TaskType TASK_TYPE_INTERNAL_INTERSECTION_OBSERVER = TaskType::TASK_TYPE_INTERNAL_INTERSECTION_OBSERVER;
  static const TaskType TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_DEFAULT = TaskType::TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_DEFAULT;
  static const TaskType TASK_TYPE_WORKER_THREAD_TASK_QUEUE_DEFAULT = TaskType::TASK_TYPE_WORKER_THREAD_TASK_QUEUE_DEFAULT;
  static const TaskType TASK_TYPE_WORKER_THREAD_TASK_QUEUE_V8 = TaskType::TASK_TYPE_WORKER_THREAD_TASK_QUEUE_V8;
  static const TaskType TASK_TYPE_WORKER_THREAD_TASK_QUEUE_COMPOSITOR = TaskType::TASK_TYPE_WORKER_THREAD_TASK_QUEUE_COMPOSITOR;
  static const TaskType TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_INPUT = TaskType::TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_INPUT;
  static const TaskType TASK_TYPE_NETWORKING_WITH_URL_LOADER_ANNOTATION = TaskType::TASK_TYPE_NETWORKING_WITH_URL_LOADER_ANNOTATION;
  static const TaskType TASK_TYPE_WORKER_ANIMATION = TaskType::TASK_TYPE_WORKER_ANIMATION;
  static const TaskType TASK_TYPE_INTERNAL_TRANSLATION = TaskType::TASK_TYPE_INTERNAL_TRANSLATION;
  static const TaskType TASK_TYPE_FONT_LOADING = TaskType::TASK_TYPE_FONT_LOADING;
  static const TaskType TASK_TYPE_APPLICATION_LIFECYCLE = TaskType::TASK_TYPE_APPLICATION_LIFECYCLE;
  static const TaskType TASK_TYPE_BACKGROUND_FETCH = TaskType::TASK_TYPE_BACKGROUND_FETCH;
  static const TaskType TASK_TYPE_PERMISSION = TaskType::TASK_TYPE_PERMISSION;
  static const TaskType TASK_TYPE_SERVICE_WORKER_CLIENT_MESSAGE = TaskType::TASK_TYPE_SERVICE_WORKER_CLIENT_MESSAGE;
  static const TaskType TASK_TYPE_INTERNAL_CONTENT_CAPTURE = TaskType::TASK_TYPE_INTERNAL_CONTENT_CAPTURE;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_MEMORY_PURGE = TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_MEMORY_PURGE;
  static const TaskType TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED = TaskType::TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED;
  static const TaskType TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED_UNFREEZABLE = TaskType::TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED_UNFREEZABLE;
  static const TaskType TASK_TYPE_INTERNAL_CONTINUE_SCRIPT_LOADING = TaskType::TASK_TYPE_INTERNAL_CONTINUE_SCRIPT_LOADING;
  static const TaskType TASK_TYPE_WEB_LOCKS = TaskType::TASK_TYPE_WEB_LOCKS;
  static const TaskType TASK_TYPE_WEB_SCHEDULING_POSTED_TASK = TaskType::TASK_TYPE_WEB_SCHEDULING_POSTED_TASK;
  static const TaskType TASK_TYPE_INTERNAL_FRAME_LIFE_CYCLE_CONTROL = TaskType::TASK_TYPE_INTERNAL_FRAME_LIFE_CYCLE_CONTROL;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_NON_WAKING = TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_NON_WAKING;
  static const TaskType TASK_TYPE_INTERNAL_FIND_IN_PAGE = TaskType::TASK_TYPE_INTERNAL_FIND_IN_PAGE;
  static const TaskType TASK_TYPE_INTERNAL_HIGH_PRIORITY_LOCAL_FRAME = TaskType::TASK_TYPE_INTERNAL_HIGH_PRIORITY_LOCAL_FRAME;
  static const TaskType TASK_TYPE_JAVASCRIPT_TIMER_IMMEDIATE = TaskType::TASK_TYPE_JAVASCRIPT_TIMER_IMMEDIATE;
  static const TaskType TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_LOW_NESTING = TaskType::TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_LOW_NESTING;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IPC_TRACKING = TaskType::TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IPC_TRACKING;
  static const TaskType TASK_TYPE_NETWORKING_UNFREEZABLE = TaskType::TASK_TYPE_NETWORKING_UNFREEZABLE;
  static const TaskType TASK_TYPE_WAKE_LOCK = TaskType::TASK_TYPE_WAKE_LOCK;
  static const TaskType TASK_TYPE_INTERNAL_INPUT_BLOCKING = TaskType::TASK_TYPE_INTERNAL_INPUT_BLOCKING;
  static const TaskType TASK_TYPE_WEB_GPU = TaskType::TASK_TYPE_WEB_GPU;
  static const TaskType TASK_TYPE_INTERNAL_POST_MESSAGE_FORWARDING = TaskType::TASK_TYPE_INTERNAL_POST_MESSAGE_FORWARDING;
  static const TaskType TASK_TYPE_INTERNAL_NAVIGATION_CANCELLATION = TaskType::TASK_TYPE_INTERNAL_NAVIGATION_CANCELLATION;
  static const TaskType TASK_TYPE_LOW_PRIORITY_SCRIPT_EXECUTION = TaskType::TASK_TYPE_LOW_PRIORITY_SCRIPT_EXECUTION;
  static const TaskType TASK_TYPE_STORAGE = TaskType::TASK_TYPE_STORAGE;
  static const FrameType FRAME_TYPE_UNSPECIFIED = FrameType::FRAME_TYPE_UNSPECIFIED;
  static const FrameType FRAME_TYPE_MAIN_FRAME = FrameType::FRAME_TYPE_MAIN_FRAME;
  static const FrameType FRAME_TYPE_SAME_ORIGIN_SUBFRAME = FrameType::FRAME_TYPE_SAME_ORIGIN_SUBFRAME;
  static const FrameType FRAME_TYPE_CROSS_ORIGIN_SUBFRAME = FrameType::FRAME_TYPE_CROSS_ORIGIN_SUBFRAME;

  using FieldMetadata_TaskType =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType,
      RendererMainThreadTaskExecution>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TaskType kTaskType() { return {}; }
  void set_task_type(::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType value) {
    static constexpr uint32_t field_id = FieldMetadata_TaskType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrameVisible =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RendererMainThreadTaskExecution>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameVisible kFrameVisible() { return {}; }
  void set_frame_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameVisible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PageVisible =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RendererMainThreadTaskExecution>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PageVisible kPageVisible() { return {}; }
  void set_page_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_PageVisible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrameType =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType,
      RendererMainThreadTaskExecution>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameType kFrameType() { return {}; }
  void set_frame_type(::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsAdFrame =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RendererMainThreadTaskExecution>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsAdFrame kIsAdFrame() { return {}; }
  void set_is_ad_frame(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsAdFrame::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class BackForwardCacheCanStoreDocumentResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BackForwardCacheCanStoreDocumentResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BackForwardCacheCanStoreDocumentResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BackForwardCacheCanStoreDocumentResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_back_forward_cache_not_restored_reason() const { return at<1>().valid(); }
  int32_t back_forward_cache_not_restored_reason() const { return at<1>().as_int32(); }
};

class BackForwardCacheCanStoreDocumentResult : public ::protozero::Message {
 public:
  using Decoder = BackForwardCacheCanStoreDocumentResult_Decoder;
  enum : int32_t {
    kBackForwardCacheNotRestoredReasonFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BackForwardCacheCanStoreDocumentResult"; }


  using BackForwardCacheNotRestoredReason = ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason;
  static inline const char* BackForwardCacheNotRestoredReason_Name(BackForwardCacheNotRestoredReason value) {
    return ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_Name(value);
  }
  static const BackForwardCacheNotRestoredReason NOT_MAIN_FRAME = BackForwardCacheNotRestoredReason::NOT_MAIN_FRAME;
  static const BackForwardCacheNotRestoredReason BACK_FORWARD_CACHE_DISABLED = BackForwardCacheNotRestoredReason::BACK_FORWARD_CACHE_DISABLED;
  static const BackForwardCacheNotRestoredReason RELATED_ACTIVE_CONTENTS_EXIST = BackForwardCacheNotRestoredReason::RELATED_ACTIVE_CONTENTS_EXIST;
  static const BackForwardCacheNotRestoredReason HTTP_STATUS_NOT_OK = BackForwardCacheNotRestoredReason::HTTP_STATUS_NOT_OK;
  static const BackForwardCacheNotRestoredReason SCHEME_NOT_HTTP_OR_HTTPS = BackForwardCacheNotRestoredReason::SCHEME_NOT_HTTP_OR_HTTPS;
  static const BackForwardCacheNotRestoredReason LOADING = BackForwardCacheNotRestoredReason::LOADING;
  static const BackForwardCacheNotRestoredReason WAS_GRANTED_MEDIA_ACCESS = BackForwardCacheNotRestoredReason::WAS_GRANTED_MEDIA_ACCESS;
  static const BackForwardCacheNotRestoredReason BLOCKLISTED_FEATURES = BackForwardCacheNotRestoredReason::BLOCKLISTED_FEATURES;
  static const BackForwardCacheNotRestoredReason DISABLE_FOR_RENDER_FRAME_HOST_CALLED = BackForwardCacheNotRestoredReason::DISABLE_FOR_RENDER_FRAME_HOST_CALLED;
  static const BackForwardCacheNotRestoredReason DOMAIN_NOT_ALLOWED = BackForwardCacheNotRestoredReason::DOMAIN_NOT_ALLOWED;
  static const BackForwardCacheNotRestoredReason HTTP_METHOD_NOT_GET = BackForwardCacheNotRestoredReason::HTTP_METHOD_NOT_GET;
  static const BackForwardCacheNotRestoredReason SUBFRAME_IS_NAVIGATING = BackForwardCacheNotRestoredReason::SUBFRAME_IS_NAVIGATING;
  static const BackForwardCacheNotRestoredReason TIMEOUT = BackForwardCacheNotRestoredReason::TIMEOUT;
  static const BackForwardCacheNotRestoredReason CACHE_LIMIT = BackForwardCacheNotRestoredReason::CACHE_LIMIT;
  static const BackForwardCacheNotRestoredReason JAVASCRIPT_EXECUTION = BackForwardCacheNotRestoredReason::JAVASCRIPT_EXECUTION;
  static const BackForwardCacheNotRestoredReason RENDERER_PROCESS_KILLED = BackForwardCacheNotRestoredReason::RENDERER_PROCESS_KILLED;
  static const BackForwardCacheNotRestoredReason RENDERER_PROCESS_CRASHED = BackForwardCacheNotRestoredReason::RENDERER_PROCESS_CRASHED;
  static const BackForwardCacheNotRestoredReason GRANTED_MEDIA_STREAM_ACCESS = BackForwardCacheNotRestoredReason::GRANTED_MEDIA_STREAM_ACCESS;
  static const BackForwardCacheNotRestoredReason SCHEDULER_TRACKED_FEATURE_USED = BackForwardCacheNotRestoredReason::SCHEDULER_TRACKED_FEATURE_USED;
  static const BackForwardCacheNotRestoredReason CONFLICTING_BROWSING_INSTANCE = BackForwardCacheNotRestoredReason::CONFLICTING_BROWSING_INSTANCE;
  static const BackForwardCacheNotRestoredReason CACHE_FLUSHED = BackForwardCacheNotRestoredReason::CACHE_FLUSHED;
  static const BackForwardCacheNotRestoredReason SERVICE_WORKER_VERSION_ACTIVATION = BackForwardCacheNotRestoredReason::SERVICE_WORKER_VERSION_ACTIVATION;
  static const BackForwardCacheNotRestoredReason SESSION_RESTORED = BackForwardCacheNotRestoredReason::SESSION_RESTORED;
  static const BackForwardCacheNotRestoredReason UNKNOWN = BackForwardCacheNotRestoredReason::UNKNOWN;
  static const BackForwardCacheNotRestoredReason SERVICE_WORKER_POST_MESSAGE = BackForwardCacheNotRestoredReason::SERVICE_WORKER_POST_MESSAGE;
  static const BackForwardCacheNotRestoredReason ENTERED_BACK_FORWARD_CACHE_BEFORE_SERVICE_WORKER_HOST_ADDED = BackForwardCacheNotRestoredReason::ENTERED_BACK_FORWARD_CACHE_BEFORE_SERVICE_WORKER_HOST_ADDED;
  static const BackForwardCacheNotRestoredReason NOT_MOST_RECENT_NAVIGATION_ENTRY = BackForwardCacheNotRestoredReason::NOT_MOST_RECENT_NAVIGATION_ENTRY;
  static const BackForwardCacheNotRestoredReason SERVICE_WORKER_CLAIM = BackForwardCacheNotRestoredReason::SERVICE_WORKER_CLAIM;
  static const BackForwardCacheNotRestoredReason IGNORE_EVENT_AND_EVICT = BackForwardCacheNotRestoredReason::IGNORE_EVENT_AND_EVICT;
  static const BackForwardCacheNotRestoredReason HAVE_INNER_CONTENTS = BackForwardCacheNotRestoredReason::HAVE_INNER_CONTENTS;
  static const BackForwardCacheNotRestoredReason TIMEOUT_PUTTING_IN_CACHE = BackForwardCacheNotRestoredReason::TIMEOUT_PUTTING_IN_CACHE;
  static const BackForwardCacheNotRestoredReason BACK_FORWARD_CACHE_DISABLED_BY_LOW_MEMORY = BackForwardCacheNotRestoredReason::BACK_FORWARD_CACHE_DISABLED_BY_LOW_MEMORY;
  static const BackForwardCacheNotRestoredReason BACK_FORWARD_CACHE_DISABLED_BY_COMMAND_LINE = BackForwardCacheNotRestoredReason::BACK_FORWARD_CACHE_DISABLED_BY_COMMAND_LINE;
  static const BackForwardCacheNotRestoredReason NETWORK_REQUEST_REDIRECTED = BackForwardCacheNotRestoredReason::NETWORK_REQUEST_REDIRECTED;
  static const BackForwardCacheNotRestoredReason NETWORK_REQUEST_TIMEOUT = BackForwardCacheNotRestoredReason::NETWORK_REQUEST_TIMEOUT;
  static const BackForwardCacheNotRestoredReason NETWORK_EXCEEDS_BUFFER_LIMIT = BackForwardCacheNotRestoredReason::NETWORK_EXCEEDS_BUFFER_LIMIT;
  static const BackForwardCacheNotRestoredReason NAVIGATION_CANCELLED_WHILE_RESTORING = BackForwardCacheNotRestoredReason::NAVIGATION_CANCELLED_WHILE_RESTORING;
  static const BackForwardCacheNotRestoredReason BACK_FORWARD_CACHE_DISABLED_FOR_PRERENDER = BackForwardCacheNotRestoredReason::BACK_FORWARD_CACHE_DISABLED_FOR_PRERENDER;
  static const BackForwardCacheNotRestoredReason USER_AGENT_OVERRIDE_DIFFERS = BackForwardCacheNotRestoredReason::USER_AGENT_OVERRIDE_DIFFERS;
  static const BackForwardCacheNotRestoredReason NETWORK_REQUEST_DATAPIPE_DRAINED_AS_BYTES_CONSUMER = BackForwardCacheNotRestoredReason::NETWORK_REQUEST_DATAPIPE_DRAINED_AS_BYTES_CONSUMER;
  static const BackForwardCacheNotRestoredReason FOREGROUND_CACHE_LIMIT = BackForwardCacheNotRestoredReason::FOREGROUND_CACHE_LIMIT;
  static const BackForwardCacheNotRestoredReason BROWSING_INSTANCE_NOT_SWAPPED = BackForwardCacheNotRestoredReason::BROWSING_INSTANCE_NOT_SWAPPED;
  static const BackForwardCacheNotRestoredReason BACK_FORWARD_CACHE_DISABLED_FOR_DELEGATE = BackForwardCacheNotRestoredReason::BACK_FORWARD_CACHE_DISABLED_FOR_DELEGATE;
  static const BackForwardCacheNotRestoredReason OPT_IN_UNLOAD_HEADER_NOT_PRESENT = BackForwardCacheNotRestoredReason::OPT_IN_UNLOAD_HEADER_NOT_PRESENT;
  static const BackForwardCacheNotRestoredReason UNLOAD_HANDLER_EXISTS_IN_MAIN_FRAME = BackForwardCacheNotRestoredReason::UNLOAD_HANDLER_EXISTS_IN_MAIN_FRAME;
  static const BackForwardCacheNotRestoredReason UNLOAD_HANDLER_EXISTS_IN_SUBFRAME = BackForwardCacheNotRestoredReason::UNLOAD_HANDLER_EXISTS_IN_SUBFRAME;
  static const BackForwardCacheNotRestoredReason SERVICE_WORKER_UNREGISTRATION = BackForwardCacheNotRestoredReason::SERVICE_WORKER_UNREGISTRATION;
  static const BackForwardCacheNotRestoredReason CACHE_CONTROL_NO_STORE = BackForwardCacheNotRestoredReason::CACHE_CONTROL_NO_STORE;
  static const BackForwardCacheNotRestoredReason CACHE_CONTROL_NO_STORE_COOKIE_MODIFIED = BackForwardCacheNotRestoredReason::CACHE_CONTROL_NO_STORE_COOKIE_MODIFIED;
  static const BackForwardCacheNotRestoredReason CACHE_CONTROL_NO_STORE_HTTP_ONLY_COOKIE_MODIFIED = BackForwardCacheNotRestoredReason::CACHE_CONTROL_NO_STORE_HTTP_ONLY_COOKIE_MODIFIED;
  static const BackForwardCacheNotRestoredReason NO_RESPONSE_HEAD = BackForwardCacheNotRestoredReason::NO_RESPONSE_HEAD;
  static const BackForwardCacheNotRestoredReason ACTIVATION_NAVIGATION_DISALLOWED_FOR_BUG_1234857 = BackForwardCacheNotRestoredReason::ACTIVATION_NAVIGATION_DISALLOWED_FOR_BUG_1234857;
  static const BackForwardCacheNotRestoredReason ERROR_DOCUMENT = BackForwardCacheNotRestoredReason::ERROR_DOCUMENT;
  static const BackForwardCacheNotRestoredReason FENCED_FRAMES_EMBEDDER = BackForwardCacheNotRestoredReason::FENCED_FRAMES_EMBEDDER;

  using FieldMetadata_BackForwardCacheNotRestoredReason =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason,
      BackForwardCacheCanStoreDocumentResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BackForwardCacheNotRestoredReason kBackForwardCacheNotRestoredReason() { return {}; }
  void set_back_forward_cache_not_restored_reason(::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason value) {
    static constexpr uint32_t field_id = FieldMetadata_BackForwardCacheNotRestoredReason::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class ChromeThreadPoolTask_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeThreadPoolTask_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeThreadPoolTask_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeThreadPoolTask_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_task_priority() const { return at<1>().valid(); }
  int32_t task_priority() const { return at<1>().as_int32(); }
  bool has_execution_mode() const { return at<2>().valid(); }
  int32_t execution_mode() const { return at<2>().as_int32(); }
  bool has_sequence_token() const { return at<3>().valid(); }
  int64_t sequence_token() const { return at<3>().as_int64(); }
  bool has_shutdown_behavior() const { return at<4>().valid(); }
  int32_t shutdown_behavior() const { return at<4>().as_int32(); }
};

class ChromeThreadPoolTask : public ::protozero::Message {
 public:
  using Decoder = ChromeThreadPoolTask_Decoder;
  enum : int32_t {
    kTaskPriorityFieldNumber = 1,
    kExecutionModeFieldNumber = 2,
    kSequenceTokenFieldNumber = 3,
    kShutdownBehaviorFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeThreadPoolTask"; }


  using Priority = ::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority;
  static inline const char* Priority_Name(Priority value) {
    return ::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority_Name(value);
  }

  using ExecutionMode = ::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode;
  static inline const char* ExecutionMode_Name(ExecutionMode value) {
    return ::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode_Name(value);
  }

  using ShutdownBehavior = ::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior;
  static inline const char* ShutdownBehavior_Name(ShutdownBehavior value) {
    return ::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior_Name(value);
  }
  static const Priority PRIORITY_UNSPECIFIED = Priority::PRIORITY_UNSPECIFIED;
  static const Priority PRIORITY_BEST_EFFORT = Priority::PRIORITY_BEST_EFFORT;
  static const Priority PRIORITY_USER_VISIBLE = Priority::PRIORITY_USER_VISIBLE;
  static const Priority PRIORITY_USER_BLOCKING = Priority::PRIORITY_USER_BLOCKING;
  static const ExecutionMode EXECTUION_MODE_UNSPECIFIED = ExecutionMode::EXECTUION_MODE_UNSPECIFIED;
  static const ExecutionMode EXECUTION_MODE_PARALLEL = ExecutionMode::EXECUTION_MODE_PARALLEL;
  static const ExecutionMode EXECUTION_MODE_SEQUENCED = ExecutionMode::EXECUTION_MODE_SEQUENCED;
  static const ExecutionMode EXECUTION_MODE_SINGLE_THREAD = ExecutionMode::EXECUTION_MODE_SINGLE_THREAD;
  static const ExecutionMode EXECUTION_MODE_JOB = ExecutionMode::EXECUTION_MODE_JOB;
  static const ShutdownBehavior SHUTDOWN_BEHAVIOR_UNSPECIFIED = ShutdownBehavior::SHUTDOWN_BEHAVIOR_UNSPECIFIED;
  static const ShutdownBehavior SHUTDOWN_BEHAVIOR_CONTINUE_ON_SHUTDOWN = ShutdownBehavior::SHUTDOWN_BEHAVIOR_CONTINUE_ON_SHUTDOWN;
  static const ShutdownBehavior SHUTDOWN_BEHAVIOR_SKIP_ON_SHUTDOWN = ShutdownBehavior::SHUTDOWN_BEHAVIOR_SKIP_ON_SHUTDOWN;
  static const ShutdownBehavior SHUTDOWN_BEHAVIOR_BLOCK_SHUTDOWN = ShutdownBehavior::SHUTDOWN_BEHAVIOR_BLOCK_SHUTDOWN;

  using FieldMetadata_TaskPriority =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority,
      ChromeThreadPoolTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TaskPriority kTaskPriority() { return {}; }
  void set_task_priority(::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority value) {
    static constexpr uint32_t field_id = FieldMetadata_TaskPriority::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ExecutionMode =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode,
      ChromeThreadPoolTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ExecutionMode kExecutionMode() { return {}; }
  void set_execution_mode(::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode value) {
    static constexpr uint32_t field_id = FieldMetadata_ExecutionMode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SequenceToken =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      ChromeThreadPoolTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SequenceToken kSequenceToken() { return {}; }
  void set_sequence_token(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SequenceToken::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShutdownBehavior =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior,
      ChromeThreadPoolTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ShutdownBehavior kShutdownBehavior() { return {}; }
  void set_shutdown_behavior(::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior value) {
    static constexpr uint32_t field_id = FieldMetadata_ShutdownBehavior::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class RenderFrameHost_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RenderFrameHost_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderFrameHost_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderFrameHost_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_process() const { return at<1>().valid(); }
  ::protozero::ConstBytes process() const { return at<1>().as_bytes(); }
  bool has_render_frame_host_id() const { return at<2>().valid(); }
  ::protozero::ConstBytes render_frame_host_id() const { return at<2>().as_bytes(); }
  bool has_lifecycle_state() const { return at<3>().valid(); }
  int32_t lifecycle_state() const { return at<3>().as_int32(); }
  bool has_origin() const { return at<4>().valid(); }
  ::protozero::ConstChars origin() const { return at<4>().as_string(); }
  bool has_url() const { return at<5>().valid(); }
  ::protozero::ConstChars url() const { return at<5>().as_string(); }
  bool has_frame_tree_node_id() const { return at<6>().valid(); }
  uint64_t frame_tree_node_id() const { return at<6>().as_uint64(); }
  bool has_site_instance() const { return at<7>().valid(); }
  ::protozero::ConstBytes site_instance() const { return at<7>().as_bytes(); }
  bool has_parent() const { return at<8>().valid(); }
  ::protozero::ConstBytes parent() const { return at<8>().as_bytes(); }
  bool has_outer_document() const { return at<9>().valid(); }
  ::protozero::ConstBytes outer_document() const { return at<9>().as_bytes(); }
  bool has_embedder() const { return at<10>().valid(); }
  ::protozero::ConstBytes embedder() const { return at<10>().as_bytes(); }
  bool has_browsing_context_state() const { return at<11>().valid(); }
  ::protozero::ConstBytes browsing_context_state() const { return at<11>().as_bytes(); }
  bool has_frame_type() const { return at<12>().valid(); }
  int32_t frame_type() const { return at<12>().as_int32(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class RenderFrameHost : public ::protozero::Message {
 public:
  using Decoder = RenderFrameHost_Decoder;
  enum : int32_t {
    kProcessFieldNumber = 1,
    kRenderFrameHostIdFieldNumber = 2,
    kLifecycleStateFieldNumber = 3,
    kOriginFieldNumber = 4,
    kUrlFieldNumber = 5,
    kFrameTreeNodeIdFieldNumber = 6,
    kSiteInstanceFieldNumber = 7,
    kParentFieldNumber = 8,
    kOuterDocumentFieldNumber = 9,
    kEmbedderFieldNumber = 10,
    kBrowsingContextStateFieldNumber = 11,
    kFrameTypeFieldNumber = 12,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderFrameHost"; }


  using LifecycleState = ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState;
  static inline const char* LifecycleState_Name(LifecycleState value) {
    return ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState_Name(value);
  }
  static const LifecycleState UNSPECIFIED = LifecycleState::UNSPECIFIED;
  static const LifecycleState SPECULATIVE = LifecycleState::SPECULATIVE;
  static const LifecycleState PENDING_COMMIT = LifecycleState::PENDING_COMMIT;
  static const LifecycleState PRERENDERING = LifecycleState::PRERENDERING;
  static const LifecycleState ACTIVE = LifecycleState::ACTIVE;
  static const LifecycleState IN_BACK_FORWARD_CACHE = LifecycleState::IN_BACK_FORWARD_CACHE;
  static const LifecycleState RUNNING_UNLOAD_HANDLERS = LifecycleState::RUNNING_UNLOAD_HANDLERS;
  static const LifecycleState READY_TO_BE_DELETED = LifecycleState::READY_TO_BE_DELETED;

  using FieldMetadata_Process =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHost,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Process kProcess() { return {}; }
  template <typename T = RenderProcessHost> T* set_process() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_RenderFrameHostId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      GlobalRenderFrameHostId,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderFrameHostId kRenderFrameHostId() { return {}; }
  template <typename T = GlobalRenderFrameHostId> T* set_render_frame_host_id() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_LifecycleState =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LifecycleState kLifecycleState() { return {}; }
  void set_lifecycle_state(::perfetto::protos::pbzero::RenderFrameHost_LifecycleState value) {
    static constexpr uint32_t field_id = FieldMetadata_LifecycleState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Origin =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Origin kOrigin() { return {}; }
  void set_origin(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Origin::kFieldId, data, size);
  }
  void set_origin(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Origin::kFieldId, chars.data, chars.size);
  }
  void set_origin(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Origin::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Url =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Url kUrl() { return {}; }
  void set_url(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Url::kFieldId, data, size);
  }
  void set_url(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Url::kFieldId, chars.data, chars.size);
  }
  void set_url(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Url::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrameTreeNodeId =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNodeId kFrameTreeNodeId() { return {}; }
  void set_frame_tree_node_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameTreeNodeId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SiteInstance =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SiteInstance,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstance kSiteInstance() { return {}; }
  template <typename T = SiteInstance> T* set_site_instance() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_Parent =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Parent kParent() { return {}; }
  template <typename T = RenderFrameHost> T* set_parent() {
    return BeginNestedMessage<T>(8);
  }


  using FieldMetadata_OuterDocument =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_OuterDocument kOuterDocument() { return {}; }
  template <typename T = RenderFrameHost> T* set_outer_document() {
    return BeginNestedMessage<T>(9);
  }


  using FieldMetadata_Embedder =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Embedder kEmbedder() { return {}; }
  template <typename T = RenderFrameHost> T* set_embedder() {
    return BeginNestedMessage<T>(10);
  }


  using FieldMetadata_BrowsingContextState =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BrowsingContextState,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BrowsingContextState kBrowsingContextState() { return {}; }
  template <typename T = BrowsingContextState> T* set_browsing_context_state() {
    return BeginNestedMessage<T>(11);
  }


  using FieldMetadata_FrameType =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameType kFrameType() { return {}; }
  void set_frame_type(::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class BrowsingContextState_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  BrowsingContextState_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BrowsingContextState_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BrowsingContextState_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_browsing_instance_id() const { return at<1>().valid(); }
  int32_t browsing_instance_id() const { return at<1>().as_int32(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class BrowsingContextState : public ::protozero::Message {
 public:
  using Decoder = BrowsingContextState_Decoder;
  enum : int32_t {
    kBrowsingInstanceIdFieldNumber = 1,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BrowsingContextState"; }


  using FieldMetadata_BrowsingInstanceId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      BrowsingContextState>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BrowsingInstanceId kBrowsingInstanceId() { return {}; }
  void set_browsing_instance_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BrowsingInstanceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      BrowsingContextState>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class GlobalRenderFrameHostId_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GlobalRenderFrameHostId_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GlobalRenderFrameHostId_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GlobalRenderFrameHostId_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_routing_id() const { return at<1>().valid(); }
  int32_t routing_id() const { return at<1>().as_int32(); }
  bool has_process_id() const { return at<2>().valid(); }
  int32_t process_id() const { return at<2>().as_int32(); }
};

class GlobalRenderFrameHostId : public ::protozero::Message {
 public:
  using Decoder = GlobalRenderFrameHostId_Decoder;
  enum : int32_t {
    kRoutingIdFieldNumber = 1,
    kProcessIdFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.GlobalRenderFrameHostId"; }


  using FieldMetadata_RoutingId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      GlobalRenderFrameHostId>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RoutingId kRoutingId() { return {}; }
  void set_routing_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RoutingId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ProcessId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      GlobalRenderFrameHostId>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProcessId kProcessId() { return {}; }
  void set_process_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ProcessId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class SendBeginMainFrameToCommitBreakdown_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/12, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SendBeginMainFrameToCommitBreakdown_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SendBeginMainFrameToCommitBreakdown_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SendBeginMainFrameToCommitBreakdown_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_handle_input_events_us() const { return at<1>().valid(); }
  uint64_t handle_input_events_us() const { return at<1>().as_uint64(); }
  bool has_animate_us() const { return at<2>().valid(); }
  uint64_t animate_us() const { return at<2>().as_uint64(); }
  bool has_style_update_us() const { return at<3>().valid(); }
  uint64_t style_update_us() const { return at<3>().as_uint64(); }
  bool has_layout_update_us() const { return at<4>().valid(); }
  uint64_t layout_update_us() const { return at<4>().as_uint64(); }
  bool has_accessibility_update_us() const { return at<12>().valid(); }
  uint64_t accessibility_update_us() const { return at<12>().as_uint64(); }
  bool has_prepaint_us() const { return at<5>().valid(); }
  uint64_t prepaint_us() const { return at<5>().as_uint64(); }
  bool has_compositing_inputs_us() const { return at<6>().valid(); }
  uint64_t compositing_inputs_us() const { return at<6>().as_uint64(); }
  bool has_compositing_assignments_us() const { return at<7>().valid(); }
  uint64_t compositing_assignments_us() const { return at<7>().as_uint64(); }
  bool has_paint_us() const { return at<8>().valid(); }
  uint64_t paint_us() const { return at<8>().as_uint64(); }
  bool has_composite_commit_us() const { return at<9>().valid(); }
  uint64_t composite_commit_us() const { return at<9>().as_uint64(); }
  bool has_update_layers_us() const { return at<10>().valid(); }
  uint64_t update_layers_us() const { return at<10>().as_uint64(); }
  bool has_begin_main_sent_to_started_us() const { return at<11>().valid(); }
  uint64_t begin_main_sent_to_started_us() const { return at<11>().as_uint64(); }
};

class SendBeginMainFrameToCommitBreakdown : public ::protozero::Message {
 public:
  using Decoder = SendBeginMainFrameToCommitBreakdown_Decoder;
  enum : int32_t {
    kHandleInputEventsUsFieldNumber = 1,
    kAnimateUsFieldNumber = 2,
    kStyleUpdateUsFieldNumber = 3,
    kLayoutUpdateUsFieldNumber = 4,
    kAccessibilityUpdateUsFieldNumber = 12,
    kPrepaintUsFieldNumber = 5,
    kCompositingInputsUsFieldNumber = 6,
    kCompositingAssignmentsUsFieldNumber = 7,
    kPaintUsFieldNumber = 8,
    kCompositeCommitUsFieldNumber = 9,
    kUpdateLayersUsFieldNumber = 10,
    kBeginMainSentToStartedUsFieldNumber = 11,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SendBeginMainFrameToCommitBreakdown"; }


  using FieldMetadata_HandleInputEventsUs =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HandleInputEventsUs kHandleInputEventsUs() { return {}; }
  void set_handle_input_events_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_HandleInputEventsUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AnimateUs =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AnimateUs kAnimateUs() { return {}; }
  void set_animate_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_AnimateUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StyleUpdateUs =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_StyleUpdateUs kStyleUpdateUs() { return {}; }
  void set_style_update_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_StyleUpdateUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LayoutUpdateUs =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LayoutUpdateUs kLayoutUpdateUs() { return {}; }
  void set_layout_update_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LayoutUpdateUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AccessibilityUpdateUs =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AccessibilityUpdateUs kAccessibilityUpdateUs() { return {}; }
  void set_accessibility_update_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_AccessibilityUpdateUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PrepaintUs =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PrepaintUs kPrepaintUs() { return {}; }
  void set_prepaint_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_PrepaintUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CompositingInputsUs =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CompositingInputsUs kCompositingInputsUs() { return {}; }
  void set_compositing_inputs_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CompositingInputsUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CompositingAssignmentsUs =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CompositingAssignmentsUs kCompositingAssignmentsUs() { return {}; }
  void set_compositing_assignments_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CompositingAssignmentsUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PaintUs =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PaintUs kPaintUs() { return {}; }
  void set_paint_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_PaintUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CompositeCommitUs =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CompositeCommitUs kCompositeCommitUs() { return {}; }
  void set_composite_commit_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CompositeCommitUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_UpdateLayersUs =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_UpdateLayersUs kUpdateLayersUs() { return {}; }
  void set_update_layers_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_UpdateLayersUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_BeginMainSentToStartedUs =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BeginMainSentToStartedUs kBeginMainSentToStartedUs() { return {}; }
  void set_begin_main_sent_to_started_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BeginMainSentToStartedUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class ChromeSamplingProfilerSampleCollected_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeSamplingProfilerSampleCollected_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeSamplingProfilerSampleCollected_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeSamplingProfilerSampleCollected_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_frame_count() const { return at<1>().valid(); }
  int32_t frame_count() const { return at<1>().as_int32(); }
  bool has_write_status() const { return at<2>().valid(); }
  int32_t write_status() const { return at<2>().as_int32(); }
  bool has_sampled_thread_id() const { return at<3>().valid(); }
  int32_t sampled_thread_id() const { return at<3>().as_int32(); }
};

class ChromeSamplingProfilerSampleCollected : public ::protozero::Message {
 public:
  using Decoder = ChromeSamplingProfilerSampleCollected_Decoder;
  enum : int32_t {
    kFrameCountFieldNumber = 1,
    kWriteStatusFieldNumber = 2,
    kSampledThreadIdFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeSamplingProfilerSampleCollected"; }


  using WriteStatus = ::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus;
  static inline const char* WriteStatus_Name(WriteStatus value) {
    return ::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus_Name(value);
  }
  static const WriteStatus WRITE_STATUS_NONE = WriteStatus::WRITE_STATUS_NONE;
  static const WriteStatus WRITE_STATUS_BUFFERING_SAMPLE = WriteStatus::WRITE_STATUS_BUFFERING_SAMPLE;
  static const WriteStatus WRITE_STATUS_WRITING_BUFFERED = WriteStatus::WRITE_STATUS_WRITING_BUFFERED;
  static const WriteStatus WRITE_STATUS_WRITING_TO_TRACE = WriteStatus::WRITE_STATUS_WRITING_TO_TRACE;

  using FieldMetadata_FrameCount =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ChromeSamplingProfilerSampleCollected>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameCount kFrameCount() { return {}; }
  void set_frame_count(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WriteStatus =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus,
      ChromeSamplingProfilerSampleCollected>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WriteStatus kWriteStatus() { return {}; }
  void set_write_status(::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus value) {
    static constexpr uint32_t field_id = FieldMetadata_WriteStatus::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SampledThreadId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ChromeSamplingProfilerSampleCollected>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SampledThreadId kSampledThreadId() { return {}; }
  void set_sampled_thread_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SampledThreadId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class ParkableStringUnpark_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ParkableStringUnpark_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ParkableStringUnpark_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ParkableStringUnpark_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_size_bytes() const { return at<1>().valid(); }
  int32_t size_bytes() const { return at<1>().as_int32(); }
  bool has_time_since_last_disk_write_sec() const { return at<2>().valid(); }
  int32_t time_since_last_disk_write_sec() const { return at<2>().as_int32(); }
};

class ParkableStringUnpark : public ::protozero::Message {
 public:
  using Decoder = ParkableStringUnpark_Decoder;
  enum : int32_t {
    kSizeBytesFieldNumber = 1,
    kTimeSinceLastDiskWriteSecFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ParkableStringUnpark"; }


  using FieldMetadata_SizeBytes =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ParkableStringUnpark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SizeBytes kSizeBytes() { return {}; }
  void set_size_bytes(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SizeBytes::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TimeSinceLastDiskWriteSec =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ParkableStringUnpark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TimeSinceLastDiskWriteSec kTimeSinceLastDiskWriteSec() { return {}; }
  void set_time_since_last_disk_write_sec(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TimeSinceLastDiskWriteSec::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class ParkableStringCompressInBackground_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ParkableStringCompressInBackground_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ParkableStringCompressInBackground_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ParkableStringCompressInBackground_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_size_bytes() const { return at<1>().valid(); }
  int32_t size_bytes() const { return at<1>().as_int32(); }
};

class ParkableStringCompressInBackground : public ::protozero::Message {
 public:
  using Decoder = ParkableStringCompressInBackground_Decoder;
  enum : int32_t {
    kSizeBytesFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ParkableStringCompressInBackground"; }


  using FieldMetadata_SizeBytes =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ParkableStringCompressInBackground>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SizeBytes kSizeBytes() { return {}; }
  void set_size_bytes(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SizeBytes::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class AndroidViewDump_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidViewDump_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidViewDump_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidViewDump_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_activity() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> activity() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class AndroidViewDump : public ::protozero::Message {
 public:
  using Decoder = AndroidViewDump_Decoder;
  enum : int32_t {
    kActivityFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.AndroidViewDump"; }


  using FieldMetadata_Activity =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AndroidActivity,
      AndroidViewDump>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Activity kActivity() { return {}; }
  template <typename T = AndroidActivity> T* add_activity() {
    return BeginNestedMessage<T>(1);
  }

};

class AndroidActivity_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidActivity_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidActivity_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidActivity_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_view() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> view() const { return GetRepeated<::protozero::ConstBytes>(2); }
};

class AndroidActivity : public ::protozero::Message {
 public:
  using Decoder = AndroidActivity_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kViewFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.AndroidActivity"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      AndroidActivity>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Name kName() { return {}; }
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_View =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AndroidView,
      AndroidActivity>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_View kView() { return {}; }
  template <typename T = AndroidView> T* add_view() {
    return BeginNestedMessage<T>(2);
  }

};

class AndroidView_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AndroidView_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidView_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidView_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  int32_t id() const { return at<1>().as_int32(); }
  bool has_parent_id() const { return at<2>().valid(); }
  int32_t parent_id() const { return at<2>().as_int32(); }
  bool has_is_shown() const { return at<3>().valid(); }
  bool is_shown() const { return at<3>().as_bool(); }
  bool has_is_dirty() const { return at<4>().valid(); }
  bool is_dirty() const { return at<4>().as_bool(); }
  bool has_class_name() const { return at<5>().valid(); }
  ::protozero::ConstChars class_name() const { return at<5>().as_string(); }
  bool has_resource_name() const { return at<6>().valid(); }
  ::protozero::ConstChars resource_name() const { return at<6>().as_string(); }
};

class AndroidView : public ::protozero::Message {
 public:
  using Decoder = AndroidView_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kParentIdFieldNumber = 2,
    kIsShownFieldNumber = 3,
    kIsDirtyFieldNumber = 4,
    kClassNameFieldNumber = 5,
    kResourceNameFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.AndroidView"; }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Id kId() { return {}; }
  void set_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ParentId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ParentId kParentId() { return {}; }
  void set_parent_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ParentId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsShown =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsShown kIsShown() { return {}; }
  void set_is_shown(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsShown::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsDirty =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsDirty kIsDirty() { return {}; }
  void set_is_dirty(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsDirty::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ClassName =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ClassName kClassName() { return {}; }
  void set_class_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ClassName::kFieldId, data, size);
  }
  void set_class_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ClassName::kFieldId, chars.data, chars.size);
  }
  void set_class_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ClassName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ResourceName =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ResourceName kResourceName() { return {}; }
  void set_resource_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ResourceName::kFieldId, data, size);
  }
  void set_resource_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ResourceName::kFieldId, chars.data, chars.size);
  }
  void set_resource_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ResourceName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class RenderFrameProxyHost_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RenderFrameProxyHost_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderFrameProxyHost_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderFrameProxyHost_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_routing_id() const { return at<1>().valid(); }
  int32_t routing_id() const { return at<1>().as_int32(); }
  bool has_process_id() const { return at<2>().valid(); }
  int32_t process_id() const { return at<2>().as_int32(); }
  bool has_rvh_map_id() const { return at<3>().valid(); }
  int32_t rvh_map_id() const { return at<3>().as_int32(); }
  bool has_site_instance_id() const { return at<4>().valid(); }
  int32_t site_instance_id() const { return at<4>().as_int32(); }
  bool has_is_render_frame_proxy_live() const { return at<5>().valid(); }
  bool is_render_frame_proxy_live() const { return at<5>().as_bool(); }
  bool has_site_instance_group_id() const { return at<6>().valid(); }
  int32_t site_instance_group_id() const { return at<6>().as_int32(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class RenderFrameProxyHost : public ::protozero::Message {
 public:
  using Decoder = RenderFrameProxyHost_Decoder;
  enum : int32_t {
    kRoutingIdFieldNumber = 1,
    kProcessIdFieldNumber = 2,
    kRvhMapIdFieldNumber = 3,
    kSiteInstanceIdFieldNumber = 4,
    kIsRenderFrameProxyLiveFieldNumber = 5,
    kSiteInstanceGroupIdFieldNumber = 6,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderFrameProxyHost"; }


  using FieldMetadata_RoutingId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RoutingId kRoutingId() { return {}; }
  void set_routing_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RoutingId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ProcessId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProcessId kProcessId() { return {}; }
  void set_process_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ProcessId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RvhMapId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RvhMapId kRvhMapId() { return {}; }
  void set_rvh_map_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RvhMapId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SiteInstanceId =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceId kSiteInstanceId() { return {}; }
  void set_site_instance_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SiteInstanceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsRenderFrameProxyLive =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsRenderFrameProxyLive kIsRenderFrameProxyLive() { return {}; }
  void set_is_render_frame_proxy_live(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsRenderFrameProxyLive::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SiteInstanceGroupId =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceGroupId kSiteInstanceGroupId() { return {}; }
  void set_site_instance_group_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SiteInstanceGroupId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class RenderViewHost_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RenderViewHost_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderViewHost_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderViewHost_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_rvh_map_id() const { return at<1>().valid(); }
  int32_t rvh_map_id() const { return at<1>().as_int32(); }
  bool has_routing_id() const { return at<2>().valid(); }
  int32_t routing_id() const { return at<2>().as_int32(); }
  bool has_process_id() const { return at<3>().valid(); }
  int32_t process_id() const { return at<3>().as_int32(); }
  bool has_process() const { return at<6>().valid(); }
  ::protozero::ConstBytes process() const { return at<6>().as_bytes(); }
  bool has_is_in_back_forward_cache() const { return at<4>().valid(); }
  bool is_in_back_forward_cache() const { return at<4>().as_bool(); }
  bool has_renderer_view_created() const { return at<5>().valid(); }
  bool renderer_view_created() const { return at<5>().as_bool(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class RenderViewHost : public ::protozero::Message {
 public:
  using Decoder = RenderViewHost_Decoder;
  enum : int32_t {
    kRvhMapIdFieldNumber = 1,
    kRoutingIdFieldNumber = 2,
    kProcessIdFieldNumber = 3,
    kProcessFieldNumber = 6,
    kIsInBackForwardCacheFieldNumber = 4,
    kRendererViewCreatedFieldNumber = 5,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderViewHost"; }


  using FieldMetadata_RvhMapId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RvhMapId kRvhMapId() { return {}; }
  void set_rvh_map_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RvhMapId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RoutingId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RoutingId kRoutingId() { return {}; }
  void set_routing_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RoutingId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ProcessId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProcessId kProcessId() { return {}; }
  void set_process_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ProcessId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Process =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHost,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Process kProcess() { return {}; }
  template <typename T = RenderProcessHost> T* set_process() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_IsInBackForwardCache =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsInBackForwardCache kIsInBackForwardCache() { return {}; }
  void set_is_in_back_forward_cache(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsInBackForwardCache::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RendererViewCreated =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RendererViewCreated kRendererViewCreated() { return {}; }
  void set_renderer_view_created(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_RendererViewCreated::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class SiteInstanceGroup_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  SiteInstanceGroup_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SiteInstanceGroup_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SiteInstanceGroup_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_site_instance_group_id() const { return at<1>().valid(); }
  int32_t site_instance_group_id() const { return at<1>().as_int32(); }
  bool has_active_frame_count() const { return at<2>().valid(); }
  int32_t active_frame_count() const { return at<2>().as_int32(); }
  bool has_process() const { return at<3>().valid(); }
  ::protozero::ConstBytes process() const { return at<3>().as_bytes(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class SiteInstanceGroup : public ::protozero::Message {
 public:
  using Decoder = SiteInstanceGroup_Decoder;
  enum : int32_t {
    kSiteInstanceGroupIdFieldNumber = 1,
    kActiveFrameCountFieldNumber = 2,
    kProcessFieldNumber = 3,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SiteInstanceGroup"; }


  using FieldMetadata_SiteInstanceGroupId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstanceGroup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceGroupId kSiteInstanceGroupId() { return {}; }
  void set_site_instance_group_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SiteInstanceGroupId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ActiveFrameCount =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstanceGroup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ActiveFrameCount kActiveFrameCount() { return {}; }
  void set_active_frame_count(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ActiveFrameCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Process =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHost,
      SiteInstanceGroup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Process kProcess() { return {}; }
  template <typename T = RenderProcessHost> T* set_process() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      SiteInstanceGroup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class SiteInstance_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  SiteInstance_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SiteInstance_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SiteInstance_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_site_instance_id() const { return at<1>().valid(); }
  int32_t site_instance_id() const { return at<1>().as_int32(); }
  bool has_browsing_instance_id() const { return at<2>().valid(); }
  int32_t browsing_instance_id() const { return at<2>().as_int32(); }
  bool has_is_default() const { return at<3>().valid(); }
  bool is_default() const { return at<3>().as_bool(); }
  bool has_has_process() const { return at<4>().valid(); }
  bool has_process() const { return at<4>().as_bool(); }
  bool has_related_active_contents_count() const { return at<5>().valid(); }
  int32_t related_active_contents_count() const { return at<5>().as_int32(); }
  bool has_active_rfh_count() const { return at<6>().valid(); }
  int32_t active_rfh_count() const { return at<6>().as_int32(); }
  bool has_site_instance_group() const { return at<7>().valid(); }
  ::protozero::ConstBytes site_instance_group() const { return at<7>().as_bytes(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class SiteInstance : public ::protozero::Message {
 public:
  using Decoder = SiteInstance_Decoder;
  enum : int32_t {
    kSiteInstanceIdFieldNumber = 1,
    kBrowsingInstanceIdFieldNumber = 2,
    kIsDefaultFieldNumber = 3,
    kHasProcessFieldNumber = 4,
    kRelatedActiveContentsCountFieldNumber = 5,
    kActiveRfhCountFieldNumber = 6,
    kSiteInstanceGroupFieldNumber = 7,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SiteInstance"; }


  using FieldMetadata_SiteInstanceId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceId kSiteInstanceId() { return {}; }
  void set_site_instance_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SiteInstanceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_BrowsingInstanceId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BrowsingInstanceId kBrowsingInstanceId() { return {}; }
  void set_browsing_instance_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BrowsingInstanceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsDefault =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsDefault kIsDefault() { return {}; }
  void set_is_default(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsDefault::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasProcess =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasProcess kHasProcess() { return {}; }
  void set_has_process(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasProcess::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RelatedActiveContentsCount =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RelatedActiveContentsCount kRelatedActiveContentsCount() { return {}; }
  void set_related_active_contents_count(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RelatedActiveContentsCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ActiveRfhCount =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ActiveRfhCount kActiveRfhCount() { return {}; }
  void set_active_rfh_count(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ActiveRfhCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SiteInstanceGroup =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SiteInstanceGroup,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceGroup kSiteInstanceGroup() { return {}; }
  template <typename T = SiteInstanceGroup> T* set_site_instance_group() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class ChromeExtensionId_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeExtensionId_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeExtensionId_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeExtensionId_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_extension_id() const { return at<1>().valid(); }
  ::protozero::ConstChars extension_id() const { return at<1>().as_string(); }
  bool has_pseudonymized_extension_id() const { return at<2>().valid(); }
  uint32_t pseudonymized_extension_id() const { return at<2>().as_uint32(); }
};

class ChromeExtensionId : public ::protozero::Message {
 public:
  using Decoder = ChromeExtensionId_Decoder;
  enum : int32_t {
    kExtensionIdFieldNumber = 1,
    kPseudonymizedExtensionIdFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeExtensionId"; }


  using FieldMetadata_ExtensionId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeExtensionId>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ExtensionId kExtensionId() { return {}; }
  void set_extension_id(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ExtensionId::kFieldId, data, size);
  }
  void set_extension_id(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ExtensionId::kFieldId, chars.data, chars.size);
  }
  void set_extension_id(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ExtensionId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PseudonymizedExtensionId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeExtensionId>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PseudonymizedExtensionId kPseudonymizedExtensionId() { return {}; }
  void set_pseudonymized_extension_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_PseudonymizedExtensionId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class ChildProcessLauncherPriority_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChildProcessLauncherPriority_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChildProcessLauncherPriority_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChildProcessLauncherPriority_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_is_backgrounded() const { return at<1>().valid(); }
  bool is_backgrounded() const { return at<1>().as_bool(); }
  bool has_has_pending_views() const { return at<2>().valid(); }
  bool has_pending_views() const { return at<2>().as_bool(); }
  bool has_importance() const { return at<3>().valid(); }
  int32_t importance() const { return at<3>().as_int32(); }
};

class ChildProcessLauncherPriority : public ::protozero::Message {
 public:
  using Decoder = ChildProcessLauncherPriority_Decoder;
  enum : int32_t {
    kIsBackgroundedFieldNumber = 1,
    kHasPendingViewsFieldNumber = 2,
    kImportanceFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChildProcessLauncherPriority"; }


  using Importance = ::perfetto::protos::pbzero::ChildProcessLauncherPriority_Importance;
  static inline const char* Importance_Name(Importance value) {
    return ::perfetto::protos::pbzero::ChildProcessLauncherPriority_Importance_Name(value);
  }
  static const Importance IMPORTANCE_NORMAL = Importance::IMPORTANCE_NORMAL;
  static const Importance IMPORTANCE_MODERATE = Importance::IMPORTANCE_MODERATE;
  static const Importance IMPORTANCE_IMPORTANT = Importance::IMPORTANCE_IMPORTANT;

  using FieldMetadata_IsBackgrounded =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChildProcessLauncherPriority>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsBackgrounded kIsBackgrounded() { return {}; }
  void set_is_backgrounded(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsBackgrounded::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasPendingViews =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChildProcessLauncherPriority>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasPendingViews kHasPendingViews() { return {}; }
  void set_has_pending_views(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasPendingViews::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Importance =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChildProcessLauncherPriority_Importance,
      ChildProcessLauncherPriority>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Importance kImportance() { return {}; }
  void set_importance(::perfetto::protos::pbzero::ChildProcessLauncherPriority_Importance value) {
    static constexpr uint32_t field_id = FieldMetadata_Importance::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class RenderProcessHostCleanup_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RenderProcessHostCleanup_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderProcessHostCleanup_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderProcessHostCleanup_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_listener_count() const { return at<1>().valid(); }
  uint32_t listener_count() const { return at<1>().as_uint32(); }
  bool has_keep_alive_ref_count() const { return at<2>().valid(); }
  uint32_t keep_alive_ref_count() const { return at<2>().as_uint32(); }
  bool has_shutdown_delay_ref_count() const { return at<3>().valid(); }
  uint32_t shutdown_delay_ref_count() const { return at<3>().as_uint32(); }
  bool has_worker_ref_count() const { return at<4>().valid(); }
  uint32_t worker_ref_count() const { return at<4>().as_uint32(); }
};

class RenderProcessHostCleanup : public ::protozero::Message {
 public:
  using Decoder = RenderProcessHostCleanup_Decoder;
  enum : int32_t {
    kListenerCountFieldNumber = 1,
    kKeepAliveRefCountFieldNumber = 2,
    kShutdownDelayRefCountFieldNumber = 3,
    kWorkerRefCountFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderProcessHostCleanup"; }


  using FieldMetadata_ListenerCount =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHostCleanup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ListenerCount kListenerCount() { return {}; }
  void set_listener_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ListenerCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeepAliveRefCount =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHostCleanup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KeepAliveRefCount kKeepAliveRefCount() { return {}; }
  void set_keep_alive_ref_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_KeepAliveRefCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShutdownDelayRefCount =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHostCleanup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ShutdownDelayRefCount kShutdownDelayRefCount() { return {}; }
  void set_shutdown_delay_ref_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ShutdownDelayRefCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WorkerRefCount =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHostCleanup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WorkerRefCount kWorkerRefCount() { return {}; }
  void set_worker_ref_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_WorkerRefCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class RenderProcessHostListener_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RenderProcessHostListener_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderProcessHostListener_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderProcessHostListener_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_routing_id() const { return at<1>().valid(); }
  uint32_t routing_id() const { return at<1>().as_uint32(); }
};

class RenderProcessHostListener : public ::protozero::Message {
 public:
  using Decoder = RenderProcessHostListener_Decoder;
  enum : int32_t {
    kRoutingIdFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderProcessHostListener"; }


  using FieldMetadata_RoutingId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHostListener>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RoutingId kRoutingId() { return {}; }
  void set_routing_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RoutingId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class RenderProcessHost_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RenderProcessHost_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderProcessHost_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderProcessHost_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint32_t id() const { return at<1>().as_uint32(); }
  bool has_process_lock() const { return at<2>().valid(); }
  ::protozero::ConstChars process_lock() const { return at<2>().as_string(); }
  bool has_child_process_id() const { return at<3>().valid(); }
  int32_t child_process_id() const { return at<3>().as_int32(); }
  bool has_browser_context() const { return at<4>().valid(); }
  ::protozero::ConstBytes browser_context() const { return at<4>().as_bytes(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class RenderProcessHost : public ::protozero::Message {
 public:
  using Decoder = RenderProcessHost_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kProcessLockFieldNumber = 2,
    kChildProcessIdFieldNumber = 3,
    kBrowserContextFieldNumber = 4,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderProcessHost"; }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Id kId() { return {}; }
  void set_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ProcessLock =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      RenderProcessHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProcessLock kProcessLock() { return {}; }
  void set_process_lock(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ProcessLock::kFieldId, data, size);
  }
  void set_process_lock(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ProcessLock::kFieldId, chars.data, chars.size);
  }
  void set_process_lock(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ProcessLock::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ChildProcessId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderProcessHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChildProcessId kChildProcessId() { return {}; }
  void set_child_process_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ChildProcessId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_BrowserContext =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeBrowserContext,
      RenderProcessHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BrowserContext kBrowserContext() { return {}; }
  template <typename T = ChromeBrowserContext> T* set_browser_context() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      RenderProcessHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class ResourceBundle_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ResourceBundle_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ResourceBundle_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ResourceBundle_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_resource_id() const { return at<1>().valid(); }
  uint32_t resource_id() const { return at<1>().as_uint32(); }
};

class ResourceBundle : public ::protozero::Message {
 public:
  using Decoder = ResourceBundle_Decoder;
  enum : int32_t {
    kResourceIdFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ResourceBundle"; }


  using FieldMetadata_ResourceId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ResourceBundle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ResourceId kResourceId() { return {}; }
  void set_resource_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ResourceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class ChromeWebAppBadNavigate_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeWebAppBadNavigate_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeWebAppBadNavigate_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeWebAppBadNavigate_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_is_kiosk() const { return at<1>().valid(); }
  bool is_kiosk() const { return at<1>().as_bool(); }
  bool has_has_hosted_app_controller() const { return at<2>().valid(); }
  bool has_hosted_app_controller() const { return at<2>().as_bool(); }
  bool has_app_name() const { return at<3>().valid(); }
  ::protozero::ConstChars app_name() const { return at<3>().as_string(); }
  bool has_system_app_type() const { return at<4>().valid(); }
  uint32_t system_app_type() const { return at<4>().as_uint32(); }
  bool has_web_app_provider_registry_ready() const { return at<5>().valid(); }
  bool web_app_provider_registry_ready() const { return at<5>().as_bool(); }
  bool has_system_web_app_manager_synchronized() const { return at<6>().valid(); }
  bool system_web_app_manager_synchronized() const { return at<6>().as_bool(); }
};

class ChromeWebAppBadNavigate : public ::protozero::Message {
 public:
  using Decoder = ChromeWebAppBadNavigate_Decoder;
  enum : int32_t {
    kIsKioskFieldNumber = 1,
    kHasHostedAppControllerFieldNumber = 2,
    kAppNameFieldNumber = 3,
    kSystemAppTypeFieldNumber = 4,
    kWebAppProviderRegistryReadyFieldNumber = 5,
    kSystemWebAppManagerSynchronizedFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeWebAppBadNavigate"; }


  using FieldMetadata_IsKiosk =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsKiosk kIsKiosk() { return {}; }
  void set_is_kiosk(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsKiosk::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasHostedAppController =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasHostedAppController kHasHostedAppController() { return {}; }
  void set_has_hosted_app_controller(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasHostedAppController::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AppName =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AppName kAppName() { return {}; }
  void set_app_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_AppName::kFieldId, data, size);
  }
  void set_app_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_AppName::kFieldId, chars.data, chars.size);
  }
  void set_app_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_AppName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SystemAppType =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SystemAppType kSystemAppType() { return {}; }
  void set_system_app_type(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SystemAppType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WebAppProviderRegistryReady =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WebAppProviderRegistryReady kWebAppProviderRegistryReady() { return {}; }
  void set_web_app_provider_registry_ready(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_WebAppProviderRegistryReady::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SystemWebAppManagerSynchronized =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SystemWebAppManagerSynchronized kSystemWebAppManagerSynchronized() { return {}; }
  void set_system_web_app_manager_synchronized(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_SystemWebAppManagerSynchronized::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class ChromeSqlDiagnostics_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ChromeSqlDiagnostics_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeSqlDiagnostics_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeSqlDiagnostics_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_reported_sqlite_error_code() const { return at<1>().valid(); }
  int32_t reported_sqlite_error_code() const { return at<1>().as_int32(); }
  bool has_error_code() const { return at<2>().valid(); }
  int32_t error_code() const { return at<2>().as_int32(); }
  bool has_last_errno() const { return at<3>().valid(); }
  int32_t last_errno() const { return at<3>().as_int32(); }
  bool has_sql_statement() const { return at<4>().valid(); }
  ::protozero::ConstChars sql_statement() const { return at<4>().as_string(); }
  bool has_version() const { return at<5>().valid(); }
  int32_t version() const { return at<5>().as_int32(); }
  bool has_schema_sql_rows() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> schema_sql_rows() const { return GetRepeated<::protozero::ConstChars>(6); }
  bool has_schema_other_row_names() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> schema_other_row_names() const { return GetRepeated<::protozero::ConstChars>(7); }
  bool has_has_valid_header() const { return at<8>().valid(); }
  bool has_valid_header() const { return at<8>().as_bool(); }
  bool has_has_valid_schema() const { return at<9>().valid(); }
  bool has_valid_schema() const { return at<9>().as_bool(); }
  bool has_error_message() const { return at<10>().valid(); }
  ::protozero::ConstChars error_message() const { return at<10>().as_string(); }
};

class ChromeSqlDiagnostics : public ::protozero::Message {
 public:
  using Decoder = ChromeSqlDiagnostics_Decoder;
  enum : int32_t {
    kReportedSqliteErrorCodeFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
    kLastErrnoFieldNumber = 3,
    kSqlStatementFieldNumber = 4,
    kVersionFieldNumber = 5,
    kSchemaSqlRowsFieldNumber = 6,
    kSchemaOtherRowNamesFieldNumber = 7,
    kHasValidHeaderFieldNumber = 8,
    kHasValidSchemaFieldNumber = 9,
    kErrorMessageFieldNumber = 10,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeSqlDiagnostics"; }


  using FieldMetadata_ReportedSqliteErrorCode =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ChromeSqlDiagnostics>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ReportedSqliteErrorCode kReportedSqliteErrorCode() { return {}; }
  void set_reported_sqlite_error_code(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ReportedSqliteErrorCode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ErrorCode =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ChromeSqlDiagnostics>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ErrorCode kErrorCode() { return {}; }
  void set_error_code(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ErrorCode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LastErrno =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ChromeSqlDiagnostics>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LastErrno kLastErrno() { return {}; }
  void set_last_errno(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LastErrno::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SqlStatement =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeSqlDiagnostics>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SqlStatement kSqlStatement() { return {}; }
  void set_sql_statement(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SqlStatement::kFieldId, data, size);
  }
  void set_sql_statement(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SqlStatement::kFieldId, chars.data, chars.size);
  }
  void set_sql_statement(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SqlStatement::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Version =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ChromeSqlDiagnostics>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Version kVersion() { return {}; }
  void set_version(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Version::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SchemaSqlRows =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeSqlDiagnostics>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchemaSqlRows kSchemaSqlRows() { return {}; }
  void add_schema_sql_rows(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SchemaSqlRows::kFieldId, data, size);
  }
  void add_schema_sql_rows(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SchemaSqlRows::kFieldId, chars.data, chars.size);
  }
  void add_schema_sql_rows(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SchemaSqlRows::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SchemaOtherRowNames =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeSqlDiagnostics>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchemaOtherRowNames kSchemaOtherRowNames() { return {}; }
  void add_schema_other_row_names(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SchemaOtherRowNames::kFieldId, data, size);
  }
  void add_schema_other_row_names(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SchemaOtherRowNames::kFieldId, chars.data, chars.size);
  }
  void add_schema_other_row_names(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SchemaOtherRowNames::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasValidHeader =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeSqlDiagnostics>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasValidHeader kHasValidHeader() { return {}; }
  void set_has_valid_header(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasValidHeader::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasValidSchema =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeSqlDiagnostics>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasValidSchema kHasValidSchema() { return {}; }
  void set_has_valid_schema(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasValidSchema::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ErrorMessage =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeSqlDiagnostics>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ErrorMessage kErrorMessage() { return {}; }
  void set_error_message(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ErrorMessage::kFieldId, data, size);
  }
  void set_error_message(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ErrorMessage::kFieldId, chars.data, chars.size);
  }
  void set_error_message(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ErrorMessage::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class ChromeHashedPerformanceMark_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeHashedPerformanceMark_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeHashedPerformanceMark_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeHashedPerformanceMark_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_site_hash() const { return at<1>().valid(); }
  uint32_t site_hash() const { return at<1>().as_uint32(); }
  bool has_site() const { return at<2>().valid(); }
  ::protozero::ConstChars site() const { return at<2>().as_string(); }
  bool has_mark_hash() const { return at<3>().valid(); }
  uint32_t mark_hash() const { return at<3>().as_uint32(); }
  bool has_mark() const { return at<4>().valid(); }
  ::protozero::ConstChars mark() const { return at<4>().as_string(); }
  bool has_execution_context_id() const { return at<5>().valid(); }
  uint32_t execution_context_id() const { return at<5>().as_uint32(); }
  bool has_sequence_number() const { return at<6>().valid(); }
  uint32_t sequence_number() const { return at<6>().as_uint32(); }
};

class ChromeHashedPerformanceMark : public ::protozero::Message {
 public:
  using Decoder = ChromeHashedPerformanceMark_Decoder;
  enum : int32_t {
    kSiteHashFieldNumber = 1,
    kSiteFieldNumber = 2,
    kMarkHashFieldNumber = 3,
    kMarkFieldNumber = 4,
    kExecutionContextIdFieldNumber = 5,
    kSequenceNumberFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeHashedPerformanceMark"; }


  using FieldMetadata_SiteHash =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteHash kSiteHash() { return {}; }
  void set_site_hash(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SiteHash::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Site =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Site kSite() { return {}; }
  void set_site(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Site::kFieldId, data, size);
  }
  void set_site(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Site::kFieldId, chars.data, chars.size);
  }
  void set_site(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Site::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MarkHash =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MarkHash kMarkHash() { return {}; }
  void set_mark_hash(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MarkHash::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Mark =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Mark kMark() { return {}; }
  void set_mark(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Mark::kFieldId, data, size);
  }
  void set_mark(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Mark::kFieldId, chars.data, chars.size);
  }
  void set_mark(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Mark::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ExecutionContextId =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ExecutionContextId kExecutionContextId() { return {}; }
  void set_execution_context_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ExecutionContextId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SequenceNumber =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SequenceNumber kSequenceNumber() { return {}; }
  void set_sequence_number(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SequenceNumber::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class FrameTreeNodeInfo_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FrameTreeNodeInfo_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FrameTreeNodeInfo_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FrameTreeNodeInfo_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_frame_tree_node_id() const { return at<1>().valid(); }
  uint64_t frame_tree_node_id() const { return at<1>().as_uint64(); }
  bool has_is_main_frame() const { return at<2>().valid(); }
  bool is_main_frame() const { return at<2>().as_bool(); }
  bool has_has_speculative_render_frame_host() const { return at<3>().valid(); }
  bool has_speculative_render_frame_host() const { return at<3>().as_bool(); }
  bool has_current_frame_host() const { return at<4>().valid(); }
  ::protozero::ConstBytes current_frame_host() const { return at<4>().as_bytes(); }
  bool has_speculative_frame_host() const { return at<5>().valid(); }
  ::protozero::ConstBytes speculative_frame_host() const { return at<5>().as_bytes(); }
  bool has_frame_type() const { return at<6>().valid(); }
  int32_t frame_type() const { return at<6>().as_int32(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class FrameTreeNodeInfo : public ::protozero::Message {
 public:
  using Decoder = FrameTreeNodeInfo_Decoder;
  enum : int32_t {
    kFrameTreeNodeIdFieldNumber = 1,
    kIsMainFrameFieldNumber = 2,
    kHasSpeculativeRenderFrameHostFieldNumber = 3,
    kCurrentFrameHostFieldNumber = 4,
    kSpeculativeFrameHostFieldNumber = 5,
    kFrameTypeFieldNumber = 6,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FrameTreeNodeInfo"; }


  using FrameType = ::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType;
  static inline const char* FrameType_Name(FrameType value) {
    return ::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType_Name(value);
  }
  static const FrameType UNSPECIFIED_FRAME_TYPE = FrameType::UNSPECIFIED_FRAME_TYPE;
  static const FrameType SUBFRAME = FrameType::SUBFRAME;
  static const FrameType PRIMARY_MAIN_FRAME = FrameType::PRIMARY_MAIN_FRAME;
  static const FrameType PRERENDER_MAIN_FRAME = FrameType::PRERENDER_MAIN_FRAME;
  static const FrameType FENCED_FRAME_ROOT = FrameType::FENCED_FRAME_ROOT;

  using FieldMetadata_FrameTreeNodeId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNodeId kFrameTreeNodeId() { return {}; }
  void set_frame_tree_node_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameTreeNodeId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsMainFrame =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsMainFrame kIsMainFrame() { return {}; }
  void set_is_main_frame(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsMainFrame::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasSpeculativeRenderFrameHost =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasSpeculativeRenderFrameHost kHasSpeculativeRenderFrameHost() { return {}; }
  void set_has_speculative_render_frame_host(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasSpeculativeRenderFrameHost::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CurrentFrameHost =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CurrentFrameHost kCurrentFrameHost() { return {}; }
  template <typename T = RenderFrameHost> T* set_current_frame_host() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_SpeculativeFrameHost =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SpeculativeFrameHost kSpeculativeFrameHost() { return {}; }
  template <typename T = RenderFrameHost> T* set_speculative_frame_host() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_FrameType =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameType kFrameType() { return {}; }
  void set_frame_type(::perfetto::protos::pbzero::FrameTreeNodeInfo_FrameType value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class ShouldSwapBrowsingInstancesResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ShouldSwapBrowsingInstancesResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ShouldSwapBrowsingInstancesResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ShouldSwapBrowsingInstancesResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_frame_tree_node_id() const { return at<1>().valid(); }
  uint64_t frame_tree_node_id() const { return at<1>().as_uint64(); }
  bool has_result() const { return at<2>().valid(); }
  int32_t result() const { return at<2>().as_int32(); }
};

class ShouldSwapBrowsingInstancesResult : public ::protozero::Message {
 public:
  using Decoder = ShouldSwapBrowsingInstancesResult_Decoder;
  enum : int32_t {
    kFrameTreeNodeIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ShouldSwapBrowsingInstancesResult"; }


  using FieldMetadata_FrameTreeNodeId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ShouldSwapBrowsingInstancesResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNodeId kFrameTreeNodeId() { return {}; }
  void set_frame_tree_node_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameTreeNodeId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Result =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance,
      ShouldSwapBrowsingInstancesResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Result kResult() { return {}; }
  void set_result(::perfetto::protos::pbzero::ShouldSwapBrowsingInstance value) {
    static constexpr uint32_t field_id = FieldMetadata_Result::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class RenderFrameImplDeletion_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RenderFrameImplDeletion_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderFrameImplDeletion_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderFrameImplDeletion_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_intent() const { return at<1>().valid(); }
  int32_t intent() const { return at<1>().as_int32(); }
  bool has_has_pending_commit() const { return at<2>().valid(); }
  bool has_pending_commit() const { return at<2>().as_bool(); }
  bool has_has_pending_cross_document_commit() const { return at<3>().valid(); }
  bool has_pending_cross_document_commit() const { return at<3>().as_bool(); }
  bool has_frame_tree_node_id() const { return at<4>().valid(); }
  uint64_t frame_tree_node_id() const { return at<4>().as_uint64(); }
};

class RenderFrameImplDeletion : public ::protozero::Message {
 public:
  using Decoder = RenderFrameImplDeletion_Decoder;
  enum : int32_t {
    kIntentFieldNumber = 1,
    kHasPendingCommitFieldNumber = 2,
    kHasPendingCrossDocumentCommitFieldNumber = 3,
    kFrameTreeNodeIdFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderFrameImplDeletion"; }


  using FieldMetadata_Intent =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::FrameDeleteIntention,
      RenderFrameImplDeletion>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Intent kIntent() { return {}; }
  void set_intent(::perfetto::protos::pbzero::FrameDeleteIntention value) {
    static constexpr uint32_t field_id = FieldMetadata_Intent::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasPendingCommit =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RenderFrameImplDeletion>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasPendingCommit kHasPendingCommit() { return {}; }
  void set_has_pending_commit(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasPendingCommit::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasPendingCrossDocumentCommit =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RenderFrameImplDeletion>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasPendingCrossDocumentCommit kHasPendingCrossDocumentCommit() { return {}; }
  void set_has_pending_cross_document_commit(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasPendingCrossDocumentCommit::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrameTreeNodeId =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      RenderFrameImplDeletion>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNodeId kFrameTreeNodeId() { return {}; }
  void set_frame_tree_node_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameTreeNodeId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class ChromeMessagePumpForUI_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeMessagePumpForUI_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeMessagePumpForUI_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeMessagePumpForUI_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_message_id() const { return at<1>().valid(); }
  uint32_t message_id() const { return at<1>().as_uint32(); }
};

class ChromeMessagePumpForUI : public ::protozero::Message {
 public:
  using Decoder = ChromeMessagePumpForUI_Decoder;
  enum : int32_t {
    kMessageIdFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeMessagePumpForUI"; }


  using FieldMetadata_MessageId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeMessagePumpForUI>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MessageId kMessageId() { return {}; }
  void set_message_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MessageId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class ChromeRasterTask_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeRasterTask_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeRasterTask_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeRasterTask_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_source_frame_number() const { return at<1>().valid(); }
  int64_t source_frame_number() const { return at<1>().as_int64(); }
};

class ChromeRasterTask : public ::protozero::Message {
 public:
  using Decoder = ChromeRasterTask_Decoder;
  enum : int32_t {
    kSourceFrameNumberFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeRasterTask"; }


  using FieldMetadata_SourceFrameNumber =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      ChromeRasterTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SourceFrameNumber kSourceFrameNumber() { return {}; }
  void set_source_frame_number(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SourceFrameNumber::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class ChromeTaskPostedToDisabledQueue_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeTaskPostedToDisabledQueue_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeTaskPostedToDisabledQueue_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeTaskPostedToDisabledQueue_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_task_queue_name() const { return at<1>().valid(); }
  ::protozero::ConstChars task_queue_name() const { return at<1>().as_string(); }
  bool has_time_since_disabled_ms() const { return at<2>().valid(); }
  uint64_t time_since_disabled_ms() const { return at<2>().as_uint64(); }
  bool has_ipc_hash() const { return at<3>().valid(); }
  uint32_t ipc_hash() const { return at<3>().as_uint32(); }
  bool has_source_location_iid() const { return at<4>().valid(); }
  uint64_t source_location_iid() const { return at<4>().as_uint64(); }
};

class ChromeTaskPostedToDisabledQueue : public ::protozero::Message {
 public:
  using Decoder = ChromeTaskPostedToDisabledQueue_Decoder;
  enum : int32_t {
    kTaskQueueNameFieldNumber = 1,
    kTimeSinceDisabledMsFieldNumber = 2,
    kIpcHashFieldNumber = 3,
    kSourceLocationIidFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeTaskPostedToDisabledQueue"; }


  using FieldMetadata_TaskQueueName =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeTaskPostedToDisabledQueue>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TaskQueueName kTaskQueueName() { return {}; }
  void set_task_queue_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_TaskQueueName::kFieldId, data, size);
  }
  void set_task_queue_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_TaskQueueName::kFieldId, chars.data, chars.size);
  }
  void set_task_queue_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_TaskQueueName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TimeSinceDisabledMs =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ChromeTaskPostedToDisabledQueue>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TimeSinceDisabledMs kTimeSinceDisabledMs() { return {}; }
  void set_time_since_disabled_ms(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TimeSinceDisabledMs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IpcHash =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeTaskPostedToDisabledQueue>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IpcHash kIpcHash() { return {}; }
  void set_ipc_hash(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_IpcHash::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SourceLocationIid =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ChromeTaskPostedToDisabledQueue>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SourceLocationIid kSourceLocationIid() { return {}; }
  void set_source_location_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SourceLocationIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class ChromeProfileDestroyer_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeProfileDestroyer_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeProfileDestroyer_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeProfileDestroyer_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_profile_ptr() const { return at<1>().valid(); }
  uint64_t profile_ptr() const { return at<1>().as_uint64(); }
  bool has_is_off_the_record() const { return at<2>().valid(); }
  bool is_off_the_record() const { return at<2>().as_bool(); }
  bool has_otr_profile_id() const { return at<3>().valid(); }
  ::protozero::ConstChars otr_profile_id() const { return at<3>().as_string(); }
  bool has_host_count_at_creation() const { return at<4>().valid(); }
  uint32_t host_count_at_creation() const { return at<4>().as_uint32(); }
  bool has_host_count_at_destruction() const { return at<5>().valid(); }
  uint32_t host_count_at_destruction() const { return at<5>().as_uint32(); }
  bool has_render_process_host_ptr() const { return at<6>().valid(); }
  uint64_t render_process_host_ptr() const { return at<6>().as_uint64(); }
};

class ChromeProfileDestroyer : public ::protozero::Message {
 public:
  using Decoder = ChromeProfileDestroyer_Decoder;
  enum : int32_t {
    kProfilePtrFieldNumber = 1,
    kIsOffTheRecordFieldNumber = 2,
    kOtrProfileIdFieldNumber = 3,
    kHostCountAtCreationFieldNumber = 4,
    kHostCountAtDestructionFieldNumber = 5,
    kRenderProcessHostPtrFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeProfileDestroyer"; }


  using FieldMetadata_ProfilePtr =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProfilePtr kProfilePtr() { return {}; }
  void set_profile_ptr(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ProfilePtr::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFixed64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsOffTheRecord =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsOffTheRecord kIsOffTheRecord() { return {}; }
  void set_is_off_the_record(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsOffTheRecord::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OtrProfileId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_OtrProfileId kOtrProfileId() { return {}; }
  void set_otr_profile_id(const char* data, size_t size) {
    AppendBytes(FieldMetadata_OtrProfileId::kFieldId, data, size);
  }
  void set_otr_profile_id(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_OtrProfileId::kFieldId, chars.data, chars.size);
  }
  void set_otr_profile_id(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_OtrProfileId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HostCountAtCreation =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HostCountAtCreation kHostCountAtCreation() { return {}; }
  void set_host_count_at_creation(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_HostCountAtCreation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HostCountAtDestruction =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HostCountAtDestruction kHostCountAtDestruction() { return {}; }
  void set_host_count_at_destruction(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_HostCountAtDestruction::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RenderProcessHostPtr =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderProcessHostPtr kRenderProcessHostPtr() { return {}; }
  void set_render_process_host_ptr(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RenderProcessHostPtr::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFixed64>
        ::Append(*this, field_id, value);
  }
};

class ChromeBrowserContext_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeBrowserContext_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeBrowserContext_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeBrowserContext_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<2>().valid(); }
  ::protozero::ConstChars id() const { return at<2>().as_string(); }
};

class ChromeBrowserContext : public ::protozero::Message {
 public:
  using Decoder = ChromeBrowserContext_Decoder;
  enum : int32_t {
    kIdFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeBrowserContext"; }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeBrowserContext>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Id kId() { return {}; }
  void set_id(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Id::kFieldId, data, size);
  }
  void set_id(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Id::kFieldId, chars.data, chars.size);
  }
  void set_id(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class ChromeTaskAnnotator_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeTaskAnnotator_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeTaskAnnotator_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeTaskAnnotator_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ipc_hash() const { return at<1>().valid(); }
  uint32_t ipc_hash() const { return at<1>().as_uint32(); }
  bool has_task_delay_us() const { return at<2>().valid(); }
  uint64_t task_delay_us() const { return at<2>().as_uint64(); }
};

class ChromeTaskAnnotator : public ::protozero::Message {
 public:
  using Decoder = ChromeTaskAnnotator_Decoder;
  enum : int32_t {
    kIpcHashFieldNumber = 1,
    kTaskDelayUsFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeTaskAnnotator"; }


  using FieldMetadata_IpcHash =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeTaskAnnotator>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IpcHash kIpcHash() { return {}; }
  void set_ipc_hash(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_IpcHash::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TaskDelayUs =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ChromeTaskAnnotator>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TaskDelayUs kTaskDelayUs() { return {}; }
  void set_task_delay_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TaskDelayUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class BlinkTaskScope_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlinkTaskScope_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlinkTaskScope_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlinkTaskScope_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_type() const { return at<1>().valid(); }
  int32_t type() const { return at<1>().as_int32(); }
  bool has_scope_task_id() const { return at<2>().valid(); }
  int64_t scope_task_id() const { return at<2>().as_int64(); }
  bool has_running_task_id_to_be_restored() const { return at<3>().valid(); }
  int64_t running_task_id_to_be_restored() const { return at<3>().as_int64(); }
  bool has_continuation_task_id_to_be_restored() const { return at<4>().valid(); }
  int64_t continuation_task_id_to_be_restored() const { return at<4>().as_int64(); }
  bool has_parent_task_id() const { return at<5>().valid(); }
  int64_t parent_task_id() const { return at<5>().as_int64(); }
};

class BlinkTaskScope : public ::protozero::Message {
 public:
  using Decoder = BlinkTaskScope_Decoder;
  enum : int32_t {
    kTypeFieldNumber = 1,
    kScopeTaskIdFieldNumber = 2,
    kRunningTaskIdToBeRestoredFieldNumber = 3,
    kContinuationTaskIdToBeRestoredFieldNumber = 4,
    kParentTaskIdFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BlinkTaskScope"; }


  using TaskScopeType = ::perfetto::protos::pbzero::BlinkTaskScope_TaskScopeType;
  static inline const char* TaskScopeType_Name(TaskScopeType value) {
    return ::perfetto::protos::pbzero::BlinkTaskScope_TaskScopeType_Name(value);
  }
  static const TaskScopeType TASK_SCOPE_UNKNOWN = TaskScopeType::TASK_SCOPE_UNKNOWN;
  static const TaskScopeType TASK_SCOPE_CALLBACK = TaskScopeType::TASK_SCOPE_CALLBACK;
  static const TaskScopeType TASK_SCOPE_SCHEDULED_ACTION = TaskScopeType::TASK_SCOPE_SCHEDULED_ACTION;
  static const TaskScopeType TASK_SCOPE_SCRIPT_EXECUTION = TaskScopeType::TASK_SCOPE_SCRIPT_EXECUTION;
  static const TaskScopeType TASK_SCOPE_POST_MESSAGE = TaskScopeType::TASK_SCOPE_POST_MESSAGE;
  static const TaskScopeType TASK_SCOPE_POP_STATE = TaskScopeType::TASK_SCOPE_POP_STATE;

  using FieldMetadata_Type =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::BlinkTaskScope_TaskScopeType,
      BlinkTaskScope>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Type kType() { return {}; }
  void set_type(::perfetto::protos::pbzero::BlinkTaskScope_TaskScopeType value) {
    static constexpr uint32_t field_id = FieldMetadata_Type::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ScopeTaskId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      BlinkTaskScope>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ScopeTaskId kScopeTaskId() { return {}; }
  void set_scope_task_id(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ScopeTaskId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RunningTaskIdToBeRestored =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      BlinkTaskScope>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RunningTaskIdToBeRestored kRunningTaskIdToBeRestored() { return {}; }
  void set_running_task_id_to_be_restored(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RunningTaskIdToBeRestored::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ContinuationTaskIdToBeRestored =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      BlinkTaskScope>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ContinuationTaskIdToBeRestored kContinuationTaskIdToBeRestored() { return {}; }
  void set_continuation_task_id_to_be_restored(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ContinuationTaskIdToBeRestored::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ParentTaskId =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      BlinkTaskScope>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ParentTaskId kParentTaskId() { return {}; }
  void set_parent_task_id(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ParentTaskId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class ChromeMemoryPressureNotification_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeMemoryPressureNotification_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeMemoryPressureNotification_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeMemoryPressureNotification_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_level() const { return at<1>().valid(); }
  int32_t level() const { return at<1>().as_int32(); }
  bool has_creation_location_iid() const { return at<2>().valid(); }
  uint64_t creation_location_iid() const { return at<2>().as_uint64(); }
};

class ChromeMemoryPressureNotification : public ::protozero::Message {
 public:
  using Decoder = ChromeMemoryPressureNotification_Decoder;
  enum : int32_t {
    kLevelFieldNumber = 1,
    kCreationLocationIidFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeMemoryPressureNotification"; }


  using FieldMetadata_Level =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::MemoryPressureLevel,
      ChromeMemoryPressureNotification>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Level kLevel() { return {}; }
  void set_level(::perfetto::protos::pbzero::MemoryPressureLevel value) {
    static constexpr uint32_t field_id = FieldMetadata_Level::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CreationLocationIid =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ChromeMemoryPressureNotification>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CreationLocationIid kCreationLocationIid() { return {}; }
  void set_creation_location_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CreationLocationIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class ChromeTrackEvent : public ::perfetto::protos::pbzero::TrackEvent {
 public:

  using FieldMetadata_ChromeAppState =
    ::protozero::proto_utils::FieldMetadata<
      1000,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChromeAppState,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeAppState kChromeAppState() { return {}; }
  void set_chrome_app_state(::perfetto::protos::pbzero::ChromeAppState value) {
    static constexpr uint32_t field_id = FieldMetadata_ChromeAppState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ChromeMemoryPressureNotification =
    ::protozero::proto_utils::FieldMetadata<
      1001,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeMemoryPressureNotification,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeMemoryPressureNotification kChromeMemoryPressureNotification() { return {}; }
  template <typename T = ChromeMemoryPressureNotification> T* set_chrome_memory_pressure_notification() {
    return BeginNestedMessage<T>(1001);
  }


  using FieldMetadata_ChromeTaskAnnotator =
    ::protozero::proto_utils::FieldMetadata<
      1002,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeTaskAnnotator,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeTaskAnnotator kChromeTaskAnnotator() { return {}; }
  template <typename T = ChromeTaskAnnotator> T* set_chrome_task_annotator() {
    return BeginNestedMessage<T>(1002);
  }


  using FieldMetadata_ChromeBrowserContext =
    ::protozero::proto_utils::FieldMetadata<
      1003,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeBrowserContext,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeBrowserContext kChromeBrowserContext() { return {}; }
  template <typename T = ChromeBrowserContext> T* set_chrome_browser_context() {
    return BeginNestedMessage<T>(1003);
  }


  using FieldMetadata_ChromeProfileDestroyer =
    ::protozero::proto_utils::FieldMetadata<
      1004,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeProfileDestroyer,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeProfileDestroyer kChromeProfileDestroyer() { return {}; }
  template <typename T = ChromeProfileDestroyer> T* set_chrome_profile_destroyer() {
    return BeginNestedMessage<T>(1004);
  }


  using FieldMetadata_ChromeTaskPostedToDisabledQueue =
    ::protozero::proto_utils::FieldMetadata<
      1005,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeTaskPostedToDisabledQueue,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeTaskPostedToDisabledQueue kChromeTaskPostedToDisabledQueue() { return {}; }
  template <typename T = ChromeTaskPostedToDisabledQueue> T* set_chrome_task_posted_to_disabled_queue() {
    return BeginNestedMessage<T>(1005);
  }


  using FieldMetadata_ChromeRasterTask =
    ::protozero::proto_utils::FieldMetadata<
      1006,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeRasterTask,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeRasterTask kChromeRasterTask() { return {}; }
  template <typename T = ChromeRasterTask> T* set_chrome_raster_task() {
    return BeginNestedMessage<T>(1006);
  }


  using FieldMetadata_ChromeMessagePumpForUi =
    ::protozero::proto_utils::FieldMetadata<
      1007,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeMessagePumpForUI,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeMessagePumpForUi kChromeMessagePumpForUi() { return {}; }
  template <typename T = ChromeMessagePumpForUI> T* set_chrome_message_pump_for_ui() {
    return BeginNestedMessage<T>(1007);
  }


  using FieldMetadata_RenderFrameImplDeletion =
    ::protozero::proto_utils::FieldMetadata<
      1008,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameImplDeletion,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderFrameImplDeletion kRenderFrameImplDeletion() { return {}; }
  template <typename T = RenderFrameImplDeletion> T* set_render_frame_impl_deletion() {
    return BeginNestedMessage<T>(1008);
  }


  using FieldMetadata_ShouldSwapBrowsingInstancesResult =
    ::protozero::proto_utils::FieldMetadata<
      1009,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ShouldSwapBrowsingInstancesResult,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ShouldSwapBrowsingInstancesResult kShouldSwapBrowsingInstancesResult() { return {}; }
  template <typename T = ShouldSwapBrowsingInstancesResult> T* set_should_swap_browsing_instances_result() {
    return BeginNestedMessage<T>(1009);
  }


  using FieldMetadata_FrameTreeNodeInfo =
    ::protozero::proto_utils::FieldMetadata<
      1010,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FrameTreeNodeInfo,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNodeInfo kFrameTreeNodeInfo() { return {}; }
  template <typename T = FrameTreeNodeInfo> T* set_frame_tree_node_info() {
    return BeginNestedMessage<T>(1010);
  }


  using FieldMetadata_ChromeHashedPerformanceMark =
    ::protozero::proto_utils::FieldMetadata<
      1011,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeHashedPerformanceMark,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeHashedPerformanceMark kChromeHashedPerformanceMark() { return {}; }
  template <typename T = ChromeHashedPerformanceMark> T* set_chrome_hashed_performance_mark() {
    return BeginNestedMessage<T>(1011);
  }


  using FieldMetadata_RenderProcessHost =
    ::protozero::proto_utils::FieldMetadata<
      1012,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHost,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderProcessHost kRenderProcessHost() { return {}; }
  template <typename T = RenderProcessHost> T* set_render_process_host() {
    return BeginNestedMessage<T>(1012);
  }


  using FieldMetadata_RenderProcessHostCleanup =
    ::protozero::proto_utils::FieldMetadata<
      1013,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHostCleanup,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderProcessHostCleanup kRenderProcessHostCleanup() { return {}; }
  template <typename T = RenderProcessHostCleanup> T* set_render_process_host_cleanup() {
    return BeginNestedMessage<T>(1013);
  }


  using FieldMetadata_RenderProcessHostListenerChanged =
    ::protozero::proto_utils::FieldMetadata<
      1014,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHostListener,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderProcessHostListenerChanged kRenderProcessHostListenerChanged() { return {}; }
  template <typename T = RenderProcessHostListener> T* set_render_process_host_listener_changed() {
    return BeginNestedMessage<T>(1014);
  }


  using FieldMetadata_ChildProcessLauncherPriority =
    ::protozero::proto_utils::FieldMetadata<
      1015,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChildProcessLauncherPriority,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChildProcessLauncherPriority kChildProcessLauncherPriority() { return {}; }
  template <typename T = ChildProcessLauncherPriority> T* set_child_process_launcher_priority() {
    return BeginNestedMessage<T>(1015);
  }


  using FieldMetadata_ResourceBundle =
    ::protozero::proto_utils::FieldMetadata<
      1016,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ResourceBundle,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ResourceBundle kResourceBundle() { return {}; }
  template <typename T = ResourceBundle> T* set_resource_bundle() {
    return BeginNestedMessage<T>(1016);
  }


  using FieldMetadata_ChromeWebAppBadNavigate =
    ::protozero::proto_utils::FieldMetadata<
      1017,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeWebAppBadNavigate,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeWebAppBadNavigate kChromeWebAppBadNavigate() { return {}; }
  template <typename T = ChromeWebAppBadNavigate> T* set_chrome_web_app_bad_navigate() {
    return BeginNestedMessage<T>(1017);
  }


  using FieldMetadata_ChromeExtensionId =
    ::protozero::proto_utils::FieldMetadata<
      1018,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeExtensionId,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeExtensionId kChromeExtensionId() { return {}; }
  template <typename T = ChromeExtensionId> T* set_chrome_extension_id() {
    return BeginNestedMessage<T>(1018);
  }


  using FieldMetadata_SiteInstance =
    ::protozero::proto_utils::FieldMetadata<
      1019,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SiteInstance,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstance kSiteInstance() { return {}; }
  template <typename T = SiteInstance> T* set_site_instance() {
    return BeginNestedMessage<T>(1019);
  }


  using FieldMetadata_RenderViewHost =
    ::protozero::proto_utils::FieldMetadata<
      1020,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderViewHost,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderViewHost kRenderViewHost() { return {}; }
  template <typename T = RenderViewHost> T* set_render_view_host() {
    return BeginNestedMessage<T>(1020);
  }


  using FieldMetadata_RenderFrameProxyHost =
    ::protozero::proto_utils::FieldMetadata<
      1021,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameProxyHost,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderFrameProxyHost kRenderFrameProxyHost() { return {}; }
  template <typename T = RenderFrameProxyHost> T* set_render_frame_proxy_host() {
    return BeginNestedMessage<T>(1021);
  }


  using FieldMetadata_AndroidViewDump =
    ::protozero::proto_utils::FieldMetadata<
      1022,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AndroidViewDump,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AndroidViewDump kAndroidViewDump() { return {}; }
  template <typename T = AndroidViewDump> T* set_android_view_dump() {
    return BeginNestedMessage<T>(1022);
  }


  using FieldMetadata_ParkableStringCompressInBackground =
    ::protozero::proto_utils::FieldMetadata<
      1023,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ParkableStringCompressInBackground,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ParkableStringCompressInBackground kParkableStringCompressInBackground() { return {}; }
  template <typename T = ParkableStringCompressInBackground> T* set_parkable_string_compress_in_background() {
    return BeginNestedMessage<T>(1023);
  }


  using FieldMetadata_ParkableStringUnpark =
    ::protozero::proto_utils::FieldMetadata<
      1024,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ParkableStringUnpark,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ParkableStringUnpark kParkableStringUnpark() { return {}; }
  template <typename T = ParkableStringUnpark> T* set_parkable_string_unpark() {
    return BeginNestedMessage<T>(1024);
  }


  using FieldMetadata_ChromeSamplingProfilerSampleCompleted =
    ::protozero::proto_utils::FieldMetadata<
      1025,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeSamplingProfilerSampleCollected,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeSamplingProfilerSampleCompleted kChromeSamplingProfilerSampleCompleted() { return {}; }
  template <typename T = ChromeSamplingProfilerSampleCollected> T* set_chrome_sampling_profiler_sample_completed() {
    return BeginNestedMessage<T>(1025);
  }


  using FieldMetadata_SendBeginMainframeToCommitBreakdown =
    ::protozero::proto_utils::FieldMetadata<
      1026,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SendBeginMainFrameToCommitBreakdown,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SendBeginMainframeToCommitBreakdown kSendBeginMainframeToCommitBreakdown() { return {}; }
  template <typename T = SendBeginMainFrameToCommitBreakdown> T* set_send_begin_mainframe_to_commit_breakdown() {
    return BeginNestedMessage<T>(1026);
  }


  using FieldMetadata_GlobalRenderFrameHostId =
    ::protozero::proto_utils::FieldMetadata<
      1027,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      GlobalRenderFrameHostId,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_GlobalRenderFrameHostId kGlobalRenderFrameHostId() { return {}; }
  template <typename T = GlobalRenderFrameHostId> T* set_global_render_frame_host_id() {
    return BeginNestedMessage<T>(1027);
  }


  using FieldMetadata_RenderFrameHost =
    ::protozero::proto_utils::FieldMetadata<
      1028,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderFrameHost kRenderFrameHost() { return {}; }
  template <typename T = RenderFrameHost> T* set_render_frame_host() {
    return BeginNestedMessage<T>(1028);
  }


  using FieldMetadata_ThreadPoolTask =
    ::protozero::proto_utils::FieldMetadata<
      1029,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeThreadPoolTask,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ThreadPoolTask kThreadPoolTask() { return {}; }
  template <typename T = ChromeThreadPoolTask> T* set_thread_pool_task() {
    return BeginNestedMessage<T>(1029);
  }


  using FieldMetadata_BackForwardCacheCanStoreDocumentResult =
    ::protozero::proto_utils::FieldMetadata<
      1030,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BackForwardCacheCanStoreDocumentResult,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BackForwardCacheCanStoreDocumentResult kBackForwardCacheCanStoreDocumentResult() { return {}; }
  template <typename T = BackForwardCacheCanStoreDocumentResult> T* set_back_forward_cache_can_store_document_result() {
    return BeginNestedMessage<T>(1030);
  }


  using FieldMetadata_RendererMainThreadTaskExecution =
    ::protozero::proto_utils::FieldMetadata<
      1031,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RendererMainThreadTaskExecution,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RendererMainThreadTaskExecution kRendererMainThreadTaskExecution() { return {}; }
  template <typename T = RendererMainThreadTaskExecution> T* set_renderer_main_thread_task_execution() {
    return BeginNestedMessage<T>(1031);
  }


  using FieldMetadata_EventLatency =
    ::protozero::proto_utils::FieldMetadata<
      1032,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      EventLatency,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_EventLatency kEventLatency() { return {}; }
  template <typename T = EventLatency> T* set_event_latency() {
    return BeginNestedMessage<T>(1032);
  }


  using FieldMetadata_ProcessSingleton =
    ::protozero::proto_utils::FieldMetadata<
      1033,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ProcessSingleton,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProcessSingleton kProcessSingleton() { return {}; }
  template <typename T = ProcessSingleton> T* set_process_singleton() {
    return BeginNestedMessage<T>(1033);
  }


  using FieldMetadata_SiteInstanceGroup =
    ::protozero::proto_utils::FieldMetadata<
      1034,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SiteInstanceGroup,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceGroup kSiteInstanceGroup() { return {}; }
  template <typename T = SiteInstanceGroup> T* set_site_instance_group() {
    return BeginNestedMessage<T>(1034);
  }


  using FieldMetadata_BrowsingContextState =
    ::protozero::proto_utils::FieldMetadata<
      1035,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BrowsingContextState,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BrowsingContextState kBrowsingContextState() { return {}; }
  template <typename T = BrowsingContextState> T* set_browsing_context_state() {
    return BeginNestedMessage<T>(1035);
  }


  using FieldMetadata_DeviceThermalState =
    ::protozero::proto_utils::FieldMetadata<
      1036,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::DeviceThermalState,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DeviceThermalState kDeviceThermalState() { return {}; }
  void set_device_thermal_state(::perfetto::protos::pbzero::DeviceThermalState value) {
    static constexpr uint32_t field_id = FieldMetadata_DeviceThermalState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Navigation =
    ::protozero::proto_utils::FieldMetadata<
      1037,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      NavigationHandle,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Navigation kNavigation() { return {}; }
  template <typename T = NavigationHandle> T* set_navigation() {
    return BeginNestedMessage<T>(1037);
  }


  using FieldMetadata_AndroidIpc =
    ::protozero::proto_utils::FieldMetadata<
      1038,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AndroidIPC,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AndroidIpc kAndroidIpc() { return {}; }
  template <typename T = AndroidIPC> T* set_android_ipc() {
    return BeginNestedMessage<T>(1038);
  }


  using FieldMetadata_SqlDiagnostics =
    ::protozero::proto_utils::FieldMetadata<
      1039,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeSqlDiagnostics,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SqlDiagnostics kSqlDiagnostics() { return {}; }
  template <typename T = ChromeSqlDiagnostics> T* set_sql_diagnostics() {
    return BeginNestedMessage<T>(1039);
  }


  using FieldMetadata_SequenceManagerTask =
    ::protozero::proto_utils::FieldMetadata<
      1040,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SequenceManagerTask,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SequenceManagerTask kSequenceManagerTask() { return {}; }
  template <typename T = SequenceManagerTask> T* set_sequence_manager_task() {
    return BeginNestedMessage<T>(1040);
  }


  using FieldMetadata_AndroidToolbar =
    ::protozero::proto_utils::FieldMetadata<
      1041,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AndroidToolbar,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AndroidToolbar kAndroidToolbar() { return {}; }
  template <typename T = AndroidToolbar> T* set_android_toolbar() {
    return BeginNestedMessage<T>(1041);
  }


  using FieldMetadata_ActiveProcesses =
    ::protozero::proto_utils::FieldMetadata<
      1042,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ActiveProcesses,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ActiveProcesses kActiveProcesses() { return {}; }
  template <typename T = ActiveProcesses> T* set_active_processes() {
    return BeginNestedMessage<T>(1042);
  }


  using FieldMetadata_BlinkTaskScope =
    ::protozero::proto_utils::FieldMetadata<
      1043,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlinkTaskScope,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlinkTaskScope kBlinkTaskScope() { return {}; }
  template <typename T = BlinkTaskScope> T* set_blink_task_scope() {
    return BeginNestedMessage<T>(1043);
  }


  using FieldMetadata_UkmPageLoadTimingUpdate =
    ::protozero::proto_utils::FieldMetadata<
      1044,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      UkmPageLoadTimingUpdate,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_UkmPageLoadTimingUpdate kUkmPageLoadTimingUpdate() { return {}; }
  template <typename T = UkmPageLoadTimingUpdate> T* set_ukm_page_load_timing_update() {
    return BeginNestedMessage<T>(1044);
  }


  using FieldMetadata_HighEntropyApi =
    ::protozero::proto_utils::FieldMetadata<
      1045,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlinkHighEntropyAPI,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HighEntropyApi kHighEntropyApi() { return {}; }
  template <typename T = BlinkHighEntropyAPI> T* set_high_entropy_api() {
    return BeginNestedMessage<T>(1045);
  }

};
} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
